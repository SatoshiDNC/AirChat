<html>
<head>
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="manifest.json" />
<meta name="viewport" content="width=device-width">
<meta charset="UTF-8">
<script src="3rd-party/qr-scanner.min.js" type="module"></script>
<script src="3rd-party/qr-scanner-worker.min.js" type="module"></script>
<script type="module" charset="utf-8">
const releasebuild = false;
/*!
@fileoverview gl-matrix - High performance matrix and vector operations
@author Brandon Jones
@author Colin MacKenzie IV
@version 2.7.0

Copyright (c) 2015-2018, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
!function(t,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define([],n);else{var r=n();for(var a in r)("object"==typeof exports?exports:t)[a]=r[a]}}("undefined"!=typeof self?self:this,function(){return function(t){var n={};function r(a){if(n[a])return n[a].exports;var e=n[a]={i:a,l:!1,exports:{}};return t[a].call(e.exports,e,e.exports,r),e.l=!0,e.exports}return r.m=t,r.c=n,r.d=function(t,n,a){r.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:a})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,n){if(1&n&&(t=r(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var a=Object.create(null);if(r.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var e in t)r.d(a,e,function(n){return t[n]}.bind(null,e));return a},r.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(n,"a",n),n},r.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},r.p="",r(r.s=10)}([function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.setMatrixArrayType=function(t){n.ARRAY_TYPE=t},n.toRadian=function(t){return t*e},n.equals=function(t,n){return Math.abs(t-n)<=a*Math.max(1,Math.abs(t),Math.abs(n))};var a=n.EPSILON=1e-6;n.ARRAY_TYPE="undefined"!=typeof Float32Array?Float32Array:Array,n.RANDOM=Math.random;var e=Math.PI/180},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.forEach=n.sqrLen=n.len=n.sqrDist=n.dist=n.div=n.mul=n.sub=void 0,n.create=e,n.clone=function(t){var n=new a.ARRAY_TYPE(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n},n.fromValues=function(t,n,r,e){var u=new a.ARRAY_TYPE(4);return u[0]=t,u[1]=n,u[2]=r,u[3]=e,u},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t},n.set=function(t,n,r,a,e){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t},n.subtract=u,n.multiply=o,n.divide=i,n.ceil=function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t[3]=Math.ceil(n[3]),t},n.floor=function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t[3]=Math.floor(n[3]),t},n.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t[2]=Math.min(n[2],r[2]),t[3]=Math.min(n[3],r[3]),t},n.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t[2]=Math.max(n[2],r[2]),t[3]=Math.max(n[3],r[3]),t},n.round=function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t[3]=Math.round(n[3]),t},n.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t},n.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t},n.distance=s,n.squaredDistance=c,n.length=f,n.squaredLength=M,n.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t},n.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t[3]=1/n[3],t},n.normalize=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*r+a*a+e*e+u*u;o>0&&(o=1/Math.sqrt(o),t[0]=r*o,t[1]=a*o,t[2]=e*o,t[3]=u*o);return t},n.dot=function(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]+t[3]*n[3]},n.lerp=function(t,n,r,a){var e=n[0],u=n[1],o=n[2],i=n[3];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t[2]=o+a*(r[2]-o),t[3]=i+a*(r[3]-i),t},n.random=function(t,n){var r,e,u,o,i,s;n=n||1;do{r=2*a.RANDOM()-1,e=2*a.RANDOM()-1,i=r*r+e*e}while(i>=1);do{u=2*a.RANDOM()-1,o=2*a.RANDOM()-1,s=u*u+o*o}while(s>=1);var c=Math.sqrt((1-i)/s);return t[0]=n*r,t[1]=n*e,t[2]=n*u*c,t[3]=n*o*c,t},n.transformMat4=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3];return t[0]=r[0]*a+r[4]*e+r[8]*u+r[12]*o,t[1]=r[1]*a+r[5]*e+r[9]*u+r[13]*o,t[2]=r[2]*a+r[6]*e+r[10]*u+r[14]*o,t[3]=r[3]*a+r[7]*e+r[11]*u+r[15]*o,t},n.transformQuat=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[0],i=r[1],s=r[2],c=r[3],f=c*a+i*u-s*e,M=c*e+s*a-o*u,h=c*u+o*e-i*a,l=-o*a-i*e-s*u;return t[0]=f*c+l*-o+M*-s-h*-i,t[1]=M*c+l*-i+h*-o-f*-s,t[2]=h*c+l*-s+f*-i-M*-o,t[3]=n[3],t},n.str=function(t){return"vec4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=n[0],s=n[1],c=n[2],f=n[3];return Math.abs(r-i)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(e-s)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(s))&&Math.abs(u-c)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(c))&&Math.abs(o-f)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(f))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(){var t=new a.ARRAY_TYPE(4);return a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t}function o(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t[2]=n[2]*r[2],t[3]=n[3]*r[3],t}function i(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t[2]=n[2]/r[2],t[3]=n[3]/r[3],t}function s(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2],u=n[3]-t[3];return Math.sqrt(r*r+a*a+e*e+u*u)}function c(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2],u=n[3]-t[3];return r*r+a*a+e*e+u*u}function f(t){var n=t[0],r=t[1],a=t[2],e=t[3];return Math.sqrt(n*n+r*r+a*a+e*e)}function M(t){var n=t[0],r=t[1],a=t[2],e=t[3];return n*n+r*r+a*a+e*e}n.sub=u,n.mul=o,n.div=i,n.dist=s,n.sqrDist=c,n.len=f,n.sqrLen=M,n.forEach=function(){var t=e();return function(n,r,a,e,u,o){var i=void 0,s=void 0;for(r||(r=4),a||(a=0),s=e?Math.min(e*r+a,n.length):n.length,i=a;i<s;i+=r)t[0]=n[i],t[1]=n[i+1],t[2]=n[i+2],t[3]=n[i+3],u(t,t,o),n[i]=t[0],n[i+1]=t[1],n[i+2]=t[2],n[i+3]=t[3];return n}}()},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.forEach=n.sqrLen=n.len=n.sqrDist=n.dist=n.div=n.mul=n.sub=void 0,n.create=e,n.clone=function(t){var n=new a.ARRAY_TYPE(3);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n},n.length=u,n.fromValues=o,n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t},n.set=function(t,n,r,a){return t[0]=n,t[1]=r,t[2]=a,t},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t},n.subtract=i,n.multiply=s,n.divide=c,n.ceil=function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t},n.floor=function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t},n.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t[2]=Math.min(n[2],r[2]),t},n.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t[2]=Math.max(n[2],r[2]),t},n.round=function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t},n.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t},n.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t},n.distance=f,n.squaredDistance=M,n.squaredLength=h,n.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t},n.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t},n.normalize=l,n.dot=v,n.cross=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[0],i=r[1],s=r[2];return t[0]=e*s-u*i,t[1]=u*o-a*s,t[2]=a*i-e*o,t},n.lerp=function(t,n,r,a){var e=n[0],u=n[1],o=n[2];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t[2]=o+a*(r[2]-o),t},n.hermite=function(t,n,r,a,e,u){var o=u*u,i=o*(2*u-3)+1,s=o*(u-2)+u,c=o*(u-1),f=o*(3-2*u);return t[0]=n[0]*i+r[0]*s+a[0]*c+e[0]*f,t[1]=n[1]*i+r[1]*s+a[1]*c+e[1]*f,t[2]=n[2]*i+r[2]*s+a[2]*c+e[2]*f,t},n.bezier=function(t,n,r,a,e,u){var o=1-u,i=o*o,s=u*u,c=i*o,f=3*u*i,M=3*s*o,h=s*u;return t[0]=n[0]*c+r[0]*f+a[0]*M+e[0]*h,t[1]=n[1]*c+r[1]*f+a[1]*M+e[1]*h,t[2]=n[2]*c+r[2]*f+a[2]*M+e[2]*h,t},n.random=function(t,n){n=n||1;var r=2*a.RANDOM()*Math.PI,e=2*a.RANDOM()-1,u=Math.sqrt(1-e*e)*n;return t[0]=Math.cos(r)*u,t[1]=Math.sin(r)*u,t[2]=e*n,t},n.transformMat4=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[3]*a+r[7]*e+r[11]*u+r[15];return o=o||1,t[0]=(r[0]*a+r[4]*e+r[8]*u+r[12])/o,t[1]=(r[1]*a+r[5]*e+r[9]*u+r[13])/o,t[2]=(r[2]*a+r[6]*e+r[10]*u+r[14])/o,t},n.transformMat3=function(t,n,r){var a=n[0],e=n[1],u=n[2];return t[0]=a*r[0]+e*r[3]+u*r[6],t[1]=a*r[1]+e*r[4]+u*r[7],t[2]=a*r[2]+e*r[5]+u*r[8],t},n.transformQuat=function(t,n,r){var a=r[0],e=r[1],u=r[2],o=r[3],i=n[0],s=n[1],c=n[2],f=e*c-u*s,M=u*i-a*c,h=a*s-e*i,l=e*h-u*M,v=u*f-a*h,d=a*M-e*f,b=2*o;return f*=b,M*=b,h*=b,l*=2,v*=2,d*=2,t[0]=i+f+l,t[1]=s+M+v,t[2]=c+h+d,t},n.rotateX=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[0],u[1]=e[1]*Math.cos(a)-e[2]*Math.sin(a),u[2]=e[1]*Math.sin(a)+e[2]*Math.cos(a),t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},n.rotateY=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[2]*Math.sin(a)+e[0]*Math.cos(a),u[1]=e[1],u[2]=e[2]*Math.cos(a)-e[0]*Math.sin(a),t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},n.rotateZ=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[0]*Math.cos(a)-e[1]*Math.sin(a),u[1]=e[0]*Math.sin(a)+e[1]*Math.cos(a),u[2]=e[2],t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},n.angle=function(t,n){var r=o(t[0],t[1],t[2]),a=o(n[0],n[1],n[2]);l(r,r),l(a,a);var e=v(r,a);return e>1?0:e<-1?Math.PI:Math.acos(e)},n.str=function(t){return"vec3("+t[0]+", "+t[1]+", "+t[2]+")"},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=n[0],i=n[1],s=n[2];return Math.abs(r-o)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(o))&&Math.abs(e-i)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(i))&&Math.abs(u-s)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(s))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(){var t=new a.ARRAY_TYPE(3);return a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function u(t){var n=t[0],r=t[1],a=t[2];return Math.sqrt(n*n+r*r+a*a)}function o(t,n,r){var e=new a.ARRAY_TYPE(3);return e[0]=t,e[1]=n,e[2]=r,e}function i(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t}function s(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t[2]=n[2]*r[2],t}function c(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t[2]=n[2]/r[2],t}function f(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2];return Math.sqrt(r*r+a*a+e*e)}function M(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2];return r*r+a*a+e*e}function h(t){var n=t[0],r=t[1],a=t[2];return n*n+r*r+a*a}function l(t,n){var r=n[0],a=n[1],e=n[2],u=r*r+a*a+e*e;return u>0&&(u=1/Math.sqrt(u),t[0]=n[0]*u,t[1]=n[1]*u,t[2]=n[2]*u),t}function v(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}n.sub=i,n.mul=s,n.div=c,n.dist=f,n.sqrDist=M,n.len=u,n.sqrLen=h,n.forEach=function(){var t=e();return function(n,r,a,e,u,o){var i=void 0,s=void 0;for(r||(r=3),a||(a=0),s=e?Math.min(e*r+a,n.length):n.length,i=a;i<s;i+=r)t[0]=n[i],t[1]=n[i+1],t[2]=n[i+2],u(t,t,o),n[i]=t[0],n[i+1]=t[1],n[i+2]=t[2];return n}}()},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.setAxes=n.sqlerp=n.rotationTo=n.equals=n.exactEquals=n.normalize=n.sqrLen=n.squaredLength=n.len=n.length=n.lerp=n.dot=n.scale=n.mul=n.add=n.set=n.copy=n.fromValues=n.clone=void 0,n.create=s,n.identity=function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},n.setAxisAngle=c,n.getAxisAngle=function(t,n){var r=2*Math.acos(n[3]),e=Math.sin(r/2);e>a.EPSILON?(t[0]=n[0]/e,t[1]=n[1]/e,t[2]=n[2]/e):(t[0]=1,t[1]=0,t[2]=0);return r},n.multiply=f,n.rotateX=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),s=Math.cos(r);return t[0]=a*s+o*i,t[1]=e*s+u*i,t[2]=u*s-e*i,t[3]=o*s-a*i,t},n.rotateY=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),s=Math.cos(r);return t[0]=a*s-u*i,t[1]=e*s+o*i,t[2]=u*s+a*i,t[3]=o*s-e*i,t},n.rotateZ=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),s=Math.cos(r);return t[0]=a*s+e*i,t[1]=e*s-a*i,t[2]=u*s+o*i,t[3]=o*s-u*i,t},n.calculateW=function(t,n){var r=n[0],a=n[1],e=n[2];return t[0]=r,t[1]=a,t[2]=e,t[3]=Math.sqrt(Math.abs(1-r*r-a*a-e*e)),t},n.slerp=M,n.random=function(t){var n=a.RANDOM(),r=a.RANDOM(),e=a.RANDOM(),u=Math.sqrt(1-n),o=Math.sqrt(n);return t[0]=u*Math.sin(2*Math.PI*r),t[1]=u*Math.cos(2*Math.PI*r),t[2]=o*Math.sin(2*Math.PI*e),t[3]=o*Math.cos(2*Math.PI*e),t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*r+a*a+e*e+u*u,i=o?1/o:0;return t[0]=-r*i,t[1]=-a*i,t[2]=-e*i,t[3]=u*i,t},n.conjugate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t},n.fromMat3=h,n.fromEuler=function(t,n,r,a){var e=.5*Math.PI/180;n*=e,r*=e,a*=e;var u=Math.sin(n),o=Math.cos(n),i=Math.sin(r),s=Math.cos(r),c=Math.sin(a),f=Math.cos(a);return t[0]=u*s*f-o*i*c,t[1]=o*i*f+u*s*c,t[2]=o*s*c-u*i*f,t[3]=o*s*f+u*i*c,t},n.str=function(t){return"quat("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"};var a=i(r(0)),e=i(r(5)),u=i(r(2)),o=i(r(1));function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}function s(){var t=new a.ARRAY_TYPE(4);return a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}function c(t,n,r){r*=.5;var a=Math.sin(r);return t[0]=a*n[0],t[1]=a*n[1],t[2]=a*n[2],t[3]=Math.cos(r),t}function f(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],s=r[1],c=r[2],f=r[3];return t[0]=a*f+o*i+e*c-u*s,t[1]=e*f+o*s+u*i-a*c,t[2]=u*f+o*c+a*s-e*i,t[3]=o*f-a*i-e*s-u*c,t}function M(t,n,r,e){var u=n[0],o=n[1],i=n[2],s=n[3],c=r[0],f=r[1],M=r[2],h=r[3],l=void 0,v=void 0,d=void 0,b=void 0,m=void 0;return(v=u*c+o*f+i*M+s*h)<0&&(v=-v,c=-c,f=-f,M=-M,h=-h),1-v>a.EPSILON?(l=Math.acos(v),d=Math.sin(l),b=Math.sin((1-e)*l)/d,m=Math.sin(e*l)/d):(b=1-e,m=e),t[0]=b*u+m*c,t[1]=b*o+m*f,t[2]=b*i+m*M,t[3]=b*s+m*h,t}function h(t,n){var r=n[0]+n[4]+n[8],a=void 0;if(r>0)a=Math.sqrt(r+1),t[3]=.5*a,a=.5/a,t[0]=(n[5]-n[7])*a,t[1]=(n[6]-n[2])*a,t[2]=(n[1]-n[3])*a;else{var e=0;n[4]>n[0]&&(e=1),n[8]>n[3*e+e]&&(e=2);var u=(e+1)%3,o=(e+2)%3;a=Math.sqrt(n[3*e+e]-n[3*u+u]-n[3*o+o]+1),t[e]=.5*a,a=.5/a,t[3]=(n[3*u+o]-n[3*o+u])*a,t[u]=(n[3*u+e]+n[3*e+u])*a,t[o]=(n[3*o+e]+n[3*e+o])*a}return t}n.clone=o.clone,n.fromValues=o.fromValues,n.copy=o.copy,n.set=o.set,n.add=o.add,n.mul=f,n.scale=o.scale,n.dot=o.dot,n.lerp=o.lerp;var l=n.length=o.length,v=(n.len=l,n.squaredLength=o.squaredLength),d=(n.sqrLen=v,n.normalize=o.normalize);n.exactEquals=o.exactEquals,n.equals=o.equals,n.rotationTo=function(){var t=u.create(),n=u.fromValues(1,0,0),r=u.fromValues(0,1,0);return function(a,e,o){var i=u.dot(e,o);return i<-.999999?(u.cross(t,n,e),u.len(t)<1e-6&&u.cross(t,r,e),u.normalize(t,t),c(a,t,Math.PI),a):i>.999999?(a[0]=0,a[1]=0,a[2]=0,a[3]=1,a):(u.cross(t,e,o),a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=1+i,d(a,a))}}(),n.sqlerp=function(){var t=s(),n=s();return function(r,a,e,u,o,i){return M(t,a,o,i),M(n,e,u,i),M(r,t,n,2*i*(1-i)),r}}(),n.setAxes=function(){var t=e.create();return function(n,r,a,e){return t[0]=a[0],t[3]=a[1],t[6]=a[2],t[1]=e[0],t[4]=e[1],t[7]=e[2],t[2]=-r[0],t[5]=-r[1],t[8]=-r[2],d(n,h(n,t))}}()},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=function(){var t=new a.ARRAY_TYPE(16);a.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0);return t[0]=1,t[5]=1,t[10]=1,t[15]=1,t},n.clone=function(t){var n=new a.ARRAY_TYPE(16);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t},n.fromValues=function(t,n,r,e,u,o,i,s,c,f,M,h,l,v,d,b){var m=new a.ARRAY_TYPE(16);return m[0]=t,m[1]=n,m[2]=r,m[3]=e,m[4]=u,m[5]=o,m[6]=i,m[7]=s,m[8]=c,m[9]=f,m[10]=M,m[11]=h,m[12]=l,m[13]=v,m[14]=d,m[15]=b,m},n.set=function(t,n,r,a,e,u,o,i,s,c,f,M,h,l,v,d,b){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t[4]=u,t[5]=o,t[6]=i,t[7]=s,t[8]=c,t[9]=f,t[10]=M,t[11]=h,t[12]=l,t[13]=v,t[14]=d,t[15]=b,t},n.identity=e,n.transpose=function(t,n){if(t===n){var r=n[1],a=n[2],e=n[3],u=n[6],o=n[7],i=n[11];t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=r,t[6]=n[9],t[7]=n[13],t[8]=a,t[9]=u,t[11]=n[14],t[12]=e,t[13]=o,t[14]=i}else t[0]=n[0],t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=n[1],t[5]=n[5],t[6]=n[9],t[7]=n[13],t[8]=n[2],t[9]=n[6],t[10]=n[10],t[11]=n[14],t[12]=n[3],t[13]=n[7],t[14]=n[11],t[15]=n[15];return t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8],M=n[9],h=n[10],l=n[11],v=n[12],d=n[13],b=n[14],m=n[15],p=r*i-a*o,P=r*s-e*o,A=r*c-u*o,E=a*s-e*i,O=a*c-u*i,R=e*c-u*s,y=f*d-M*v,q=f*b-h*v,x=f*m-l*v,_=M*b-h*d,Y=M*m-l*d,L=h*m-l*b,S=p*L-P*Y+A*_+E*x-O*q+R*y;if(!S)return null;return S=1/S,t[0]=(i*L-s*Y+c*_)*S,t[1]=(e*Y-a*L-u*_)*S,t[2]=(d*R-b*O+m*E)*S,t[3]=(h*O-M*R-l*E)*S,t[4]=(s*x-o*L-c*q)*S,t[5]=(r*L-e*x+u*q)*S,t[6]=(b*A-v*R-m*P)*S,t[7]=(f*R-h*A+l*P)*S,t[8]=(o*Y-i*x+c*y)*S,t[9]=(a*x-r*Y-u*y)*S,t[10]=(v*O-d*A+m*p)*S,t[11]=(M*A-f*O-l*p)*S,t[12]=(i*q-o*_-s*y)*S,t[13]=(r*_-a*q+e*y)*S,t[14]=(d*P-v*E-b*p)*S,t[15]=(f*E-M*P+h*p)*S,t},n.adjoint=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8],M=n[9],h=n[10],l=n[11],v=n[12],d=n[13],b=n[14],m=n[15];return t[0]=i*(h*m-l*b)-M*(s*m-c*b)+d*(s*l-c*h),t[1]=-(a*(h*m-l*b)-M*(e*m-u*b)+d*(e*l-u*h)),t[2]=a*(s*m-c*b)-i*(e*m-u*b)+d*(e*c-u*s),t[3]=-(a*(s*l-c*h)-i*(e*l-u*h)+M*(e*c-u*s)),t[4]=-(o*(h*m-l*b)-f*(s*m-c*b)+v*(s*l-c*h)),t[5]=r*(h*m-l*b)-f*(e*m-u*b)+v*(e*l-u*h),t[6]=-(r*(s*m-c*b)-o*(e*m-u*b)+v*(e*c-u*s)),t[7]=r*(s*l-c*h)-o*(e*l-u*h)+f*(e*c-u*s),t[8]=o*(M*m-l*d)-f*(i*m-c*d)+v*(i*l-c*M),t[9]=-(r*(M*m-l*d)-f*(a*m-u*d)+v*(a*l-u*M)),t[10]=r*(i*m-c*d)-o*(a*m-u*d)+v*(a*c-u*i),t[11]=-(r*(i*l-c*M)-o*(a*l-u*M)+f*(a*c-u*i)),t[12]=-(o*(M*b-h*d)-f*(i*b-s*d)+v*(i*h-s*M)),t[13]=r*(M*b-h*d)-f*(a*b-e*d)+v*(a*h-e*M),t[14]=-(r*(i*b-s*d)-o*(a*b-e*d)+v*(a*s-e*i)),t[15]=r*(i*h-s*M)-o*(a*h-e*M)+f*(a*s-e*i),t},n.determinant=function(t){var n=t[0],r=t[1],a=t[2],e=t[3],u=t[4],o=t[5],i=t[6],s=t[7],c=t[8],f=t[9],M=t[10],h=t[11],l=t[12],v=t[13],d=t[14],b=t[15];return(n*o-r*u)*(M*b-h*d)-(n*i-a*u)*(f*b-h*v)+(n*s-e*u)*(f*d-M*v)+(r*i-a*o)*(c*b-h*l)-(r*s-e*o)*(c*d-M*l)+(a*s-e*i)*(c*v-f*l)},n.multiply=u,n.translate=function(t,n,r){var a=r[0],e=r[1],u=r[2],o=void 0,i=void 0,s=void 0,c=void 0,f=void 0,M=void 0,h=void 0,l=void 0,v=void 0,d=void 0,b=void 0,m=void 0;n===t?(t[12]=n[0]*a+n[4]*e+n[8]*u+n[12],t[13]=n[1]*a+n[5]*e+n[9]*u+n[13],t[14]=n[2]*a+n[6]*e+n[10]*u+n[14],t[15]=n[3]*a+n[7]*e+n[11]*u+n[15]):(o=n[0],i=n[1],s=n[2],c=n[3],f=n[4],M=n[5],h=n[6],l=n[7],v=n[8],d=n[9],b=n[10],m=n[11],t[0]=o,t[1]=i,t[2]=s,t[3]=c,t[4]=f,t[5]=M,t[6]=h,t[7]=l,t[8]=v,t[9]=d,t[10]=b,t[11]=m,t[12]=o*a+f*e+v*u+n[12],t[13]=i*a+M*e+d*u+n[13],t[14]=s*a+h*e+b*u+n[14],t[15]=c*a+l*e+m*u+n[15]);return t},n.scale=function(t,n,r){var a=r[0],e=r[1],u=r[2];return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*e,t[5]=n[5]*e,t[6]=n[6]*e,t[7]=n[7]*e,t[8]=n[8]*u,t[9]=n[9]*u,t[10]=n[10]*u,t[11]=n[11]*u,t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t},n.rotate=function(t,n,r,e){var u=e[0],o=e[1],i=e[2],s=Math.sqrt(u*u+o*o+i*i),c=void 0,f=void 0,M=void 0,h=void 0,l=void 0,v=void 0,d=void 0,b=void 0,m=void 0,p=void 0,P=void 0,A=void 0,E=void 0,O=void 0,R=void 0,y=void 0,q=void 0,x=void 0,_=void 0,Y=void 0,L=void 0,S=void 0,w=void 0,I=void 0;if(s<a.EPSILON)return null;u*=s=1/s,o*=s,i*=s,c=Math.sin(r),f=Math.cos(r),M=1-f,h=n[0],l=n[1],v=n[2],d=n[3],b=n[4],m=n[5],p=n[6],P=n[7],A=n[8],E=n[9],O=n[10],R=n[11],y=u*u*M+f,q=o*u*M+i*c,x=i*u*M-o*c,_=u*o*M-i*c,Y=o*o*M+f,L=i*o*M+u*c,S=u*i*M+o*c,w=o*i*M-u*c,I=i*i*M+f,t[0]=h*y+b*q+A*x,t[1]=l*y+m*q+E*x,t[2]=v*y+p*q+O*x,t[3]=d*y+P*q+R*x,t[4]=h*_+b*Y+A*L,t[5]=l*_+m*Y+E*L,t[6]=v*_+p*Y+O*L,t[7]=d*_+P*Y+R*L,t[8]=h*S+b*w+A*I,t[9]=l*S+m*w+E*I,t[10]=v*S+p*w+O*I,t[11]=d*S+P*w+R*I,n!==t&&(t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]);return t},n.rotateX=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[4],o=n[5],i=n[6],s=n[7],c=n[8],f=n[9],M=n[10],h=n[11];n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]);return t[4]=u*e+c*a,t[5]=o*e+f*a,t[6]=i*e+M*a,t[7]=s*e+h*a,t[8]=c*e-u*a,t[9]=f*e-o*a,t[10]=M*e-i*a,t[11]=h*e-s*a,t},n.rotateY=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[0],o=n[1],i=n[2],s=n[3],c=n[8],f=n[9],M=n[10],h=n[11];n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]);return t[0]=u*e-c*a,t[1]=o*e-f*a,t[2]=i*e-M*a,t[3]=s*e-h*a,t[8]=u*a+c*e,t[9]=o*a+f*e,t[10]=i*a+M*e,t[11]=s*a+h*e,t},n.rotateZ=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[0],o=n[1],i=n[2],s=n[3],c=n[4],f=n[5],M=n[6],h=n[7];n!==t&&(t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]);return t[0]=u*e+c*a,t[1]=o*e+f*a,t[2]=i*e+M*a,t[3]=s*e+h*a,t[4]=c*e-u*a,t[5]=f*e-o*a,t[6]=M*e-i*a,t[7]=h*e-s*a,t},n.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t},n.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromRotation=function(t,n,r){var e=r[0],u=r[1],o=r[2],i=Math.sqrt(e*e+u*u+o*o),s=void 0,c=void 0,f=void 0;if(i<a.EPSILON)return null;return e*=i=1/i,u*=i,o*=i,s=Math.sin(n),c=Math.cos(n),f=1-c,t[0]=e*e*f+c,t[1]=u*e*f+o*s,t[2]=o*e*f-u*s,t[3]=0,t[4]=e*u*f-o*s,t[5]=u*u*f+c,t[6]=o*u*f+e*s,t[7]=0,t[8]=e*o*f+u*s,t[9]=u*o*f-e*s,t[10]=o*o*f+c,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromXRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=a,t[6]=r,t[7]=0,t[8]=0,t[9]=-r,t[10]=a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromYRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=0,t[2]=-r,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=r,t[9]=0,t[10]=a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromZRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=0,t[3]=0,t[4]=-r,t[5]=a,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromRotationTranslation=o,n.fromQuat2=function(t,n){var r=new a.ARRAY_TYPE(3),e=-n[0],u=-n[1],i=-n[2],s=n[3],c=n[4],f=n[5],M=n[6],h=n[7],l=e*e+u*u+i*i+s*s;l>0?(r[0]=2*(c*s+h*e+f*i-M*u)/l,r[1]=2*(f*s+h*u+M*e-c*i)/l,r[2]=2*(M*s+h*i+c*u-f*e)/l):(r[0]=2*(c*s+h*e+f*i-M*u),r[1]=2*(f*s+h*u+M*e-c*i),r[2]=2*(M*s+h*i+c*u-f*e));return o(t,n,r),t},n.getTranslation=function(t,n){return t[0]=n[12],t[1]=n[13],t[2]=n[14],t},n.getScaling=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[4],o=n[5],i=n[6],s=n[8],c=n[9],f=n[10];return t[0]=Math.sqrt(r*r+a*a+e*e),t[1]=Math.sqrt(u*u+o*o+i*i),t[2]=Math.sqrt(s*s+c*c+f*f),t},n.getRotation=function(t,n){var r=n[0]+n[5]+n[10],a=0;r>0?(a=2*Math.sqrt(r+1),t[3]=.25*a,t[0]=(n[6]-n[9])/a,t[1]=(n[8]-n[2])/a,t[2]=(n[1]-n[4])/a):n[0]>n[5]&&n[0]>n[10]?(a=2*Math.sqrt(1+n[0]-n[5]-n[10]),t[3]=(n[6]-n[9])/a,t[0]=.25*a,t[1]=(n[1]+n[4])/a,t[2]=(n[8]+n[2])/a):n[5]>n[10]?(a=2*Math.sqrt(1+n[5]-n[0]-n[10]),t[3]=(n[8]-n[2])/a,t[0]=(n[1]+n[4])/a,t[1]=.25*a,t[2]=(n[6]+n[9])/a):(a=2*Math.sqrt(1+n[10]-n[0]-n[5]),t[3]=(n[1]-n[4])/a,t[0]=(n[8]+n[2])/a,t[1]=(n[6]+n[9])/a,t[2]=.25*a);return t},n.fromRotationTranslationScale=function(t,n,r,a){var e=n[0],u=n[1],o=n[2],i=n[3],s=e+e,c=u+u,f=o+o,M=e*s,h=e*c,l=e*f,v=u*c,d=u*f,b=o*f,m=i*s,p=i*c,P=i*f,A=a[0],E=a[1],O=a[2];return t[0]=(1-(v+b))*A,t[1]=(h+P)*A,t[2]=(l-p)*A,t[3]=0,t[4]=(h-P)*E,t[5]=(1-(M+b))*E,t[6]=(d+m)*E,t[7]=0,t[8]=(l+p)*O,t[9]=(d-m)*O,t[10]=(1-(M+v))*O,t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t},n.fromRotationTranslationScaleOrigin=function(t,n,r,a,e){var u=n[0],o=n[1],i=n[2],s=n[3],c=u+u,f=o+o,M=i+i,h=u*c,l=u*f,v=u*M,d=o*f,b=o*M,m=i*M,p=s*c,P=s*f,A=s*M,E=a[0],O=a[1],R=a[2],y=e[0],q=e[1],x=e[2],_=(1-(d+m))*E,Y=(l+A)*E,L=(v-P)*E,S=(l-A)*O,w=(1-(h+m))*O,I=(b+p)*O,N=(v+P)*R,g=(b-p)*R,T=(1-(h+d))*R;return t[0]=_,t[1]=Y,t[2]=L,t[3]=0,t[4]=S,t[5]=w,t[6]=I,t[7]=0,t[8]=N,t[9]=g,t[10]=T,t[11]=0,t[12]=r[0]+y-(_*y+S*q+N*x),t[13]=r[1]+q-(Y*y+w*q+g*x),t[14]=r[2]+x-(L*y+I*q+T*x),t[15]=1,t},n.fromQuat=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r+r,i=a+a,s=e+e,c=r*o,f=a*o,M=a*i,h=e*o,l=e*i,v=e*s,d=u*o,b=u*i,m=u*s;return t[0]=1-M-v,t[1]=f+m,t[2]=h-b,t[3]=0,t[4]=f-m,t[5]=1-c-v,t[6]=l+d,t[7]=0,t[8]=h+b,t[9]=l-d,t[10]=1-c-M,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.frustum=function(t,n,r,a,e,u,o){var i=1/(r-n),s=1/(e-a),c=1/(u-o);return t[0]=2*u*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*u*s,t[6]=0,t[7]=0,t[8]=(r+n)*i,t[9]=(e+a)*s,t[10]=(o+u)*c,t[11]=-1,t[12]=0,t[13]=0,t[14]=o*u*2*c,t[15]=0,t},n.perspective=function(t,n,r,a,e){var u=1/Math.tan(n/2),o=void 0;t[0]=u/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=u,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=e&&e!==1/0?(o=1/(a-e),t[10]=(e+a)*o,t[14]=2*e*a*o):(t[10]=-1,t[14]=-2*a);return t},n.perspectiveFromFieldOfView=function(t,n,r,a){var e=Math.tan(n.upDegrees*Math.PI/180),u=Math.tan(n.downDegrees*Math.PI/180),o=Math.tan(n.leftDegrees*Math.PI/180),i=Math.tan(n.rightDegrees*Math.PI/180),s=2/(o+i),c=2/(e+u);return t[0]=s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=c,t[6]=0,t[7]=0,t[8]=-(o-i)*s*.5,t[9]=(e-u)*c*.5,t[10]=a/(r-a),t[11]=-1,t[12]=0,t[13]=0,t[14]=a*r/(r-a),t[15]=0,t},n.ortho=function(t,n,r,a,e,u,o){var i=1/(n-r),s=1/(a-e),c=1/(u-o);return t[0]=-2*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*s,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*c,t[11]=0,t[12]=(n+r)*i,t[13]=(e+a)*s,t[14]=(o+u)*c,t[15]=1,t},n.lookAt=function(t,n,r,u){var o=void 0,i=void 0,s=void 0,c=void 0,f=void 0,M=void 0,h=void 0,l=void 0,v=void 0,d=void 0,b=n[0],m=n[1],p=n[2],P=u[0],A=u[1],E=u[2],O=r[0],R=r[1],y=r[2];if(Math.abs(b-O)<a.EPSILON&&Math.abs(m-R)<a.EPSILON&&Math.abs(p-y)<a.EPSILON)return e(t);h=b-O,l=m-R,v=p-y,d=1/Math.sqrt(h*h+l*l+v*v),o=A*(v*=d)-E*(l*=d),i=E*(h*=d)-P*v,s=P*l-A*h,(d=Math.sqrt(o*o+i*i+s*s))?(o*=d=1/d,i*=d,s*=d):(o=0,i=0,s=0);c=l*s-v*i,f=v*o-h*s,M=h*i-l*o,(d=Math.sqrt(c*c+f*f+M*M))?(c*=d=1/d,f*=d,M*=d):(c=0,f=0,M=0);return t[0]=o,t[1]=c,t[2]=h,t[3]=0,t[4]=i,t[5]=f,t[6]=l,t[7]=0,t[8]=s,t[9]=M,t[10]=v,t[11]=0,t[12]=-(o*b+i*m+s*p),t[13]=-(c*b+f*m+M*p),t[14]=-(h*b+l*m+v*p),t[15]=1,t},n.targetTo=function(t,n,r,a){var e=n[0],u=n[1],o=n[2],i=a[0],s=a[1],c=a[2],f=e-r[0],M=u-r[1],h=o-r[2],l=f*f+M*M+h*h;l>0&&(l=1/Math.sqrt(l),f*=l,M*=l,h*=l);var v=s*h-c*M,d=c*f-i*h,b=i*M-s*f;(l=v*v+d*d+b*b)>0&&(l=1/Math.sqrt(l),v*=l,d*=l,b*=l);return t[0]=v,t[1]=d,t[2]=b,t[3]=0,t[4]=M*b-h*d,t[5]=h*v-f*b,t[6]=f*d-M*v,t[7]=0,t[8]=f,t[9]=M,t[10]=h,t[11]=0,t[12]=e,t[13]=u,t[14]=o,t[15]=1,t},n.str=function(t){return"mat4("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+", "+t[9]+", "+t[10]+", "+t[11]+", "+t[12]+", "+t[13]+", "+t[14]+", "+t[15]+")"},n.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2)+Math.pow(t[9],2)+Math.pow(t[10],2)+Math.pow(t[11],2)+Math.pow(t[12],2)+Math.pow(t[13],2)+Math.pow(t[14],2)+Math.pow(t[15],2))},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t[4]=n[4]+r[4],t[5]=n[5]+r[5],t[6]=n[6]+r[6],t[7]=n[7]+r[7],t[8]=n[8]+r[8],t[9]=n[9]+r[9],t[10]=n[10]+r[10],t[11]=n[11]+r[11],t[12]=n[12]+r[12],t[13]=n[13]+r[13],t[14]=n[14]+r[14],t[15]=n[15]+r[15],t},n.subtract=i,n.multiplyScalar=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=n[7]*r,t[8]=n[8]*r,t[9]=n[9]*r,t[10]=n[10]*r,t[11]=n[11]*r,t[12]=n[12]*r,t[13]=n[13]*r,t[14]=n[14]*r,t[15]=n[15]*r,t},n.multiplyScalarAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t[4]=n[4]+r[4]*a,t[5]=n[5]+r[5]*a,t[6]=n[6]+r[6]*a,t[7]=n[7]+r[7]*a,t[8]=n[8]+r[8]*a,t[9]=n[9]+r[9]*a,t[10]=n[10]+r[10]*a,t[11]=n[11]+r[11]*a,t[12]=n[12]+r[12]*a,t[13]=n[13]+r[13]*a,t[14]=n[14]+r[14]*a,t[15]=n[15]+r[15]*a,t},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]&&t[9]===n[9]&&t[10]===n[10]&&t[11]===n[11]&&t[12]===n[12]&&t[13]===n[13]&&t[14]===n[14]&&t[15]===n[15]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=t[4],s=t[5],c=t[6],f=t[7],M=t[8],h=t[9],l=t[10],v=t[11],d=t[12],b=t[13],m=t[14],p=t[15],P=n[0],A=n[1],E=n[2],O=n[3],R=n[4],y=n[5],q=n[6],x=n[7],_=n[8],Y=n[9],L=n[10],S=n[11],w=n[12],I=n[13],N=n[14],g=n[15];return Math.abs(r-P)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(P))&&Math.abs(e-A)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(A))&&Math.abs(u-E)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(E))&&Math.abs(o-O)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(O))&&Math.abs(i-R)<=a.EPSILON*Math.max(1,Math.abs(i),Math.abs(R))&&Math.abs(s-y)<=a.EPSILON*Math.max(1,Math.abs(s),Math.abs(y))&&Math.abs(c-q)<=a.EPSILON*Math.max(1,Math.abs(c),Math.abs(q))&&Math.abs(f-x)<=a.EPSILON*Math.max(1,Math.abs(f),Math.abs(x))&&Math.abs(M-_)<=a.EPSILON*Math.max(1,Math.abs(M),Math.abs(_))&&Math.abs(h-Y)<=a.EPSILON*Math.max(1,Math.abs(h),Math.abs(Y))&&Math.abs(l-L)<=a.EPSILON*Math.max(1,Math.abs(l),Math.abs(L))&&Math.abs(v-S)<=a.EPSILON*Math.max(1,Math.abs(v),Math.abs(S))&&Math.abs(d-w)<=a.EPSILON*Math.max(1,Math.abs(d),Math.abs(w))&&Math.abs(b-I)<=a.EPSILON*Math.max(1,Math.abs(b),Math.abs(I))&&Math.abs(m-N)<=a.EPSILON*Math.max(1,Math.abs(m),Math.abs(N))&&Math.abs(p-g)<=a.EPSILON*Math.max(1,Math.abs(p),Math.abs(g))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function u(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=n[6],f=n[7],M=n[8],h=n[9],l=n[10],v=n[11],d=n[12],b=n[13],m=n[14],p=n[15],P=r[0],A=r[1],E=r[2],O=r[3];return t[0]=P*a+A*i+E*M+O*d,t[1]=P*e+A*s+E*h+O*b,t[2]=P*u+A*c+E*l+O*m,t[3]=P*o+A*f+E*v+O*p,P=r[4],A=r[5],E=r[6],O=r[7],t[4]=P*a+A*i+E*M+O*d,t[5]=P*e+A*s+E*h+O*b,t[6]=P*u+A*c+E*l+O*m,t[7]=P*o+A*f+E*v+O*p,P=r[8],A=r[9],E=r[10],O=r[11],t[8]=P*a+A*i+E*M+O*d,t[9]=P*e+A*s+E*h+O*b,t[10]=P*u+A*c+E*l+O*m,t[11]=P*o+A*f+E*v+O*p,P=r[12],A=r[13],E=r[14],O=r[15],t[12]=P*a+A*i+E*M+O*d,t[13]=P*e+A*s+E*h+O*b,t[14]=P*u+A*c+E*l+O*m,t[15]=P*o+A*f+E*v+O*p,t}function o(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=a+a,s=e+e,c=u+u,f=a*i,M=a*s,h=a*c,l=e*s,v=e*c,d=u*c,b=o*i,m=o*s,p=o*c;return t[0]=1-(l+d),t[1]=M+p,t[2]=h-m,t[3]=0,t[4]=M-p,t[5]=1-(f+d),t[6]=v+b,t[7]=0,t[8]=h+m,t[9]=v-b,t[10]=1-(f+l),t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t}function i(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t[4]=n[4]-r[4],t[5]=n[5]-r[5],t[6]=n[6]-r[6],t[7]=n[7]-r[7],t[8]=n[8]-r[8],t[9]=n[9]-r[9],t[10]=n[10]-r[10],t[11]=n[11]-r[11],t[12]=n[12]-r[12],t[13]=n[13]-r[13],t[14]=n[14]-r[14],t[15]=n[15]-r[15],t}n.mul=u,n.sub=i},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=function(){var t=new a.ARRAY_TYPE(9);a.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0);return t[0]=1,t[4]=1,t[8]=1,t},n.fromMat4=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[4],t[4]=n[5],t[5]=n[6],t[6]=n[8],t[7]=n[9],t[8]=n[10],t},n.clone=function(t){var n=new a.ARRAY_TYPE(9);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},n.fromValues=function(t,n,r,e,u,o,i,s,c){var f=new a.ARRAY_TYPE(9);return f[0]=t,f[1]=n,f[2]=r,f[3]=e,f[4]=u,f[5]=o,f[6]=i,f[7]=s,f[8]=c,f},n.set=function(t,n,r,a,e,u,o,i,s,c){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t[4]=u,t[5]=o,t[6]=i,t[7]=s,t[8]=c,t},n.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},n.transpose=function(t,n){if(t===n){var r=n[1],a=n[2],e=n[5];t[1]=n[3],t[2]=n[6],t[3]=r,t[5]=n[7],t[6]=a,t[7]=e}else t[0]=n[0],t[1]=n[3],t[2]=n[6],t[3]=n[1],t[4]=n[4],t[5]=n[7],t[6]=n[2],t[7]=n[5],t[8]=n[8];return t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8],M=f*o-i*c,h=-f*u+i*s,l=c*u-o*s,v=r*M+a*h+e*l;if(!v)return null;return v=1/v,t[0]=M*v,t[1]=(-f*a+e*c)*v,t[2]=(i*a-e*o)*v,t[3]=h*v,t[4]=(f*r-e*s)*v,t[5]=(-i*r+e*u)*v,t[6]=l*v,t[7]=(-c*r+a*s)*v,t[8]=(o*r-a*u)*v,t},n.adjoint=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8];return t[0]=o*f-i*c,t[1]=e*c-a*f,t[2]=a*i-e*o,t[3]=i*s-u*f,t[4]=r*f-e*s,t[5]=e*u-r*i,t[6]=u*c-o*s,t[7]=a*s-r*c,t[8]=r*o-a*u,t},n.determinant=function(t){var n=t[0],r=t[1],a=t[2],e=t[3],u=t[4],o=t[5],i=t[6],s=t[7],c=t[8];return n*(c*u-o*s)+r*(-c*e+o*i)+a*(s*e-u*i)},n.multiply=e,n.translate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=n[6],f=n[7],M=n[8],h=r[0],l=r[1];return t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=i,t[5]=s,t[6]=h*a+l*o+c,t[7]=h*e+l*i+f,t[8]=h*u+l*s+M,t},n.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=n[6],f=n[7],M=n[8],h=Math.sin(r),l=Math.cos(r);return t[0]=l*a+h*o,t[1]=l*e+h*i,t[2]=l*u+h*s,t[3]=l*o-h*a,t[4]=l*i-h*e,t[5]=l*s-h*u,t[6]=c,t[7]=f,t[8]=M,t},n.scale=function(t,n,r){var a=r[0],e=r[1];return t[0]=a*n[0],t[1]=a*n[1],t[2]=a*n[2],t[3]=e*n[3],t[4]=e*n[4],t[5]=e*n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},n.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=n[0],t[7]=n[1],t[8]=1,t},n.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=0,t[3]=-r,t[4]=a,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},n.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=n[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},n.fromMat2d=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=0,t[3]=n[2],t[4]=n[3],t[5]=0,t[6]=n[4],t[7]=n[5],t[8]=1,t},n.fromQuat=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r+r,i=a+a,s=e+e,c=r*o,f=a*o,M=a*i,h=e*o,l=e*i,v=e*s,d=u*o,b=u*i,m=u*s;return t[0]=1-M-v,t[3]=f-m,t[6]=h+b,t[1]=f+m,t[4]=1-c-v,t[7]=l-d,t[2]=h-b,t[5]=l+d,t[8]=1-c-M,t},n.normalFromMat4=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8],M=n[9],h=n[10],l=n[11],v=n[12],d=n[13],b=n[14],m=n[15],p=r*i-a*o,P=r*s-e*o,A=r*c-u*o,E=a*s-e*i,O=a*c-u*i,R=e*c-u*s,y=f*d-M*v,q=f*b-h*v,x=f*m-l*v,_=M*b-h*d,Y=M*m-l*d,L=h*m-l*b,S=p*L-P*Y+A*_+E*x-O*q+R*y;if(!S)return null;return S=1/S,t[0]=(i*L-s*Y+c*_)*S,t[1]=(s*x-o*L-c*q)*S,t[2]=(o*Y-i*x+c*y)*S,t[3]=(e*Y-a*L-u*_)*S,t[4]=(r*L-e*x+u*q)*S,t[5]=(a*x-r*Y-u*y)*S,t[6]=(d*R-b*O+m*E)*S,t[7]=(b*A-v*R-m*P)*S,t[8]=(v*O-d*A+m*p)*S,t},n.projection=function(t,n,r){return t[0]=2/n,t[1]=0,t[2]=0,t[3]=0,t[4]=-2/r,t[5]=0,t[6]=-1,t[7]=1,t[8]=1,t},n.str=function(t){return"mat3("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+", "+t[8]+")"},n.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2))},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t[4]=n[4]+r[4],t[5]=n[5]+r[5],t[6]=n[6]+r[6],t[7]=n[7]+r[7],t[8]=n[8]+r[8],t},n.subtract=u,n.multiplyScalar=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=n[7]*r,t[8]=n[8]*r,t},n.multiplyScalarAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t[4]=n[4]+r[4]*a,t[5]=n[5]+r[5]*a,t[6]=n[6]+r[6]*a,t[7]=n[7]+r[7]*a,t[8]=n[8]+r[8]*a,t},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=t[4],s=t[5],c=t[6],f=t[7],M=t[8],h=n[0],l=n[1],v=n[2],d=n[3],b=n[4],m=n[5],p=n[6],P=n[7],A=n[8];return Math.abs(r-h)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(h))&&Math.abs(e-l)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(l))&&Math.abs(u-v)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(v))&&Math.abs(o-d)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(d))&&Math.abs(i-b)<=a.EPSILON*Math.max(1,Math.abs(i),Math.abs(b))&&Math.abs(s-m)<=a.EPSILON*Math.max(1,Math.abs(s),Math.abs(m))&&Math.abs(c-p)<=a.EPSILON*Math.max(1,Math.abs(c),Math.abs(p))&&Math.abs(f-P)<=a.EPSILON*Math.max(1,Math.abs(f),Math.abs(P))&&Math.abs(M-A)<=a.EPSILON*Math.max(1,Math.abs(M),Math.abs(A))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=n[6],f=n[7],M=n[8],h=r[0],l=r[1],v=r[2],d=r[3],b=r[4],m=r[5],p=r[6],P=r[7],A=r[8];return t[0]=h*a+l*o+v*c,t[1]=h*e+l*i+v*f,t[2]=h*u+l*s+v*M,t[3]=d*a+b*o+m*c,t[4]=d*e+b*i+m*f,t[5]=d*u+b*s+m*M,t[6]=p*a+P*o+A*c,t[7]=p*e+P*i+A*f,t[8]=p*u+P*s+A*M,t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t[4]=n[4]-r[4],t[5]=n[5]-r[5],t[6]=n[6]-r[6],t[7]=n[7]-r[7],t[8]=n[8]-r[8],t}n.mul=e,n.sub=u},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.forEach=n.sqrLen=n.sqrDist=n.dist=n.div=n.mul=n.sub=n.len=void 0,n.create=e,n.clone=function(t){var n=new a.ARRAY_TYPE(2);return n[0]=t[0],n[1]=t[1],n},n.fromValues=function(t,n){var r=new a.ARRAY_TYPE(2);return r[0]=t,r[1]=n,r},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t},n.set=function(t,n,r){return t[0]=n,t[1]=r,t},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t},n.subtract=u,n.multiply=o,n.divide=i,n.ceil=function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t},n.floor=function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t},n.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t},n.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t},n.round=function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t},n.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t},n.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t},n.distance=s,n.squaredDistance=c,n.length=f,n.squaredLength=M,n.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t},n.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t},n.normalize=function(t,n){var r=n[0],a=n[1],e=r*r+a*a;e>0&&(e=1/Math.sqrt(e),t[0]=n[0]*e,t[1]=n[1]*e);return t},n.dot=function(t,n){return t[0]*n[0]+t[1]*n[1]},n.cross=function(t,n,r){var a=n[0]*r[1]-n[1]*r[0];return t[0]=t[1]=0,t[2]=a,t},n.lerp=function(t,n,r,a){var e=n[0],u=n[1];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t},n.random=function(t,n){n=n||1;var r=2*a.RANDOM()*Math.PI;return t[0]=Math.cos(r)*n,t[1]=Math.sin(r)*n,t},n.transformMat2=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[2]*e,t[1]=r[1]*a+r[3]*e,t},n.transformMat2d=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[2]*e+r[4],t[1]=r[1]*a+r[3]*e+r[5],t},n.transformMat3=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[3]*e+r[6],t[1]=r[1]*a+r[4]*e+r[7],t},n.transformMat4=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[4]*e+r[12],t[1]=r[1]*a+r[5]*e+r[13],t},n.rotate=function(t,n,r,a){var e=n[0]-r[0],u=n[1]-r[1],o=Math.sin(a),i=Math.cos(a);return t[0]=e*i-u*o+r[0],t[1]=e*o+u*i+r[1],t},n.angle=function(t,n){var r=t[0],a=t[1],e=n[0],u=n[1],o=r*r+a*a;o>0&&(o=1/Math.sqrt(o));var i=e*e+u*u;i>0&&(i=1/Math.sqrt(i));var s=(r*e+a*u)*o*i;return s>1?0:s<-1?Math.PI:Math.acos(s)},n.str=function(t){return"vec2("+t[0]+", "+t[1]+")"},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]},n.equals=function(t,n){var r=t[0],e=t[1],u=n[0],o=n[1];return Math.abs(r-u)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(u))&&Math.abs(e-o)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(o))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(){var t=new a.ARRAY_TYPE(2);return a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0),t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t}function o(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t}function i(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t}function s(t,n){var r=n[0]-t[0],a=n[1]-t[1];return Math.sqrt(r*r+a*a)}function c(t,n){var r=n[0]-t[0],a=n[1]-t[1];return r*r+a*a}function f(t){var n=t[0],r=t[1];return Math.sqrt(n*n+r*r)}function M(t){var n=t[0],r=t[1];return n*n+r*r}n.len=f,n.sub=u,n.mul=o,n.div=i,n.dist=s,n.sqrDist=c,n.sqrLen=M,n.forEach=function(){var t=e();return function(n,r,a,e,u,o){var i=void 0,s=void 0;for(r||(r=2),a||(a=0),s=e?Math.min(e*r+a,n.length):n.length,i=a;i<s;i+=r)t[0]=n[i],t[1]=n[i+1],u(t,t,o),n[i]=t[0],n[i+1]=t[1];return n}}()},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sqrLen=n.squaredLength=n.len=n.length=n.dot=n.mul=n.setReal=n.getReal=void 0,n.create=function(){var t=new a.ARRAY_TYPE(8);a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0);return t[3]=1,t},n.clone=function(t){var n=new a.ARRAY_TYPE(8);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n},n.fromValues=function(t,n,r,e,u,o,i,s){var c=new a.ARRAY_TYPE(8);return c[0]=t,c[1]=n,c[2]=r,c[3]=e,c[4]=u,c[5]=o,c[6]=i,c[7]=s,c},n.fromRotationTranslationValues=function(t,n,r,e,u,o,i){var s=new a.ARRAY_TYPE(8);s[0]=t,s[1]=n,s[2]=r,s[3]=e;var c=.5*u,f=.5*o,M=.5*i;return s[4]=c*e+f*r-M*n,s[5]=f*e+M*t-c*r,s[6]=M*e+c*n-f*t,s[7]=-c*t-f*n-M*r,s},n.fromRotationTranslation=i,n.fromTranslation=function(t,n){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t[4]=.5*n[0],t[5]=.5*n[1],t[6]=.5*n[2],t[7]=0,t},n.fromRotation=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=0,t[5]=0,t[6]=0,t[7]=0,t},n.fromMat4=function(t,n){var r=e.create();u.getRotation(r,n);var o=new a.ARRAY_TYPE(3);return u.getTranslation(o,n),i(t,r,o),t},n.copy=s,n.identity=function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t},n.set=function(t,n,r,a,e,u,o,i,s){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t[4]=u,t[5]=o,t[6]=i,t[7]=s,t},n.getDual=function(t,n){return t[0]=n[4],t[1]=n[5],t[2]=n[6],t[3]=n[7],t},n.setDual=function(t,n){return t[4]=n[0],t[5]=n[1],t[6]=n[2],t[7]=n[3],t},n.getTranslation=function(t,n){var r=n[4],a=n[5],e=n[6],u=n[7],o=-n[0],i=-n[1],s=-n[2],c=n[3];return t[0]=2*(r*c+u*o+a*s-e*i),t[1]=2*(a*c+u*i+e*o-r*s),t[2]=2*(e*c+u*s+r*i-a*o),t},n.translate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=.5*r[0],s=.5*r[1],c=.5*r[2],f=n[4],M=n[5],h=n[6],l=n[7];return t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=o*i+e*c-u*s+f,t[5]=o*s+u*i-a*c+M,t[6]=o*c+a*s-e*i+h,t[7]=-a*i-e*s-u*c+l,t},n.rotateX=function(t,n,r){var a=-n[0],u=-n[1],o=-n[2],i=n[3],s=n[4],c=n[5],f=n[6],M=n[7],h=s*i+M*a+c*o-f*u,l=c*i+M*u+f*a-s*o,v=f*i+M*o+s*u-c*a,d=M*i-s*a-c*u-f*o;return e.rotateX(t,n,r),a=t[0],u=t[1],o=t[2],i=t[3],t[4]=h*i+d*a+l*o-v*u,t[5]=l*i+d*u+v*a-h*o,t[6]=v*i+d*o+h*u-l*a,t[7]=d*i-h*a-l*u-v*o,t},n.rotateY=function(t,n,r){var a=-n[0],u=-n[1],o=-n[2],i=n[3],s=n[4],c=n[5],f=n[6],M=n[7],h=s*i+M*a+c*o-f*u,l=c*i+M*u+f*a-s*o,v=f*i+M*o+s*u-c*a,d=M*i-s*a-c*u-f*o;return e.rotateY(t,n,r),a=t[0],u=t[1],o=t[2],i=t[3],t[4]=h*i+d*a+l*o-v*u,t[5]=l*i+d*u+v*a-h*o,t[6]=v*i+d*o+h*u-l*a,t[7]=d*i-h*a-l*u-v*o,t},n.rotateZ=function(t,n,r){var a=-n[0],u=-n[1],o=-n[2],i=n[3],s=n[4],c=n[5],f=n[6],M=n[7],h=s*i+M*a+c*o-f*u,l=c*i+M*u+f*a-s*o,v=f*i+M*o+s*u-c*a,d=M*i-s*a-c*u-f*o;return e.rotateZ(t,n,r),a=t[0],u=t[1],o=t[2],i=t[3],t[4]=h*i+d*a+l*o-v*u,t[5]=l*i+d*u+v*a-h*o,t[6]=v*i+d*o+h*u-l*a,t[7]=d*i-h*a-l*u-v*o,t},n.rotateByQuatAppend=function(t,n,r){var a=r[0],e=r[1],u=r[2],o=r[3],i=n[0],s=n[1],c=n[2],f=n[3];return t[0]=i*o+f*a+s*u-c*e,t[1]=s*o+f*e+c*a-i*u,t[2]=c*o+f*u+i*e-s*a,t[3]=f*o-i*a-s*e-c*u,i=n[4],s=n[5],c=n[6],f=n[7],t[4]=i*o+f*a+s*u-c*e,t[5]=s*o+f*e+c*a-i*u,t[6]=c*o+f*u+i*e-s*a,t[7]=f*o-i*a-s*e-c*u,t},n.rotateByQuatPrepend=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],s=r[1],c=r[2],f=r[3];return t[0]=a*f+o*i+e*c-u*s,t[1]=e*f+o*s+u*i-a*c,t[2]=u*f+o*c+a*s-e*i,t[3]=o*f-a*i-e*s-u*c,i=r[4],s=r[5],c=r[6],f=r[7],t[4]=a*f+o*i+e*c-u*s,t[5]=e*f+o*s+u*i-a*c,t[6]=u*f+o*c+a*s-e*i,t[7]=o*f-a*i-e*s-u*c,t},n.rotateAroundAxis=function(t,n,r,e){if(Math.abs(e)<a.EPSILON)return s(t,n);var u=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);e*=.5;var o=Math.sin(e),i=o*r[0]/u,c=o*r[1]/u,f=o*r[2]/u,M=Math.cos(e),h=n[0],l=n[1],v=n[2],d=n[3];t[0]=h*M+d*i+l*f-v*c,t[1]=l*M+d*c+v*i-h*f,t[2]=v*M+d*f+h*c-l*i,t[3]=d*M-h*i-l*c-v*f;var b=n[4],m=n[5],p=n[6],P=n[7];return t[4]=b*M+P*i+m*f-p*c,t[5]=m*M+P*c+p*i-b*f,t[6]=p*M+P*f+b*c-m*i,t[7]=P*M-b*i-m*c-p*f,t},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t[4]=n[4]+r[4],t[5]=n[5]+r[5],t[6]=n[6]+r[6],t[7]=n[7]+r[7],t},n.multiply=c,n.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=n[7]*r,t},n.lerp=function(t,n,r,a){var e=1-a;f(n,r)<0&&(a=-a);return t[0]=n[0]*e+r[0]*a,t[1]=n[1]*e+r[1]*a,t[2]=n[2]*e+r[2]*a,t[3]=n[3]*e+r[3]*a,t[4]=n[4]*e+r[4]*a,t[5]=n[5]*e+r[5]*a,t[6]=n[6]*e+r[6]*a,t[7]=n[7]*e+r[7]*a,t},n.invert=function(t,n){var r=h(n);return t[0]=-n[0]/r,t[1]=-n[1]/r,t[2]=-n[2]/r,t[3]=n[3]/r,t[4]=-n[4]/r,t[5]=-n[5]/r,t[6]=-n[6]/r,t[7]=n[7]/r,t},n.conjugate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t[4]=-n[4],t[5]=-n[5],t[6]=-n[6],t[7]=n[7],t},n.normalize=function(t,n){var r=h(n);if(r>0){r=Math.sqrt(r);var a=n[0]/r,e=n[1]/r,u=n[2]/r,o=n[3]/r,i=n[4],s=n[5],c=n[6],f=n[7],M=a*i+e*s+u*c+o*f;t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=(i-a*M)/r,t[5]=(s-e*M)/r,t[6]=(c-u*M)/r,t[7]=(f-o*M)/r}return t},n.str=function(t){return"quat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+", "+t[6]+", "+t[7]+")"},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=t[4],s=t[5],c=t[6],f=t[7],M=n[0],h=n[1],l=n[2],v=n[3],d=n[4],b=n[5],m=n[6],p=n[7];return Math.abs(r-M)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(M))&&Math.abs(e-h)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(h))&&Math.abs(u-l)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(l))&&Math.abs(o-v)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(v))&&Math.abs(i-d)<=a.EPSILON*Math.max(1,Math.abs(i),Math.abs(d))&&Math.abs(s-b)<=a.EPSILON*Math.max(1,Math.abs(s),Math.abs(b))&&Math.abs(c-m)<=a.EPSILON*Math.max(1,Math.abs(c),Math.abs(m))&&Math.abs(f-p)<=a.EPSILON*Math.max(1,Math.abs(f),Math.abs(p))};var a=o(r(0)),e=o(r(3)),u=o(r(4));function o(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}function i(t,n,r){var a=.5*r[0],e=.5*r[1],u=.5*r[2],o=n[0],i=n[1],s=n[2],c=n[3];return t[0]=o,t[1]=i,t[2]=s,t[3]=c,t[4]=a*c+e*s-u*i,t[5]=e*c+u*o-a*s,t[6]=u*c+a*i-e*o,t[7]=-a*o-e*i-u*s,t}function s(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t}n.getReal=e.copy;n.setReal=e.copy;function c(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[4],s=r[5],c=r[6],f=r[7],M=n[4],h=n[5],l=n[6],v=n[7],d=r[0],b=r[1],m=r[2],p=r[3];return t[0]=a*p+o*d+e*m-u*b,t[1]=e*p+o*b+u*d-a*m,t[2]=u*p+o*m+a*b-e*d,t[3]=o*p-a*d-e*b-u*m,t[4]=a*f+o*i+e*c-u*s+M*p+v*d+h*m-l*b,t[5]=e*f+o*s+u*i-a*c+h*p+v*b+l*d-M*m,t[6]=u*f+o*c+a*s-e*i+l*p+v*m+M*b-h*d,t[7]=o*f-a*i-e*s-u*c+v*p-M*d-h*b-l*m,t}n.mul=c;var f=n.dot=e.dot;var M=n.length=e.length,h=(n.len=M,n.squaredLength=e.squaredLength);n.sqrLen=h},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=function(){var t=new a.ARRAY_TYPE(6);a.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[4]=0,t[5]=0);return t[0]=1,t[3]=1,t},n.clone=function(t){var n=new a.ARRAY_TYPE(6);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t},n.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},n.fromValues=function(t,n,r,e,u,o){var i=new a.ARRAY_TYPE(6);return i[0]=t,i[1]=n,i[2]=r,i[3]=e,i[4]=u,i[5]=o,i},n.set=function(t,n,r,a,e,u,o){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t[4]=u,t[5]=o,t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=r*u-a*e;if(!s)return null;return s=1/s,t[0]=u*s,t[1]=-a*s,t[2]=-e*s,t[3]=r*s,t[4]=(e*i-u*o)*s,t[5]=(a*o-r*i)*s,t},n.determinant=function(t){return t[0]*t[3]-t[1]*t[2]},n.multiply=e,n.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=Math.sin(r),f=Math.cos(r);return t[0]=a*f+u*c,t[1]=e*f+o*c,t[2]=a*-c+u*f,t[3]=e*-c+o*f,t[4]=i,t[5]=s,t},n.scale=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=r[0],f=r[1];return t[0]=a*c,t[1]=e*c,t[2]=u*f,t[3]=o*f,t[4]=i,t[5]=s,t},n.translate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=r[0],f=r[1];return t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=a*c+u*f+i,t[5]=e*c+o*f+s,t},n.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=-r,t[3]=a,t[4]=0,t[5]=0,t},n.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t[4]=0,t[5]=0,t},n.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=n[0],t[5]=n[1],t},n.str=function(t){return"mat2d("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+", "+t[4]+", "+t[5]+")"},n.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+1)},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t[4]=n[4]+r[4],t[5]=n[5]+r[5],t},n.subtract=u,n.multiplyScalar=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*r,t[5]=n[5]*r,t},n.multiplyScalarAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t[4]=n[4]+r[4]*a,t[5]=n[5]+r[5]*a,t},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=t[4],s=t[5],c=n[0],f=n[1],M=n[2],h=n[3],l=n[4],v=n[5];return Math.abs(r-c)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(e-f)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(f))&&Math.abs(u-M)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(M))&&Math.abs(o-h)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(h))&&Math.abs(i-l)<=a.EPSILON*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(s-v)<=a.EPSILON*Math.max(1,Math.abs(s),Math.abs(v))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=r[0],f=r[1],M=r[2],h=r[3],l=r[4],v=r[5];return t[0]=a*c+u*f,t[1]=e*c+o*f,t[2]=a*M+u*h,t[3]=e*M+o*h,t[4]=a*l+u*v+i,t[5]=e*l+o*v+s,t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t[4]=n[4]-r[4],t[5]=n[5]-r[5],t}n.mul=e,n.sub=u},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.sub=n.mul=void 0,n.create=function(){var t=new a.ARRAY_TYPE(4);a.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0);return t[0]=1,t[3]=1,t},n.clone=function(t){var n=new a.ARRAY_TYPE(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t},n.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},n.fromValues=function(t,n,r,e){var u=new a.ARRAY_TYPE(4);return u[0]=t,u[1]=n,u[2]=r,u[3]=e,u},n.set=function(t,n,r,a,e){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t},n.transpose=function(t,n){if(t===n){var r=n[1];t[1]=n[2],t[2]=r}else t[0]=n[0],t[1]=n[2],t[2]=n[1],t[3]=n[3];return t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*u-e*a;if(!o)return null;return o=1/o,t[0]=u*o,t[1]=-a*o,t[2]=-e*o,t[3]=r*o,t},n.adjoint=function(t,n){var r=n[0];return t[0]=n[3],t[1]=-n[1],t[2]=-n[2],t[3]=r,t},n.determinant=function(t){return t[0]*t[3]-t[2]*t[1]},n.multiply=e,n.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),s=Math.cos(r);return t[0]=a*s+u*i,t[1]=e*s+o*i,t[2]=a*-i+u*s,t[3]=e*-i+o*s,t},n.scale=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],s=r[1];return t[0]=a*i,t[1]=e*i,t[2]=u*s,t[3]=o*s,t},n.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=-r,t[3]=a,t},n.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t},n.str=function(t){return"mat2("+t[0]+", "+t[1]+", "+t[2]+", "+t[3]+")"},n.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2))},n.LDU=function(t,n,r,a){return t[2]=a[2]/a[0],r[0]=a[0],r[1]=a[1],r[3]=a[3]-t[2]*r[1],[t,n,r]},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t},n.subtract=u,n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=n[0],s=n[1],c=n[2],f=n[3];return Math.abs(r-i)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(e-s)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(s))&&Math.abs(u-c)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(c))&&Math.abs(o-f)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(f))},n.multiplyScalar=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t},n.multiplyScalarAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],s=r[1],c=r[2],f=r[3];return t[0]=a*i+u*s,t[1]=e*i+o*s,t[2]=a*c+u*f,t[3]=e*c+o*f,t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t}n.mul=e,n.sub=u},function(t,n,r){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.vec4=n.vec3=n.vec2=n.quat2=n.quat=n.mat4=n.mat3=n.mat2d=n.mat2=n.glMatrix=void 0;var a=l(r(0)),e=l(r(9)),u=l(r(8)),o=l(r(5)),i=l(r(4)),s=l(r(3)),c=l(r(7)),f=l(r(6)),M=l(r(2)),h=l(r(1));function l(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}n.glMatrix=a,n.mat2=e,n.mat2d=u,n.mat3=o,n.mat4=i,n.quat=s,n.quat2=c,n.vec2=f,n.vec3=M,n.vec4=h}])});
/*
 jquery-qrcode v0.14.0 - https://larsjung.de/jquery-qrcode/ */
'use strict';let G=null;class H{}H.render=function(w,B){G(w,B)};self.QrCreator=H;
(function(w){function B(t,c,a,e){var b={},h=w(a,c);h.u(t);h.J();e=e||0;var r=h.h(),d=h.h()+2*e;b.text=t;b.level=c;b.version=a;b.O=d;b.a=function(b,a){b-=e;a-=e;return 0>b||b>=r||0>a||a>=r?!1:h.a(b,a)};return b}function C(t,c,a,e,b,h,r,d,g,x){function u(b,a,f,c,d,r,g){b?(t.lineTo(a+r,f+g),t.arcTo(a,f,c,d,h)):t.lineTo(a,f)}r?t.moveTo(c+h,a):t.moveTo(c,a);u(d,e,a,e,b,-h,0);u(g,e,b,c,b,0,-h);u(x,c,b,c,a,h,0);u(r,c,a,e,a,0,h)}function z(t,c,a,e,b,h,r,d,g,x){function u(b,a,c,d){t.moveTo(b+c,a);t.lineTo(b,
a);t.lineTo(b,a+d);t.arcTo(b,a,b+c,a,h)}r&&u(c,a,h,h);d&&u(e,a,-h,h);g&&u(e,b,-h,-h);x&&u(c,b,h,-h)}function A(t,c){var a=c.fill;if("string"===typeof a)t.fillStyle=a;else{var e=a.type,b=a.colorStops;a=a.position.map((b)=>Math.round(b*c.size));if("linear-gradient"===e)var h=t.createLinearGradient.apply(t,a);else if("radial-gradient"===e)h=t.createRadialGradient.apply(t,a);else throw Error("Unsupported fill");b.forEach(([b,a])=>{h.addColorStop(b,a)});t.fillStyle=h}}function y(t,c){a:{var a=c.text,e=
c.v,b=c.N,h=c.K,r=c.P;b=Math.max(1,b||1);for(h=Math.min(40,h||40);b<=h;b+=1)try{var d=B(a,e,b,r);break a}catch(J){}d=void 0}if(!d)return null;a=t.getContext("2d");c.background&&(a.fillStyle=c.background,a.fillRect(c.left,c.top,c.size,c.size));e=d.O;h=c.size/e;a.beginPath();for(r=0;r<e;r+=1)for(b=0;b<e;b+=1){var g=a,x=c.left+b*h,u=c.top+r*h,p=r,q=b,f=d.a,k=x+h,m=u+h,D=p-1,E=p+1,n=q-1,l=q+1,y=Math.floor(Math.min(.5,Math.max(0,c.R))*h),v=f(p,q),I=f(D,n),w=f(D,q);D=f(D,l);var F=f(p,l);l=f(E,l);q=f(E,
q);E=f(E,n);p=f(p,n);x=Math.round(x);u=Math.round(u);k=Math.round(k);m=Math.round(m);v?C(g,x,u,k,m,y,!w&&!p,!w&&!F,!q&&!F,!q&&!p):z(g,x,u,k,m,y,w&&p&&I,w&&F&&D,q&&F&&l,q&&p&&E)}A(a,c);a.fill();return t}var v={minVersion:1,maxVersion:40,ecLevel:"L",left:0,top:0,size:200,fill:"#000",background:null,text:"no text",radius:.5,quiet:0};G=function(t,c){var a={};Object.assign(a,v,t);a.N=a.minVersion;a.K=a.maxVersion;a.v=a.ecLevel;a.left=a.left;a.top=a.top;a.size=a.size;a.fill=a.fill;a.background=a.background;
a.text=a.text;a.R=a.radius;a.P=a.quiet;if(c instanceof HTMLCanvasElement){if(c.width!==a.size||c.height!==a.size)c.width=a.size,c.height=a.size;c.getContext("2d").clearRect(0,0,c.width,c.height);y(c,a)}else t=document.createElement("canvas"),t.width=a.size,t.height=a.size,a=y(t,a),c.appendChild(a)}})(function(){function w(c){var a=C.s(c);return{S:function(){return 4},b:function(){return a.length},write:function(c){for(var b=0;b<a.length;b+=1)c.put(a[b],8)}}}function B(){var c=[],a=0,e={B:function(){return c},
c:function(b){return 1==(c[Math.floor(b/8)]>>>7-b%8&1)},put:function(b,h){for(var a=0;a<h;a+=1)e.m(1==(b>>>h-a-1&1))},f:function(){return a},m:function(b){var h=Math.floor(a/8);c.length<=h&&c.push(0);b&&(c[h]|=128>>>a%8);a+=1}};return e}function C(c,a){function e(b,h){for(var a=-1;7>=a;a+=1)if(!(-1>=b+a||d<=b+a))for(var c=-1;7>=c;c+=1)-1>=h+c||d<=h+c||(r[b+a][h+c]=0<=a&&6>=a&&(0==c||6==c)||0<=c&&6>=c&&(0==a||6==a)||2<=a&&4>=a&&2<=c&&4>=c?!0:!1)}function b(b,a){for(var f=d=4*c+17,k=Array(f),m=0;m<
f;m+=1){k[m]=Array(f);for(var p=0;p<f;p+=1)k[m][p]=null}r=k;e(0,0);e(d-7,0);e(0,d-7);f=y.G(c);for(k=0;k<f.length;k+=1)for(m=0;m<f.length;m+=1){p=f[k];var q=f[m];if(null==r[p][q])for(var n=-2;2>=n;n+=1)for(var l=-2;2>=l;l+=1)r[p+n][q+l]=-2==n||2==n||-2==l||2==l||0==n&&0==l}for(f=8;f<d-8;f+=1)null==r[f][6]&&(r[f][6]=0==f%2);for(f=8;f<d-8;f+=1)null==r[6][f]&&(r[6][f]=0==f%2);f=y.w(h<<3|a);for(k=0;15>k;k+=1)m=!b&&1==(f>>k&1),r[6>k?k:8>k?k+1:d-15+k][8]=m,r[8][8>k?d-k-1:9>k?15-k:14-k]=m;r[d-8][8]=!b;if(7<=
c){f=y.A(c);for(k=0;18>k;k+=1)m=!b&&1==(f>>k&1),r[Math.floor(k/3)][k%3+d-8-3]=m;for(k=0;18>k;k+=1)m=!b&&1==(f>>k&1),r[k%3+d-8-3][Math.floor(k/3)]=m}if(null==g){b=t.I(c,h);f=B();for(k=0;k<x.length;k+=1)m=x[k],f.put(4,4),f.put(m.b(),y.f(4,c)),m.write(f);for(k=m=0;k<b.length;k+=1)m+=b[k].j;if(f.f()>8*m)throw Error("code length overflow. ("+f.f()+">"+8*m+")");for(f.f()+4<=8*m&&f.put(0,4);0!=f.f()%8;)f.m(!1);for(;!(f.f()>=8*m);){f.put(236,8);if(f.f()>=8*m)break;f.put(17,8)}var u=0;m=k=0;p=Array(b.length);
q=Array(b.length);for(n=0;n<b.length;n+=1){var v=b[n].j,w=b[n].o-v;k=Math.max(k,v);m=Math.max(m,w);p[n]=Array(v);for(l=0;l<p[n].length;l+=1)p[n][l]=255&f.B()[l+u];u+=v;l=y.C(w);v=z(p[n],l.b()-1).l(l);q[n]=Array(l.b()-1);for(l=0;l<q[n].length;l+=1)w=l+v.b()-q[n].length,q[n][l]=0<=w?v.c(w):0}for(l=f=0;l<b.length;l+=1)f+=b[l].o;f=Array(f);for(l=u=0;l<k;l+=1)for(n=0;n<b.length;n+=1)l<p[n].length&&(f[u]=p[n][l],u+=1);for(l=0;l<m;l+=1)for(n=0;n<b.length;n+=1)l<q[n].length&&(f[u]=q[n][l],u+=1);g=f}b=g;f=
-1;k=d-1;m=7;p=0;a=y.F(a);for(q=d-1;0<q;q-=2)for(6==q&&--q;;){for(n=0;2>n;n+=1)null==r[k][q-n]&&(l=!1,p<b.length&&(l=1==(b[p]>>>m&1)),a(k,q-n)&&(l=!l),r[k][q-n]=l,--m,-1==m&&(p+=1,m=7));k+=f;if(0>k||d<=k){k-=f;f=-f;break}}}var h=A[a],r=null,d=0,g=null,x=[],u={u:function(b){b=w(b);x.push(b);g=null},a:function(b,a){if(0>b||d<=b||0>a||d<=a)throw Error(b+","+a);return r[b][a]},h:function(){return d},J:function(){for(var a=0,h=0,c=0;8>c;c+=1){b(!0,c);var d=y.D(u);if(0==c||a>d)a=d,h=c}b(!1,h)}};return u}
function z(c,a){if("undefined"==typeof c.length)throw Error(c.length+"/"+a);var e=function(){for(var b=0;b<c.length&&0==c[b];)b+=1;for(var r=Array(c.length-b+a),d=0;d<c.length-b;d+=1)r[d]=c[d+b];return r}(),b={c:function(b){return e[b]},b:function(){return e.length},multiply:function(a){for(var h=Array(b.b()+a.b()-1),c=0;c<b.b();c+=1)for(var g=0;g<a.b();g+=1)h[c+g]^=v.i(v.g(b.c(c))+v.g(a.c(g)));return z(h,0)},l:function(a){if(0>b.b()-a.b())return b;for(var c=v.g(b.c(0))-v.g(a.c(0)),h=Array(b.b()),
g=0;g<b.b();g+=1)h[g]=b.c(g);for(g=0;g<a.b();g+=1)h[g]^=v.i(v.g(a.c(g))+c);return z(h,0).l(a)}};return b}C.s=function(c){for(var a=[],e=0;e<c.length;e++){var b=c.charCodeAt(e);128>b?a.push(b):2048>b?a.push(192|b>>6,128|b&63):55296>b||57344<=b?a.push(224|b>>12,128|b>>6&63,128|b&63):(e++,b=65536+((b&1023)<<10|c.charCodeAt(e)&1023),a.push(240|b>>18,128|b>>12&63,128|b>>6&63,128|b&63))}return a};var A={L:1,M:0,Q:3,H:2},y=function(){function c(b){for(var a=0;0!=b;)a+=1,b>>>=1;return a}var a=[[],[6,18],
[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],
[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],e={w:function(b){for(var a=b<<10;0<=c(a)-c(1335);)a^=1335<<c(a)-c(1335);return(b<<10|a)^21522},A:function(b){for(var a=b<<12;0<=c(a)-c(7973);)a^=7973<<c(a)-c(7973);return b<<12|a},G:function(b){return a[b-1]},F:function(b){switch(b){case 0:return function(b,a){return 0==(b+a)%2};case 1:return function(b){return 0==b%2};case 2:return function(b,a){return 0==a%3};case 3:return function(b,a){return 0==
(b+a)%3};case 4:return function(b,a){return 0==(Math.floor(b/2)+Math.floor(a/3))%2};case 5:return function(b,a){return 0==b*a%2+b*a%3};case 6:return function(b,a){return 0==(b*a%2+b*a%3)%2};case 7:return function(b,a){return 0==(b*a%3+(b+a)%2)%2};default:throw Error("bad maskPattern:"+b);}},C:function(b){for(var a=z([1],0),c=0;c<b;c+=1)a=a.multiply(z([1,v.i(c)],0));return a},f:function(b,a){if(4!=b||1>a||40<a)throw Error("mode: "+b+"; type: "+a);return 10>a?8:16},D:function(b){for(var a=b.h(),c=0,
d=0;d<a;d+=1)for(var g=0;g<a;g+=1){for(var e=0,t=b.a(d,g),p=-1;1>=p;p+=1)if(!(0>d+p||a<=d+p))for(var q=-1;1>=q;q+=1)0>g+q||a<=g+q||(0!=p||0!=q)&&t==b.a(d+p,g+q)&&(e+=1);5<e&&(c+=3+e-5)}for(d=0;d<a-1;d+=1)for(g=0;g<a-1;g+=1)if(e=0,b.a(d,g)&&(e+=1),b.a(d+1,g)&&(e+=1),b.a(d,g+1)&&(e+=1),b.a(d+1,g+1)&&(e+=1),0==e||4==e)c+=3;for(d=0;d<a;d+=1)for(g=0;g<a-6;g+=1)b.a(d,g)&&!b.a(d,g+1)&&b.a(d,g+2)&&b.a(d,g+3)&&b.a(d,g+4)&&!b.a(d,g+5)&&b.a(d,g+6)&&(c+=40);for(g=0;g<a;g+=1)for(d=0;d<a-6;d+=1)b.a(d,g)&&!b.a(d+
1,g)&&b.a(d+2,g)&&b.a(d+3,g)&&b.a(d+4,g)&&!b.a(d+5,g)&&b.a(d+6,g)&&(c+=40);for(g=e=0;g<a;g+=1)for(d=0;d<a;d+=1)b.a(d,g)&&(e+=1);return c+=Math.abs(100*e/a/a-50)/5*10}};return e}(),v=function(){for(var c=Array(256),a=Array(256),e=0;8>e;e+=1)c[e]=1<<e;for(e=8;256>e;e+=1)c[e]=c[e-4]^c[e-5]^c[e-6]^c[e-8];for(e=0;255>e;e+=1)a[c[e]]=e;return{g:function(b){if(1>b)throw Error("glog("+b+")");return a[b]},i:function(b){for(;0>b;)b+=255;for(;256<=b;)b-=255;return c[b]}}}(),t=function(){function c(b,c){switch(c){case A.L:return a[4*
(b-1)];case A.M:return a[4*(b-1)+1];case A.Q:return a[4*(b-1)+2];case A.H:return a[4*(b-1)+3]}}var a=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,
2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12,7,37,13],[5,122,98,1,123,99],[7,73,
45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,
151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],
[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],
[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],e={I:function(b,a){var e=c(b,a);if("undefined"==
typeof e)throw Error("bad rs block @ typeNumber:"+b+"/errorCorrectLevel:"+a);b=e.length/3;a=[];for(var d=0;d<b;d+=1)for(var g=e[3*d],h=e[3*d+1],t=e[3*d+2],p=0;p<g;p+=1){var q=t,f={};f.o=h;f.j=q;a.push(f)}return a}};return e}();return C}());
//# sourceMappingURL=qr-creator.min.js.map
var compareData;
var df = (function() {

  var gl = undefined; function glSet(context) { gl = context; }
  var prog = undefined; function getProg() { return prog; }

function loadShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

function initShaderProgram(gl, vs, fs) {
  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vs);
  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fs);
  const shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);
  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
    return null;
  }
  return shaderProgram;
}

  var ff = (function() {
    const CHUNK_EOF = 0;
    const CHUNK_GLYPHSET = 1;
    const CHUNK_GLYPHATTR = 2;
    const CHUNK_COLORGLYPHSET = 3;
    const CHUNK_COLORGLYPHATTR = 4;

    // attributes for CHUNK_GLYPHATTR chunks
    const ATTR_GLYPH_WIDTH = 0;
    const ATTR_GLYPH_HEIGHT = 1;
    const ATTR_GLYPH_X1 = 2;
    const ATTR_GLYPH_Y1 = 3;
    const ATTR_GLYPH_X2 = 4;
    const ATTR_GLYPH_Y2 = 5;
    const ATTR_GLYPH_IMGX = 6;
    const ATTR_GLYPH_IMGY = 7;
    const ATTR_GLYPH_IMGZD = 8;

    // attributes for CHUNK_COLORGLYPHATTR chunks
    const ATTR_COLORGLYPH_COLORS = 0;

    // z/depth values
    const ZD_ENCODE = [];
    ZD_ENCODE[0] = []; ZD_ENCODE[0][1] = 0;
    ZD_ENCODE[1] = []; ZD_ENCODE[1][1] = 1;
    ZD_ENCODE[2] = []; ZD_ENCODE[2][1] = 2;
    ZD_ENCODE[3] = []; ZD_ENCODE[3][1] = 3;
    ZD_ENCODE[4] = []; ZD_ENCODE[4][1] = 4;
    ZD_ENCODE[5] = []; ZD_ENCODE[5][1] = 5;
    ZD_ENCODE[0][2] = 6;
    ZD_ENCODE[1][2] = 7;
    ZD_ENCODE[2][2] = 8;
    ZD_ENCODE[3][2] = 9;
    ZD_ENCODE[0][3] = 10;
    ZD_ENCODE[1][3] = 11;

    const ZD_DECODE = [];
    ZD_DECODE[0] = [0, 1];
    ZD_DECODE[1] = [1, 1];
    ZD_DECODE[2] = [2, 1];
    ZD_DECODE[3] = [3, 1];
    ZD_DECODE[4] = [4, 1];
    ZD_DECODE[5] = [5, 1];
    ZD_DECODE[6] = [0, 2];
    ZD_DECODE[7] = [1, 2];
    ZD_DECODE[8] = [2, 2];
    ZD_DECODE[9] = [3, 2];
    ZD_DECODE[10] = [0, 3];
    ZD_DECODE[11] = [1, 3];

    class Packer {
      makeInt(n, length) { if(n<0) n=2**(length*4)+n; return ((new Array(length+1).join('0')) + n.toString(16)).substr(-length); }
      makeAttr(type, attr, size, value) { return (type).toString(16) + this.makeInt(1+1+size, 2) + this.makeInt(attr, 1) + this.makeInt(size, 1) + this.makeInt(value, size); }
      makeAttrs(type, attr, size, values) {
        var m=~~(253/size), n=values.length, i=0, buf='';
        while (n > 0) {
          var l = n>m? m : n; n-=l;
          buf += (type).toString(16) + this.makeInt(1+1+size*l, 2) + this.makeInt(attr, 1) + this.makeInt(size, 1);
          for (var j=0; j<l; j++) { buf += this.makeInt(values[i], size); i++; }
        }
        return buf;
      }
      makeColorAttrs(values) { // each value in the array of values is itself an array of 32-bit integer color values
        function from32(c) { return [((c/0x01000000)&0xFF)/255, ((c/0x00010000)&0xFF)/255, ((c/0x00000100)&0xFF)/255, ((c/0x00000001)&0xFF)/255]; }
        var m=254, n=0, i=0, buf='', tmp='';
        while (i < values.length) {
          var k = Math.min(Math.max(0, values[i].length), 15);
          if (n + 1+3*k > m) {
            buf += (CHUNK_COLORGLYPHATTR).toString(16) + this.makeInt(1+tmp.length, 2) + this.makeInt(ATTR_COLORGLYPH_COLORS, 1) + tmp;
            tmp=''; n=0;
          }
          n+=1+3*k; tmp+=(k).toString(16);
          for (var j=0; j<k; j++) {
            var c = from32(values[i][j]);
            tmp += Math.min(Math.max(0, ~~(c[0]*15)), 15).toString(16) + Math.min(Math.max(0, ~~(c[1]*15)), 15).toString(16) + Math.min(Math.max(0, ~~(c[2]*15)), 15).toString(16);
          }
          i++;
        }
        if (tmp.length > 0) {
          buf += (CHUNK_COLORGLYPHATTR).toString(16) + this.makeInt(1+tmp.length, 2) + this.makeInt(ATTR_COLORGLYPH_COLORS, 1) + tmp;
        }
        return buf;
      }
      //assembleAttrs(type, attr, size, values) {
      //  var m=~~(253/size), n=values.length, i=0, buf='';
      //  while (n > 0) {
      //    var l = n>m? m : n; n-=l;
      //    buf += (type).toString(16) + this.makeInt(1+1+size*l, 2) + this.makeInt(attr, 1) + this.makeInt(size, 1);
      //    for (var j=0; j<l; j++) { buf += (values[i] + (new Array(size+1).join('0'))).substr(0, size); i++; }
      //  }
      //  return buf;
      //}
      makeGlyphSet(first, last, colorMode) { return (colorMode?df.ff.CHUNK_COLORGLYPHSET:df.ff.CHUNK_GLYPHSET).toString(16) + '0c' + this.makeInt(first, 6) + this.makeInt(last, 6); }
      makeGlyphAttr(attr, size, value) { return this.makeAttr(df.ff.CHUNK_GLYPHATTR, attr, size, value); }
      makeGlyphAttrs(attr, size, values) { return this.makeAttrs(df.ff.CHUNK_GLYPHATTR, attr, size, values); }
      //makeGlyphPtr(x,y,z) { return ZD_ENCODE[z][1].toString(16) + this.makeInt(x, 4) + this.makeInt(y, 4); }
      //makeGlyphPtrs(values) { return this.assembleAttrs(df.ff.CHUNK_GLYPHATTR, df.ff.ATTR_GLYPH_IMG, 9, values); }
      //makeColorAttr(attr, size, value) { return this.makeAttr(df.ff.CHUNK_COLORATTR, attr, size, value); }
      //makeColorAttrs(attr, size, values) { return this.makeAttrs(df.ff.CHUNK_COLORATTR, attr, size, values); }
      //makeSolidAttr(attr, size, value) { return this.makeAttr(df.ff.CHUNK_SOLIDATTR, attr, size, value); }
      //makeSolidAttrs(attr, size, values) { return this.makeAttrs(df.ff.CHUNK_SOLIDATTR, attr, size, values); }
      makeEOF() { return (df.ff.CHUNK_EOF).toString(16) + '00'; }
    }

    class Parser {
      constructor(data) { this.reset(data); }
      reset(data) {
        this.data = data;
        this.i = 0;
      }
      skip(length) { this.i += length; }
      getInt(length) {
        var v;
        if (length + this.i <= this.data.length) v = parseInt(this.data.substr(this.i, length), 16);
        else v = parseInt((this.data + (new Array(this.i + length+1).join('0'))).substr(this.i, length), 16);
        this.i += length; return v;
      }
      getChunkHeader() {
        var type = this.getInt(1), length = this.getInt(2);
        return { type:type, length:length, };
      }
      getGlyphSet() {
        var first = this.getInt(6), last = this.getInt(6);
        return { first:first, last:last, };
      }
      getAttrs(length) {
        var attr = this.getInt(1), size = this.getInt(1), values = [];
        for (var i=0; i<(length-1-1)/size; i++) { values[values.length] = this.getInt(size); }
        return { attr:attr, size:size, values:values, };
      }
      getColorAttrs(length) {
        function to32(c) { return (~~(c[0]*255))*0x01000000 + (~~(c[1]*255))*0x00010000 + (~~(c[2]*255))*0x00000100 + (~~(c[3]*255))*0x00000001; }
        var attr = this.getInt(1), values = [];
        var l = length-1;
        while (l > 0) {
          var n = this.getInt(1); l-=1;
          var r,g,b, v = [];
          for (var i=0; i<n; i++) {
            if (l > 0) r = this.getInt(1); l-=1;
            if (l > 0) g = this.getInt(1); l-=1;
            if (l > 0) b = this.getInt(1); l-=1;
            v[v.length] = to32([r/15,g/15,b/15,1]);
          }
          values[values.length] = v;
        }
        return { attr:attr, values:values, };
      }
      applySign(v, length) {
        for (var i=0; i<v.length; i++) { if (v[i] >= 2**(length*4-1)) v[i] -= 2**(length*4); }
      }
    }

    return {
      CHUNK_EOF: CHUNK_EOF,
      CHUNK_GLYPHSET: CHUNK_GLYPHSET,
      CHUNK_GLYPHATTR: CHUNK_GLYPHATTR,
      CHUNK_COLORGLYPHSET: CHUNK_COLORGLYPHSET,
      CHUNK_COLORGLYPHATTR: CHUNK_COLORGLYPHATTR,
      ZD_ENCODE: ZD_ENCODE,
      ZD_DECODE: ZD_DECODE,
      ATTR_GLYPH_WIDTH: ATTR_GLYPH_WIDTH,
      ATTR_GLYPH_HEIGHT: ATTR_GLYPH_HEIGHT,
      ATTR_GLYPH_X1: ATTR_GLYPH_X1,
      ATTR_GLYPH_Y1: ATTR_GLYPH_Y1,
      ATTR_GLYPH_X2: ATTR_GLYPH_X2,
      ATTR_GLYPH_Y2: ATTR_GLYPH_Y2,
      ATTR_GLYPH_IMGX: ATTR_GLYPH_IMGX,
      ATTR_GLYPH_IMGY: ATTR_GLYPH_IMGY,
      ATTR_GLYPH_IMGZD: ATTR_GLYPH_IMGZD,
      ATTR_COLORGLYPH_COLORS: ATTR_COLORGLYPH_COLORS,
      Packer: Packer,
      Parser: Parser,
    };

  })();

  const vertexShaderSource = `
    attribute vec2 aVertex;
    attribute vec2 aUV;
    varying vec2 vTex;
    uniform vec2 pos;
    uniform mat4 uProjectionMatrix;
    uniform mat4 uModelViewMatrix;
    void main(void) {
      gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertex + pos, 0.0, 1.0);
      vTex = aUV;
    }
    `;
  const fragmentShaderSource = `
    precision highp float;
    varying vec2 vTex;
    uniform sampler2D sampler0;
    uniform lowp vec4 color1;
    uniform lowp vec4 color2;
    uniform lowp vec4 color3;
    uniform int layer;
    uniform int depth;
    uniform float scaleFactor;
    uniform int sampleBase;
    void main(void){
      float v1=0.0, v2=0.0, v3=0.0;
      int ss = sampleBase;
      float tx =1.0/64.0;
      float ty =1.0/128.0;
      float o = float(ss-1)/2.0;
      int i=0, j=0;
      for(int i=0; i<4; i++) {
				if (i>=ss) break;
        for(int j=0; j<4; j++) {
					if (j>=ss) break;
          vec4 c = texture2D(sampler0, vTex+vec2((float(i)-o)/float(ss)*tx/scaleFactor,(float(j)-o)/float(ss)*ty/scaleFactor));//texture(tex, texCoordOut+vec2((i-o)/float(ss)*tx/scaleFactor,(j-o)/float(ss)*ty/scaleFactor));
          if (layer == 0) {
            v1 += c.r>=.5 ? 1.0 : 0.0;
            if (depth >= 2) v2 += c.g>=.5 ? 1.0 : 0.0;
            if (depth >= 3) v3 += c.b>=.5 ? 1.0 : 0.0;
          } else if (layer == 1) {
            v1 += c.g>=.5 ? 1.0 : 0.0;
            if (depth >= 2) v2 += c.b>=.5 ? 1.0 : 0.0;
          } else if (layer == 2) {
            v1 += c.b>=.5 ? 1.0 : 0.0;
          }
        }
      }
      //vec4 o1 = vec4(color1.rgb * (v1/float(ss*ss)), v1/float(ss*ss));
      //vec4 o2 = vec4(color2.rgb * (v2/float(ss*ss)), v2/float(ss*ss));
      //vec4 o3 = vec4(color3.rgb * (v3/float(ss*ss)), v3/float(ss*ss));
      vec4 o1 = vec4(color1.rgb, v1/float(ss*ss)*color1.a);
      vec4 o2 = vec4(color2.rgb, v2/float(ss*ss)*color2.a);
      vec4 o3 = vec4(color3.rgb, v3/float(ss*ss)*color3.a);
      o1.rgb += o2.rgb * (1.0 - o1.a); o1.a += o2.a * (1.0 - o1.a);
      o1.rgb += o3.rgb * (1.0 - o1.a); o1.a += o3.a * (1.0 - o1.a);
      gl_FragColor = o1;
    }
    `;

  class GlyphSet {
    constructor() {
			this.nextId = 1;
			this.fidelity = 4;
		}
    loadFromURL(name, callback, src) {
      var img = new Image();
      img.associatedGlyphSet = this;
      img.associatedCallback = callback;
      img.associatedName = name;
      img.onload = this.imgCallback;
      img.src = src;
    }
    loadFromImage(name, callback, imageElement) {
      this.loadFromObject(name, callback, imageElement);
    }
    loadFromCanvas(name, callback, canvasElement) {
      this.loadFromObject(name, callback, canvasElement);
    }
    initGlyphs() { // new
      this.glyphCodes = [];
      this.glyphWidths = []; this.glyphHeights = [];
      this.glyphX1 = []; this.glyphY1 = [];
      this.glyphX2 = []; this.glyphY2 = [];
      this.glyphSourceX = [], this.glyphSourceY = [], this.glyphSourceZD = [];
      this.glyphHasColors = [];
      this.glyphColors = [];
    }
    //initColors() { // new
    //  this.glyphColorIndices = [];
    //  this.colorType = [];
    //  this.solidRGB = [];
    //  this.solidMode = [];
    //}
    isReady() { return (this.ready) ? true : false; }
    imgCallback(event) {
      var img = event.target;
      var obj = img.associatedGlyphSet;
      obj.loadFromObject.call(obj, img.associatedName, img.associatedCallback, img);
    }
    loadFromObject(name, callback, element) {
      this.ready = false;
      this.finalCallback = callback;
      this.name = name;

//      this.tLine = 0; this.mLine = 0; this.bLine = 0; this.xSize = 0; this.ySize = 0;
//      this.lo = 0; this.hi = 0;
//      this.proportional = 0; this.colorLayers = 0;

      this.initGlyphs();
      //this.initColors();

      // per glyph
//      this.spaceBefore = [], this.spaceAfter = [], this.width = [], this.planes = [], this.planeIndex = [];

      // per plane
//      this.sourceX = [], this.sourceY = [], this.layer = [], this.color = [];
      this.pixCoords = [], this.texCoords = [];

      this.init2(element);
//console.log('Loaded '+ this.glyphCodes.length +' glyphs in new format.');
      if (this.glyphCodes.length == 0) {
				this.init1(element);
console.log('Loaded '+ this.glyphCodes.length +' glyphs in old format.');
			}
    }
    init1(image) {
      var img = image;
      var tempCanvas = document.createElement('canvas');
      tempCanvas.width = img.width;
      tempCanvas.height = img.height * 2;
      var c = tempCanvas.getContext('2d');
      c.drawImage(img, 0, 0);
      c.drawImage(img, 0, img.height);

      var imageData = c.getImageData(0, 0, img.width, img.height);
      var d = imageData.data;
      for (var i=0; i<d.length; i+=4) {
        d[i+0] = (d[i+0]&240) + ~~((d[i+0]&240)/16);
        d[i+1] = (d[i+1]&240) + ~~((d[i+1]&240)/16);
        d[i+2] = (d[i+2]&240) + ~~((d[i+2]&240)/16);
      }
      c.putImageData(imageData, 0, 0);
      var imageData = c.getImageData(0, img.height, img.width, img.height);
      var d = imageData.data;
      for (var i=0; i<d.length; i+=4) {
        d[i+0] = (d[i+0]&15) + (d[i+0]&15)*16;
        d[i+1] = (d[i+1]&15) + (d[i+1]&15)*16;
        d[i+2] = (d[i+2]&15) + (d[i+2]&15)*16;
      }
      c.putImageData(imageData, 0, img.height);

      function getDataBlock(r) {
        var p = 0, z = r.zd<=5? r.zd : r.zd<=9? r.zd-6 : r.zd-10, depth = r.zd<=5? 1 : r.zd<=9? 2 : 3, zz = ~~(z/2);
        var imageData = c.getImageData(r.x, r.y+((z%2)==1?img.height:0), r.w, r.h);
        var d = imageData.data;
        function getNyb() {
          while (p<d.length && (((p%4) == 0 && (zz>0)) || ((p%4) == 1 && (zz>1||depth+zz<2)) || ((p%4) == 2 && (depth+zz<3)) || (p%4) == 3)) { p+=1; }
          var n = d[p]&15; p+=1;
          while (p<d.length && (((p%4) == 0 && (zz>0)) || ((p%4) == 1 && (zz>1||depth+zz<2)) || ((p%4) == 2 && (depth+zz<3)) || (p%4) == 3)) { p+=1; }
          return n;
        }
        var blockType = getNyb();
        var zd = getNyb();
        var nw = (getNyb())*16 + (getNyb()); if (nw==0) nw=256;
        var nh = (getNyb())*16 + (getNyb()); if (nh==0) nh=256;
        var nx = (getNyb())*4096 + (getNyb())*256 + (getNyb())*16 + (getNyb());
        var ny = (getNyb())*4096 + (getNyb())*256 + (getNyb())*16 + (getNyb());
        var data = '';
        while (p<d.length) {
          data = data + (getNyb()).toString(16);
        }
        r.x = nx;
        r.y = ny;
        r.w = nw;
        r.h = nh;
        r.zd = zd;
        return data;
      }

      var r=[]; r["x"]=img.width-2; r["y"]=1; r["w"]=1; r["h"]=5; r["zd"]=10;
      var hexData = getDataBlock(r, true);
      do {
        hexData = hexData + getDataBlock(r);
      } while (r.x);

      var p = new ff.Parser(hexData);
      var chunk = p.getChunkHeader();
      var iw=0,ih=0, ix0=0,iy0=0, ix1=0,iy1=0, isx=0,isy=0,isz=0;
      var ici=0, ict=0, isrgb=0, ism=0;
      var igc=0;
      while (chunk.type != ff.CHUNK_EOF) {
        //if (chunk.type == ff.CHUNK_GLYPHCOLORATTR && this.glyphColorIndices.length == 0) {
        //  for (var i=0; i<this.glyphCodes.length; i++) for (var j=0; j<this.glyphColors[i]; j++) { this.glyphColorIndices[this.glyphColorIndices.length] = 0; }
        //}
        if (chunk.type == ff.CHUNK_COLORATTR && this.colorType.length == 0) {
          for (var i=0; i<this.glyphColorIndices.length; i++) { while (this.glyphColorIndices[i] >= this.colorType.length) this.colorType[this.colorType.length] = 0; }
        }
        if (chunk.type == ff.CHUNK_SOLIDATTR && this.solidRGB.length == 0) {
          for (var i=0; i<this.colorType.length; i++) { if (this.colorType[i]==0) { this.solidRGB[this.solidRGB.length] = 0; this.solidMode[this.solidMode.length] = 0; } }
        }
        switch(chunk.type) {
        case ff.CHUNK_GLYPHSET:
        case ff.CHUNK_COLORGLYPHSET:
          if(chunk.length==12) {
            var gs = p.getGlyphSet();
            for (i=gs.first; i<=gs.last; i++) {
              var l = this.glyphCodes.length;
              this.glyphCodes[l] = i;
              this.glyphWidths[l] = 8; this.glyphHeights[l] = 8;
              this.glyphX1[l] = 0; this.glyphY1[l] = 0;
              this.glyphX2[l] = 8; this.glyphY2[l] = 0;
              this.glyphHasColors[l] = (chunk.type==ff.CHUNK_COLORGLYPHSET)?1:0;
              this.glyphColors[l] = [];
            }
          } else {
            console.log('chuck length: ', chunk.length);
            console.log('error: bad data 1:', p.data.substr(p.i, 10));
            p.skip(chunk.length);
          }
          break;
        case ff.CHUNK_GLYPHATTR:
          var start = p.i;
          var ga = p.getAttrs(chunk.length);
          if (ga.values.length == 1) {
            switch((chunk.type<<16) + ga.attr) {
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_WIDTH: for (i=0; i<this.glyphCodes.length; i++) { this.glyphWidths[i] = ga.values[0]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_HEIGHT: for (i=0; i<this.glyphCodes.length; i++) { this.glyphHeights[i] = ga.values[0]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_X1: p.applySign(ga.values, ga.size); for (i=0; i<this.glyphCodes.length; i++) { this.glyphX1[i] = ga.values[0]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_Y1: p.applySign(ga.values, ga.size); for (i=0; i<this.glyphCodes.length; i++) { this.glyphY1[i] = ga.values[0]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_X2: p.applySign(ga.values, ga.size); for (i=0; i<this.glyphCodes.length; i++) { this.glyphX2[i] = ga.values[0]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_Y2: p.applySign(ga.values, ga.size); for (i=0; i<this.glyphCodes.length; i++) { this.glyphY2[i] = ga.values[0]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_IMGX: for (i=0; i<this.glyphCodes.length; i++) { this.glyphSourceX[i] = ga.values[0]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_IMGY: for (i=0; i<this.glyphCodes.length; i++) { this.glyphSourceY[i] = ga.values[0]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_IMGZD:for (i=0; i<this.glyphCodes.length; i++) { this.glyphSourceZD[i]= ga.values[0]; } break;
            //case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_COLORS: for (i=0; i<this.glyphCodes.length; i++) { this.glyphColors[i] = ga.values[0]; } break;
            //case (ff.CHUNK_GLYPHCOLORATTR<<16) + ff.ATTR_GLYPHCOLOR_INDEX: for (i=0; i<this.glyphColorIndices.length; i++) { this.glyphColorIndices[i] = ga.values[0]; } break;
            //case (ff.CHUNK_COLORATTR<<16) + ff.ATTR_COLOR_TYPE: for (i=0; i<this.colorType.length; i++) { this.colorType[i] = ga.values[0]; } break;
            //case (ff.CHUNK_SOLIDATTR<<16) + ff.ATTR_SOLID_RGB: for (i=0; i<this.solidRGB.length; i++) { this.solidRGB[i] = ga.values[0]; } break;
            //case (ff.CHUNK_SOLIDATTR<<16) + ff.ATTR_SOLID_MODE: for (i=0; i<this.solidMode.length; i++) { this.solidMode[i] = ga.values[0]; } break;
            default:
              console.log('chuck length: ', chunk.length);
              console.log('ignoring unknown attribute: ', chunk.type, ga.attr);
              p.skip(chunk.length);
            }
          } else {
            switch((chunk.type<<16) + ga.attr) {
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_WIDTH: for (i=0; i<ga.values.length; i++) { this.glyphWidths[iw++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_HEIGHT: for (i=0; i<ga.values.length; i++) { this.glyphHeights[ih++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_X1: p.applySign(ga.values, ga.size); for (i=0; i<ga.values.length; i++) { this.glyphX1[ix0++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_Y1: p.applySign(ga.values, ga.size); for (i=0; i<ga.values.length; i++) { this.glyphY1[iy0++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_X2: p.applySign(ga.values, ga.size); for (i=0; i<ga.values.length; i++) { this.glyphX2[ix1++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_Y2: p.applySign(ga.values, ga.size); for (i=0; i<ga.values.length; i++) { this.glyphY2[iy1++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_IMGX: for (i=0; i<ga.values.length; i++) { this.glyphSourceX[isx++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_IMGY: for (i=0; i<ga.values.length; i++) { this.glyphSourceY[isy++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_IMGZD:for (i=0; i<ga.values.length; i++) { this.glyphSourceZD[isz++]= ga.values[i]; } break;
            //case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_COLORS: for (i=0; i<ga.values.length; i++) { this.glyphColors[iy1++] = ga.values[i]; } break;
            //case (ff.CHUNK_GLYPHCOLORATTR<<16) + ff.ATTR_GLYPHCOLOR_INDEX: for (i=0; i<ga.values.length; i++) { this.glyphColorIndices[ici++] = ga.values[i]; } break;
            //case (ff.CHUNK_COLORATTR<<16) + ff.ATTR_COLOR_TYPE: for (i=0; i<ga.values.length; i++) { this.colorType[ict++] = ga.values[i]; } break;
            //case (ff.CHUNK_SOLIDATTR<<16) + ff.ATTR_SOLID_RGB: for (i=0; i<ga.values.length; i++) { this.solidRGB[isrgb++] = ga.values[i]; } break;
            //case (ff.CHUNK_SOLIDATTR<<16) + ff.ATTR_SOLID_MODE: for (i=0; i<ga.values.length; i++) { this.solidMode[ism++] = ga.values[i]; } break;
            default:
              console.log('ignoring unknown attribute: ', chunk.type, ga.attr);
              p.skip(chunk.length);
            }
          }
          if (p.i-start!=chunk.length) {
            console.log('error: bad data 2');
          }
          break;
        case ff.CHUNK_COLORGLYPHATTR:
          var ga = p.getColorAttrs(chunk.length);
          switch(ga.attr) {
          case ff.ATTR_COLORGLYPH_COLORS:
            for (i=0; i<ga.values.length; i++) { while (!this.glyphHasColors[igc] && igc < this.glyphCodes.length) igc++; if (igc < this.glyphCodes.length) this.glyphColors[igc++] = ga.values[i]; }
            break;
          default:
            console.log('ignoring unknown color attribute: ', chunk.type, attr);
            p.skip(chunk.length-1);
          }
          break;
        default:
          console.log('ignoring unknown chunk type: ', chunk);
          p.skip(chunk.length);
        }
        chunk = p.getChunkHeader();
      }

      for (var i=0; i<this.glyphCodes.length; i++) {
        if ((this.glyphSourceZD[i] % 2)==1) this.glyphSourceY[i] += img.height;
      }

      var bmWidth = img.width;
      var bmHeight = img.height;

      for (var g = 0; g < this.glyphCodes.length; g++) { var b = g;
        this.pixCoords[b*8 + 0] = 0; this.pixCoords[b*8 + 1] = this.glyphHeights[g];
        this.pixCoords[b*8 + 2] = 0; this.pixCoords[b*8 + 3] = 0;
        this.pixCoords[b*8 + 4] = this.glyphWidths[g]; this.pixCoords[b*8 + 5] = 0;
        this.pixCoords[b*8 + 6] = this.glyphWidths[g]; this.pixCoords[b*8 + 7] = this.glyphHeights[g];
        this.texCoords[b*8 + 0] = this.glyphSourceX[b] / bmWidth; this.texCoords[b*8 + 1] = (this.glyphSourceY[b] + this.glyphHeights[g]) / (bmHeight*2);
        this.texCoords[b*8 + 2] = this.glyphSourceX[b] / bmWidth; this.texCoords[b*8 + 3] = this.glyphSourceY[b] / (bmHeight*2);
        this.texCoords[b*8 + 4] = (this.glyphSourceX[b] + this.glyphWidths[g]) / bmWidth; this.texCoords[b*8 + 5] = this.glyphSourceY[b] / (bmHeight*2);
        this.texCoords[b*8 + 6] = (this.glyphSourceX[b] + this.glyphWidths[g]) / bmWidth; this.texCoords[b*8 + 7] = (this.glyphSourceY[b] + this.glyphHeights[g]) / (bmHeight*2);
      }

      var imageData = c.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
      var d = imageData.data;
      for (var i = 0; i < ~~(d.length / 2); i += 4) {
        d[i + 0] = (d[i + 0] & 15) * 16; // red
        d[i + 1] = (d[i + 1] & 15) * 16; // green
        d[i + 2] = (d[i + 2] & 15) * 16; // blue
        d[i + 0] = d[i + 0] | ~~(d[i + 0] / 16); // red
        d[i + 1] = d[i + 1] | ~~(d[i + 1] / 16); // green
        d[i + 2] = d[i + 2] | ~~(d[i + 2] / 16); // blue
      }
      for (var i = ~~(d.length / 2); i < d.length; i += 4) {
        d[i + 0] = (~~(d[i + 0] / 16)) * 16; // red
        d[i + 1] = (~~(d[i + 1] / 16)) * 16; // green
        d[i + 2] = (~~(d[i + 2] / 16)) * 16; // blue
        d[i + 0] = d[i + 0] | ~~(d[i + 0] / 16); // red
        d[i + 1] = d[i + 1] | ~~(d[i + 1] / 16); // green
        d[i + 2] = d[i + 2] | ~~(d[i + 2] / 16); // blue
      }
      c.putImageData(imageData, 0, 0);
      this.data = tempCanvas;

      d = null; imageData = null;
      c = null; tempCanvas = null;

      this.ready = true;
      if (this.finalCallback) this.finalCallback.call(null);
    }
    init2(image) {
      var img = image;
      var tempCanvas = document.createElement('canvas');
      tempCanvas.width = img.width;
      tempCanvas.height = img.height * 2;
      var c = tempCanvas.getContext('2d', { willReadFrequently: true });
      c.drawImage(img, 0, 0);
      c.drawImage(img, 0, img.height);

      var imageData = c.getImageData(0, img.height, img.width, img.height);
      var d = imageData.data;
      for (var i=0; i<d.length; i+=4) {
        d[i+0] = (d[i+0]&240) + ~~((d[i+0]&240)/16);
        d[i+1] = (d[i+1]&240) + ~~((d[i+1]&240)/16);
        d[i+2] = (d[i+2]&240) + ~~((d[i+2]&240)/16);
      }
      c.putImageData(imageData, 0, img.height);
      var imageData = c.getImageData(0, 0, img.width, img.height);
      var d = imageData.data;
      for (var i=0; i<d.length; i+=4) {
        d[i+0] = (d[i+0]&15) + (d[i+0]&15)*16;
        d[i+1] = (d[i+1]&15) + (d[i+1]&15)*16;
        d[i+2] = (d[i+2]&15) + (d[i+2]&15)*16;
      }
      c.putImageData(imageData, 0, 0);

      function getDataBlock(r, init=false) {
        var p = 0, z = r.zd<=5? r.zd : r.zd<=9? r.zd-6 : r.zd-10, depth = r.zd<=5? 1 : r.zd<=9? 2 : 3, zz = ~~(z/2);
        var imageData = c.getImageData(r.x, r.y+((z%2)==1?img.height:0), r.w, r.h);
        var d = imageData.data;
        function getNyb() {
          while (p<d.length && (((p%4) == 0 && (zz>0)) || ((p%4) == 1 && (zz>1||depth+zz<2)) || ((p%4) == 2 && (depth+zz<3)) || (p%4) == 3)) { p+=1; }
          var n = d[p]&15; p+=1;
          while (p<d.length && (((p%4) == 0 && (zz>0)) || ((p%4) == 1 && (zz>1||depth+zz<2)) || ((p%4) == 2 && (depth+zz<3)) || (p%4) == 3)) { p+=1; }
          return n;
        }
        if (init) {
          var ff = '';
          ff += getNyb().toString(16);
          ff += getNyb().toString(16);
          ff += getNyb().toString(16);
          ff += getNyb().toString(16);
          r.ver = ff;
        }
        var blockType = getNyb();
        var zd = getNyb();
        var nw = (getNyb())*16 + (getNyb()); if (nw==0) nw=256;
        var nh = (getNyb())*16 + (getNyb()); if (nh==0) nh=256;
        var nx = (getNyb())*4096 + (getNyb())*256 + (getNyb())*16 + (getNyb());
        var ny = (getNyb())*4096 + (getNyb())*256 + (getNyb())*16 + (getNyb());
        var data = '';
        while (p<d.length) {
          data = data + (getNyb()).toString(16);
        }
        r.x = nx;
        r.y = ny;
        r.w = nw;
        r.h = nh;
        r.zd = zd;
        return data;
      }

      var r=[]; r["x"]=img.width-2; r["y"]=1; r["w"]=1; r["h"]=6; r["zd"]=10;
      var hexData = getDataBlock(r, true);
//console.log('File format: '+r.ver);
      if (r.ver != 'fed1') { console.log('Unrecognized file format.'); return; }
      do {
        hexData = hexData + getDataBlock(r);
      } while (r.x);

      var p = new ff.Parser(hexData);
      var chunk = p.getChunkHeader();
      var iw=0,ih=0, ix0=0,iy0=0, ix1=0,iy1=0, isx=0,isy=0,isz=0;
      var ici=0, ict=0, isrgb=0, ism=0;
      var igc=0;
      while (chunk.type != ff.CHUNK_EOF) {
        //if (chunk.type == ff.CHUNK_GLYPHCOLORATTR && this.glyphColorIndices.length == 0) {
        //  for (var i=0; i<this.glyphCodes.length; i++) for (var j=0; j<this.glyphColors[i]; j++) { this.glyphColorIndices[this.glyphColorIndices.length] = 0; }
        //}
        if (chunk.type == ff.CHUNK_COLORATTR && this.colorType.length == 0) {
          for (var i=0; i<this.glyphColorIndices.length; i++) { while (this.glyphColorIndices[i] >= this.colorType.length) this.colorType[this.colorType.length] = 0; }
        }
        if (chunk.type == ff.CHUNK_SOLIDATTR && this.solidRGB.length == 0) {
          for (var i=0; i<this.colorType.length; i++) { if (this.colorType[i]==0) { this.solidRGB[this.solidRGB.length] = 0; this.solidMode[this.solidMode.length] = 0; } }
        }
        switch(chunk.type) {
        case ff.CHUNK_GLYPHSET:
        case ff.CHUNK_COLORGLYPHSET:
          if(chunk.length==12) {
            var gs = p.getGlyphSet();
            for (i=gs.first; i<=gs.last; i++) {
              var l = this.glyphCodes.length;
              this.glyphCodes[l] = i;
              this.glyphWidths[l] = 8; this.glyphHeights[l] = 8;
              this.glyphX1[l] = 0; this.glyphY1[l] = 0;
              this.glyphX2[l] = 8; this.glyphY2[l] = 0;
              this.glyphHasColors[l] = (chunk.type==ff.CHUNK_COLORGLYPHSET)?1:0;
              this.glyphColors[l] = [];
            }
          } else {
            console.log('chuck length: ', chunk.length);
            console.log('error: bad data 1:', p.data.substr(p.i, 10));
            return;
          }
          break;
        case ff.CHUNK_GLYPHATTR:
          var start = p.i;
          var ga = p.getAttrs(chunk.length);
          if (ga.values.length == 1) {
            switch((chunk.type<<16) + ga.attr) {
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_WIDTH: for (i=0; i<this.glyphCodes.length; i++) { this.glyphWidths[iw++] = ga.values[0]; if(iw>=this.glyphCodes.length)break; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_HEIGHT: for (i=0; i<this.glyphCodes.length; i++) { this.glyphHeights[ih++] = ga.values[0]; if(ih>=this.glyphCodes.length)break; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_X1: p.applySign(ga.values, ga.size); for (i=0; i<this.glyphCodes.length; i++) { this.glyphX1[ix0++] = ga.values[0]; if(ix0>=this.glyphCodes.length)break;} break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_Y1: p.applySign(ga.values, ga.size); for (i=0; i<this.glyphCodes.length; i++) { this.glyphY1[iy0++] = ga.values[0]; if(iy0>=this.glyphCodes.length)break;} break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_X2: p.applySign(ga.values, ga.size); for (i=0; i<this.glyphCodes.length; i++) { this.glyphX2[ix1++] = ga.values[0]; if(ix1>=this.glyphCodes.length)break;} break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_Y2: p.applySign(ga.values, ga.size); for (i=0; i<this.glyphCodes.length; i++) { this.glyphY2[iy1++] = ga.values[0]; if(iy1>=this.glyphCodes.length)break;} break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_IMGX: for (i=0; i<this.glyphCodes.length; i++) { this.glyphSourceX[isx++] = ga.values[0]; if(isx>=this.glyphCodes.length)break; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_IMGY: for (i=0; i<this.glyphCodes.length; i++) { this.glyphSourceY[isy++] = ga.values[0]; if(isy>=this.glyphCodes.length)break; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_IMGZD:for (i=0; i<this.glyphCodes.length; i++) { this.glyphSourceZD[isz++]= ga.values[0]; if(isz>=this.glyphCodes.length)break; } break;
            //case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_COLORS: for (i=0; i<this.glyphCodes.length; i++) { this.glyphColors[i] = ga.values[0]; } break;
            //case (ff.CHUNK_GLYPHCOLORATTR<<16) + ff.ATTR_GLYPHCOLOR_INDEX: for (i=0; i<this.glyphColorIndices.length; i++) { this.glyphColorIndices[i] = ga.values[0]; } break;
            //case (ff.CHUNK_COLORATTR<<16) + ff.ATTR_COLOR_TYPE: for (i=0; i<this.colorType.length; i++) { this.colorType[i] = ga.values[0]; } break;
            //case (ff.CHUNK_SOLIDATTR<<16) + ff.ATTR_SOLID_RGB: for (i=0; i<this.solidRGB.length; i++) { this.solidRGB[i] = ga.values[0]; } break;
            //case (ff.CHUNK_SOLIDATTR<<16) + ff.ATTR_SOLID_MODE: for (i=0; i<this.solidMode.length; i++) { this.solidMode[i] = ga.values[0]; } break;
            default:
              console.log('ignoring unknown attribute: ', chunk.type, ga.attr);
              p.skip(chunk.length);
            }
          } else {
            switch((chunk.type<<16) + ga.attr) {
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_WIDTH: for (i=0; i<ga.values.length; i++) { this.glyphWidths[iw++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_HEIGHT: for (i=0; i<ga.values.length; i++) { this.glyphHeights[ih++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_X1: p.applySign(ga.values, ga.size); for (i=0; i<ga.values.length; i++) { this.glyphX1[ix0++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_Y1: p.applySign(ga.values, ga.size); for (i=0; i<ga.values.length; i++) { this.glyphY1[iy0++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_X2: p.applySign(ga.values, ga.size); for (i=0; i<ga.values.length; i++) { this.glyphX2[ix1++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_Y2: p.applySign(ga.values, ga.size); for (i=0; i<ga.values.length; i++) { this.glyphY2[iy1++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_IMGX: for (i=0; i<ga.values.length; i++) { this.glyphSourceX[isx++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_IMGY: for (i=0; i<ga.values.length; i++) { this.glyphSourceY[isy++] = ga.values[i]; } break;
            case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_IMGZD:for (i=0; i<ga.values.length; i++) { this.glyphSourceZD[isz++]= ga.values[i]; } break;
            //case (ff.CHUNK_GLYPHATTR<<16) + ff.ATTR_GLYPH_COLORS: for (i=0; i<ga.values.length; i++) { this.glyphColors[iy1++] = ga.values[i]; } break;
            //case (ff.CHUNK_GLYPHCOLORATTR<<16) + ff.ATTR_GLYPHCOLOR_INDEX: for (i=0; i<ga.values.length; i++) { this.glyphColorIndices[ici++] = ga.values[i]; } break;
            //case (ff.CHUNK_COLORATTR<<16) + ff.ATTR_COLOR_TYPE: for (i=0; i<ga.values.length; i++) { this.colorType[ict++] = ga.values[i]; } break;
            //case (ff.CHUNK_SOLIDATTR<<16) + ff.ATTR_SOLID_RGB: for (i=0; i<ga.values.length; i++) { this.solidRGB[isrgb++] = ga.values[i]; } break;
            //case (ff.CHUNK_SOLIDATTR<<16) + ff.ATTR_SOLID_MODE: for (i=0; i<ga.values.length; i++) { this.solidMode[ism++] = ga.values[i]; } break;
            default:
              console.log('ignoring unknown attribute: ', chunk.type, ga.attr);
              p.skip(chunk.length);
            }
          }
          if (p.i-start!=chunk.length) {
            console.log('error: bad data 2');
          }
          break;
        case ff.CHUNK_COLORGLYPHATTR:
          var ga = p.getColorAttrs(chunk.length);
          switch(ga.attr) {
          case ff.ATTR_COLORGLYPH_COLORS:
            for (i=0; i<ga.values.length; i++) {
              while (!this.glyphHasColors[igc] && igc < this.glyphCodes.length) this.glyphColors[igc++] = null;
              if (igc < this.glyphCodes.length) this.glyphColors[igc++] = ga.values[i];
            }
            while (!this.glyphHasColors[igc] && igc < this.glyphCodes.length) this.glyphColors[igc++] = null; 
            break;
          default:
            console.log('ignoring unknown color attribute: ', chunk.type, attr);
            p.skip(chunk.length-1);
          }
          break;
        default:
          console.log('ignoring unknown chunk type: ', chunk);
          p.skip(chunk.length);
        }
        chunk = p.getChunkHeader();
      }

      for (var i=0; i<this.glyphCodes.length; i++) {
        if ((this.glyphSourceZD[i] % 2)==1) this.glyphSourceY[i] += img.height;
      }

      var bmWidth = img.width;
      var bmHeight = img.height;
			this.texWidth = img.width;
			this.texHeight = img.height;

      for (var g = 0; g < this.glyphCodes.length; g++) { var b = g;
        this.pixCoords[b*8 + 0] = 0; this.pixCoords[b*8 + 1] = this.glyphHeights[g];
        this.pixCoords[b*8 + 2] = 0; this.pixCoords[b*8 + 3] = 0;
        this.pixCoords[b*8 + 4] = this.glyphWidths[g]; this.pixCoords[b*8 + 5] = 0;
        this.pixCoords[b*8 + 6] = this.glyphWidths[g]; this.pixCoords[b*8 + 7] = this.glyphHeights[g];
        this.texCoords[b*8 + 0] = this.glyphSourceX[b] / bmWidth; this.texCoords[b*8 + 1] = (this.glyphSourceY[b] + this.glyphHeights[g]) / (bmHeight*2);
        this.texCoords[b*8 + 2] = this.glyphSourceX[b] / bmWidth; this.texCoords[b*8 + 3] = this.glyphSourceY[b] / (bmHeight*2);
        this.texCoords[b*8 + 4] = (this.glyphSourceX[b] + this.glyphWidths[g]) / bmWidth; this.texCoords[b*8 + 5] = this.glyphSourceY[b] / (bmHeight*2);
        this.texCoords[b*8 + 6] = (this.glyphSourceX[b] + this.glyphWidths[g]) / bmWidth; this.texCoords[b*8 + 7] = (this.glyphSourceY[b] + this.glyphHeights[g]) / (bmHeight*2);
      }

      var imageData = c.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
      var d = imageData.data;
      for (var i = 0; i < ~~(d.length / 2); i += 4) {
        d[i + 0] = (d[i + 0] & 15) * 16; // red
        d[i + 1] = (d[i + 1] & 15) * 16; // green
        d[i + 2] = (d[i + 2] & 15) * 16; // blue
        d[i + 0] = d[i + 0] | ~~(d[i + 0] / 16); // red
        d[i + 1] = d[i + 1] | ~~(d[i + 1] / 16); // green
        d[i + 2] = d[i + 2] | ~~(d[i + 2] / 16); // blue
      }
      for (var i = ~~(d.length / 2); i < d.length; i += 4) {
        d[i + 0] = (~~(d[i + 0] / 16)) * 16; // red
        d[i + 1] = (~~(d[i + 1] / 16)) * 16; // green
        d[i + 2] = (~~(d[i + 2] / 16)) * 16; // blue
        d[i + 0] = d[i + 0] | ~~(d[i + 0] / 16); // red
        d[i + 1] = d[i + 1] | ~~(d[i + 1] / 16); // green
        d[i + 2] = d[i + 2] | ~~(d[i + 2] / 16); // blue
      }
      c.putImageData(imageData, 0, 0);
      this.data = tempCanvas;

      d = null; imageData = null;
      c = null; tempCanvas = null;

      this.ready = true;
      if (this.finalCallback) this.finalCallback.call(null);
    }
    init() {
      if (!prog) prog = initShaderProgram(gl, vertexShaderSource, fragmentShaderSource);
      gl.useProgram(prog);
      this.tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, this.tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.data);

      this.vertexBuff = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuff);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.pixCoords), gl.STATIC_DRAW);

      this.texBuff = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuff);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.texCoords), gl.STATIC_DRAW);

      this.vloc = gl.getAttribLocation(prog, "aVertex");
      this.tloc = gl.getAttribLocation(prog, "aUV");
      this.scaleFactorLoc = gl.getUniformLocation(prog, 'scaleFactor');
      this.sampleBaseLoc = gl.getUniformLocation(prog, 'sampleBase');
      this.layerLoc = gl.getUniformLocation(prog, 'layer');
      this.depthLoc = gl.getUniformLocation(prog, 'depth');
      this.projMatLoc = gl.getUniformLocation(prog, 'uProjectionMatrix');
      this.viewMatLoc = gl.getUniformLocation(prog, 'uModelViewMatrix');
      this.color1Loc = gl.getUniformLocation(prog, 'color1');
      this.color2Loc = gl.getUniformLocation(prog, 'color2');
      this.color3Loc = gl.getUniformLocation(prog, 'color3');
    }
    update() {
      gl.useProgram(prog);
      gl.bindTexture(gl.TEXTURE_2D, this.tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
    }
    calcWidth(str) {
      var w = 0;
      for (let codePoint of str) {
        var cc = codePoint.codePointAt(0);
        var g; for (g=0; g<this.glyphCodes.length; g++) { if (this.glyphCodes[g]==cc) break; }
        w += this.glyphX2[g] - this.glyphX1[g];
      }
      return w;
    }
    findGlyph(val) {
      var n = -1;
      if (typeof val === 'number') n = val;
      if (typeof val === 'string') n = val.codePointAt(0);
      var g; for (g=0; g<this.glyphCodes.length; g++) { if (this.glyphCodes[g]==n) break; }
      if (g < this.glyphCodes.length) return g;
      return -1;
    }
		beginObj() {
			this.objData = [];
			this.objX = 0;
			this.objY = 0;
			var id = this.nextId;
			this.nextId = this.nextId + 1;
			return id;
		}
		textObj(x,y, str, color) {
			function isIterable(input) { if (input === null || input === undefined) { return false } return typeof input[Symbol.iterator] === 'function' }
			this.objX += x;
			this.objY += y;
			if (isIterable(str)) for (let codePoint of str) {
				var cc = codePoint.codePointAt(0);
				var g = this.findGlyph(cc); if (g == -1) { console.log('Missing glyph: decimal',cc); continue; }
				this.objX += -this.glyphX1[g];
				this.objY += -this.glyphHeights[g]+this.glyphY1[g];
				if (g < this.glyphCodes.length && (this.glyphWidths[g] > 1 || this.glyphHeights[g] > 1)) {
					var x0 = this.objX + 0, y0 = this.objY + this.glyphHeights[g];
					var x1 = this.objX + this.glyphWidths[g], y1 = this.objY + 0;
					var u0 = this.glyphSourceX[g] / this.texWidth, v0 = (this.glyphSourceY[g] + this.glyphHeights[g]) / (this.texHeight*2);
					var u1 = (this.glyphSourceX[g] + this.glyphWidths[g]) / this.texWidth, v1 = this.glyphSourceY[g] / (this.texHeight*2);
					this.objData.splice(this.objData.length, 0, x0,y0);
					this.objData.splice(this.objData.length, 0, u0,v0);
					this.objData.splice(this.objData.length, 0, x0,y1);
					this.objData.splice(this.objData.length, 0, u0,v1);
					this.objData.splice(this.objData.length, 0, x1,y1);
					this.objData.splice(this.objData.length, 0, u1,v1);
					this.objData.splice(this.objData.length, 0, x1,y1);
					this.objData.splice(this.objData.length, 0, u1,v1);
					this.objData.splice(this.objData.length, 0, x1,y0);
					this.objData.splice(this.objData.length, 0, u1,v0);
					this.objData.splice(this.objData.length, 0, x0,y0);
					this.objData.splice(this.objData.length, 0, u0,v0);
					//this.objData.splice(this.objData.length, 0, color[0],color[1],color[2]); // color
				}
				this.objX += this.glyphX2[g];
				this.objY += this.glyphHeights[g]-this.glyphY2[g];
			}
		}
		endObj() {
			var data = this.objData;
			delete this.objData;
			delete this.objX;
			delete this.objY;
			return data;
		}
    draw(x,y, str, color, mat0, mat1, fidelity = 0) {
			if (fidelity == 0) fidelity = this.fidelity;
      function from32(c) { return [((c/0x01000000)&0xFF)/255, ((c/0x00010000)&0xFF)/255, ((c/0x00000100)&0xFF)/255, ((c/0x00000001)&0xFF)/255]; }
      gl.useProgram(prog);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.BLEND);
      gl.bindTexture(gl.TEXTURE_2D, this.tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

      gl.enableVertexAttribArray(this.vloc);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuff);
      gl.vertexAttribPointer(this.vloc, 2, gl.FLOAT, false, 0, 0);

      gl.enableVertexAttribArray(this.tloc);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuff);
      gl.vertexAttribPointer(this.tloc, 2, gl.FLOAT, false, 0, 0);

      gl.uniformMatrix4fv(this.projMatLoc, false, mat0);
      mat4.translate(mat1, mat1, [x, y, 0]);
      var sv0; sv0 = vec3.create(); mat4.getScaling(sv0, mat0);
      var sv1; sv1 = vec3.create(); mat4.getScaling(sv1, mat1);
      gl.uniform1f(this.scaleFactorLoc, sv1[0]*sv0[0]*gl.drawingBufferWidth);
      gl.uniform1i(this.sampleBaseLoc, fidelity);
      //var scaleVec; scaleVec = vec3.create(); mat4.getScaling(scaleVec, mat1); gl.uniform1f(this.scaleFactorLoc, scaleVec[0]*2);
			function isIterable(input) { if (input === null || input === undefined) { return false } return typeof input[Symbol.iterator] === 'function' }
if (!isIterable(str)) console.log('Draw warning: string is', str);
//console.log(this.name, str.length, str.length==1?str.charCodeAt(0):'', x,y);
//console.log(this.name,'drawing',str.length,'glyphs');
      if (isIterable(str)) for (let codePoint of str) {
        var cc = codePoint.codePointAt(0);
        {//if (cc >= this.lo && cc <= this.hi) {
					//var g; for (g=0; g<this.glyphCodes.length; g++) { if (this.glyphCodes[g]==cc) break; }
          var g = this.findGlyph(cc); if (g == -1) { console.log('Missing glyph: decimal',cc); continue; }
          mat4.translate(mat1, mat1, [-this.glyphX1[g], -this.glyphHeights[g]+this.glyphY1[g], 0]);
          if (g >= this.glyphCodes.length || (this.glyphWidths[g]==1 && this.glyphHeights[g]==1)) {
            /* console.log('Glyph '+cc+' not found in font "'+this.name+'"'); */
          } else { var plane = 0; //for (var plane = 0; plane < this.planes[g]; plane++) {
            var p = g; //this.planeIndex[g]+plane;
            //var rr = ((this.color[p]/0x01000000)&0xFF), gg = ((this.color[p]/0x00010000)&0xFF), bb = ((this.color[p]/0x00000100)&0xFF), aa = ((this.color[p]/0x00000001)&0xFF);
            var c = color;
            //if (aa == 0xFF) c = [rr/255,gg/255,bb/255,1];

            //if (plane > 0) mat4.translate(mat1, mat1, [.1, .1, 0]);
            gl.uniformMatrix4fv(this.viewMatLoc, false, mat1);
            gl.uniform1i(this.layerLoc, ~~(ff.ZD_DECODE[~~this.glyphSourceZD[g]][0]/2));
            gl.uniform1i(this.depthLoc, ~~(ff.ZD_DECODE[~~this.glyphSourceZD[g]][1]));
            //if (~~(ff.ZD_DECODE[~~this.glyphSourceZD[g]][1]) == 1) {
            //  gl.uniform4fv(this.color1Loc, c);
            //} else {
              var nc = this.glyphHasColors[g] && this.glyphColors[g]? this.glyphColors[g].length : 0;
              if (nc ==0) gl.uniform4fv(this.color1Loc, color);
              if (nc > 0) gl.uniform4fv(this.color1Loc, from32(this.glyphColors[g][0]));
              if (nc > 1) gl.uniform4fv(this.color2Loc, from32(this.glyphColors[g][1]));
              if (nc > 2) gl.uniform4fv(this.color3Loc, from32(this.glyphColors[g][2]));
            //}
            gl.drawArrays(gl.TRIANGLE_FAN, p*4, 4);
          }
          mat4.translate(mat1, mat1, [this.glyphX2[g], this.glyphHeights[g]-this.glyphY2[g], 0]);
        }
      }
    }
    drawBuf(buf, beg, len, color, mat0, mat1, fidelity = 0) {
			if (fidelity == 0) fidelity = this.fidelity;
      gl.useProgram(prog);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.BLEND);
      gl.bindTexture(gl.TEXTURE_2D, this.tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.enableVertexAttribArray(this.vloc);
      gl.vertexAttribPointer(this.vloc, 2, gl.FLOAT, false, 4 * 4, 4 * 0);
      gl.enableVertexAttribArray(this.tloc);
      gl.vertexAttribPointer(this.tloc, 2, gl.FLOAT, false, 4 * 4, 4 * 2);

      gl.uniformMatrix4fv(this.viewMatLoc, false, mat1);
      gl.uniform1i(this.layerLoc, 0);
      gl.uniform1i(this.depthLoc, 0);
      gl.uniform4fv(this.color1Loc, color);
      gl.uniformMatrix4fv(this.projMatLoc, false, mat0);
      var sv0; sv0 = vec3.create(); mat4.getScaling(sv0, mat0);
      var sv1; sv1 = vec3.create(); mat4.getScaling(sv1, mat1);
      gl.uniform1f(this.scaleFactorLoc, sv1[0]*sv0[0]*gl.drawingBufferWidth);
      gl.uniform1i(this.sampleBaseLoc, fidelity);
      gl.drawArrays(gl.TRIANGLES, beg, len);
    }
  }

  return {
    glSet: glSet,
    getProg: getProg,
    GlyphSet: GlyphSet,
    ff: ff,
  };

})();

class PlatformUtil {
  constructor() {
    throw new Error()
  }
  static AudioClick() {
    if (typeof Android !== 'undefined') {
      Android.audioClick()
    } else {
      vp.beep('click')
    }
  }
}
var vp = (function() {

  // set by initialize()
  var canvas, kbalpha, kbnum, kbnext, kbprev, gl;

  // set by start()
  const beg2 = {}, len2 = {};
  var ac, clickSound, beepSound, windSound;
  var buf2;

  // set by canvasResize()
  var diagonal, wi2px, px2wi;
  var layoutSignal; // recalculate all layouts on next frame
  const layoutViews = []; // specific views to recalculate next frame

  var rootViewport, animViews = [];
  const pixelPM = mat4.create();
  var mouseEnabled = 0;

  // for debug purposes
  var plainProgram;
	var debug1 = false; // layout and rendering console messages

  const touchRadius = 85, clickRadius = 5;
  function getPointerRadius() { return (navigator.maxTouchPoints>0 ? touchRadius : clickRadius); }
  function isMouseEnabled() { return mouseEnabled; }
  function getContext() { return gl; }
	const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

	var inputGad, inputGadPrev; function getInputGad() { return inputGad; }

	var progObj;
	var img, tex, vloc, tloc, vertexBuff, texBuff;
	var uLoc;
	function setImage(img) {
		if (!progObj) {
			// create shaders
			var vertexShaderSrc = 
			"attribute vec2 aVertex;" +
			"attribute vec2 aUV;" + 
			"varying vec2 vTex;" +
      "uniform mat4 pm;" +
      "uniform mat4 mm;" +
			"uniform vec2 pos;" +
			"void main(void) {" +
			"  gl_Position = pm * mm * vec4(aVertex + pos, 0.0, 1.0);" +
			"  vTex = aUV;" +
			"}";

			var fragmentShaderSrc =
			"precision highp float;" +
			"varying vec2 vTex;" +
			"uniform sampler2D sampler0;" +
			"void main(void){" +
			"  gl_FragColor = texture2D(sampler0, vTex);"+
			"}";

			var vertShaderObj = gl.createShader(gl.VERTEX_SHADER);
			var fragShaderObj = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(vertShaderObj, vertexShaderSrc);
			gl.shaderSource(fragShaderObj, fragmentShaderSrc);
			gl.compileShader(vertShaderObj);
			gl.compileShader(fragShaderObj);

			progObj = gl.createProgram();
			gl.attachShader(progObj, vertShaderObj);
			gl.attachShader(progObj, fragShaderObj);

			gl.linkProgram(progObj);

			gl.useProgram(progObj);

			vertexBuff = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuff);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 1, 1, 0]), gl.STATIC_DRAW);

			texBuff = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, texBuff);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]), gl.STATIC_DRAW);

			vloc = gl.getAttribLocation(progObj, "aVertex"); 
			tloc = gl.getAttribLocation(progObj, "aUV");
			uLoc = gl.getUniformLocation(progObj, "pos");
		}

		tex = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, tex);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texImage2D(gl.TEXTURE_2D, 0,  gl.RGBA,  gl.RGBA, gl.UNSIGNED_BYTE, img);
		return tex;
	}
	function drawImage(tex, pm, mm) {

//console.log('drawing image');
		gl.useProgram(progObj);

		gl.enableVertexAttribArray(vloc);
		gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuff);
		gl.vertexAttribPointer(vloc, 2, gl.FLOAT, false, 0, 0);

		gl.enableVertexAttribArray(tloc);
		gl.bindBuffer(gl.ARRAY_BUFFER, texBuff);
		gl.bindTexture(gl.TEXTURE_2D, tex);
		gl.vertexAttribPointer(tloc, 2, gl.FLOAT, false, 0, 0);

		gl.uniformMatrix4fv(gl.getUniformLocation(progObj, 'pm'), false, pm);
		gl.uniformMatrix4fv(gl.getUniformLocation(progObj, 'mm'), false, mm);

		gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
	}
class HitList {
  constructor(x,y) {
    this.x = x; this.y = y;
    this.hits = []; // { gad: Gadget, dist: number }
  }
  sortHits() {
    var hits = [];
    while (this.hits.length > 0) {
      var best = 0, d = this.hits[0].dist, i, bz = this.hits[0].gad.z? this.hits[0].gad.z: 0, z;
      for (i = 0; i < this.hits.length && (z = this.hits[i].gad.z? this.hits[i].gad.z: 0, 1); i++)
        if (z > bz || (z == bz && this.hits[i].dist < d)) { best = i; d = this.hits[i].dist; bz = z; }
      hits.push(this.hits[best]); this.hits.splice(best, 1);
    }
    this.hits = hits;
  }
  containsAny(actionFlags) {
    for (var i=0; i<this.hits.length; i++) {
      if ((this.hits[i].gad.actionFlags & actionFlags) != 0) return true;
    }
    return false;
  }
  getActionableGads(actionFlags) {
    var gads = [];
    for (var i=0; i<this.hits.length; i++) {
      if ((this.hits[i].gad.actionFlags & actionFlags) != 0) gads.splice(gads.length, 0, this.hits[i].gad);
    }
    return gads;
  }
  click() {
    for (var i=0; i<this.hits.length; i++) {
      if ((this.hits[i].gad.actionFlags & vp.GAF_CLICKABLE) != 0 && this.hits[i].gad.click)
        this.hits[i].gad.click.call(this.hits[i].gad);
    }
  }
  menu() {
    for (var i=0; i<this.hits.length; i++) {
      if ((this.hits[i].gad.actionFlags & vp.GAF_CONTEXTMENU) != 0 && this.hits[i].gad.menu)
        this.hits[i].gad.menu.call(this.hits[i].gad);
    }
  }
}
class LayoutState {
  constructor(width, height) {
    this.totalWidth = width; this.totalHeight = height;
    this.remainingX = 0; this.remainingY = 0;
    this.remainingWidth = width; this.remainingHeight = height;
  }
	hasArea() {
		return this.remainingWidth > 0 && this.remainingHeight > 0;
	}
	clear() {
    this.remainingX = 0; this.remainingY = 0;
    this.remainingWidth = 0; this.remainingHeight = 0;
	}
}
class View {
  constructor(parent) {
		this.name = "unnamed";
    this.parent = parent;
    this.designFit = undefined; this.designSize = 0; this.designScale = 0; this.designWidth = 0; this.designHeight = 0;
    this.x = 0; this.y = 0; this.w = 0; this.h = 0; this.W = 0; this.H = 0;
		this.sw = 0; this.sh = 0;
    this.userMat = mat4.create(); mat4.identity(this.userMat);
    this.ox = 0; this.oy = 0; // origin
    this.userX = 0; this.userY = 0;
    this.gadgets = [];
    this.mat = mat4.create();
    this.needsRender = true; this.childRender = true;
  }
	queueLayout() {
		if (layoutViews.indexOf(this) === -1) layoutViews.push(this);
	}
  insideFit(w,h) { this.viewScale = (this.w/w < this.h/h)? this.w/w: this.h/h; }
  layoutAll(s) {
		if (debug1 && !continuous) console.log(this.name+'::'+this.layoutAll.name);
    this.x = s.remainingX; this.y = s.remainingY;
    this.w = s.remainingWidth; this.h = s.remainingHeight;
    this.W = s.totalWidth; this.H = s.totalHeight;
    this.viewScale =
      this.designFit?
				(this.h==0?1:this.designFit[0]/this.designFit[1]>this.w/this.h?
				 this.w==0?1:this.w/this.designFit[0]:this.h==0?1:this.h/this.designFit[1]):
      this.designSize? this.w!=0&&this.h!=0?Math.sqrt(this.w*this.h/this.designSize):1:
      this.designScale? this.designScale:// * window.devicePixelRatio:
      this.designWidth? this.w==0?1:this.w/this.designWidth:
      this.designHeight? this.h==0?1:this.h/this.designHeight:
      this.parent? this.parent.viewScale: 1;
if (this.viewScale == 0) {
console.log('ZERO SCALE', this.name);
this.viewScale = 1;
}
		this.sw = this.w/this.viewScale;
		this.sh = this.h/this.viewScale;
    this.rematrix();
    if (this.layoutFunc) { this.layoutFunc.call(this); this.rematrix(); }
    this.setRenderFlag(true);
  }
  rematrix() {
		mat4.copy(this.mat, pixelPM);
    mat4.scale(this.mat, pixelPM, [canvas.width/this.w, canvas.height/this.h, 1]);
    mat4.multiply(this.mat, this.mat, this.userMat);
    mat4.translate(this.mat, this.mat, [this.ox, this.oy, 0]);
    mat4.scale(this.mat, this.mat, [this.viewScale, this.viewScale, 1]);
    mat4.translate(this.mat, this.mat, [-this.userX, -this.userY, 0]);
  }
  getRawMatrix() {
		return pixelPM;
  }
  relayout() {
    if (!this.w && !this.h) return
    var s = new LayoutState();
    s.totalWidth = this.W; s.totalHeight = this.H;
    s.remainingX = this.x; s.remainingY = this.y;
		s.remainingWidth = this.w; s.remainingHeight = this.h;
    this.layoutAll(s);
  }
  getScale() { return this.viewScale; }
  setRenderFlag(value) {
    if (this.needsRender) return;
    this.needsRender = this.needsender || value;
    this.childRender = true;
    if (this.parent) this.parent.setRenderFlag(false);
    if (value && this.a) this.a.setRenderFlag(true);
    if (value && this.b) this.b.setRenderFlag(true);
    if (value && this.c) this.c.setRenderFlag(true);
  }
  renderAll(clearBackground = true) {
    this.childRender = false;
    if (this.needsRender) {
      this.needsRender = false;
			if (this.w > 0 && this.h > 0) {
				if (debug1 && !continuous)
					console.log(this.name+'::'+this.renderAll.name, this.w, this.h);
				this.clip();
		    if (clearBackground) { gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT); }
		    if (this.renderFunc) { this.renderFunc.call(this); }
			}
    }
  }
  clip() {
    gl.viewport(this.x, this.H-this.y-this.h, this.w, this.h);
    gl.scissor(this.x, this.H-this.y-this.h, this.w, this.h);
    gl.enable(gl.SCISSOR_TEST);
  }
  prepMatrix() {
    if (vp.projMat && vp.viewMat) {
      mat4.identity(vp.projMat);
      mat4.translate(vp.projMat, vp.projMat, [-1, 1, 0]);
      mat4.scale(vp.projMat, vp.projMat, [2/this.w, -2/this.h, 1]);
      mat4.identity(vp.viewMat);
      mat4.scale(vp.viewMat, vp.viewMat, [this.getScale(), this.getScale(), 1]);
      mat4.translate(vp.viewMat, vp.viewMat, [-this.panX, -this.panY, 0]);
    }
  }
  getHits(hitList, radius) {
		if (this.w <= 0 || this.h <= 0) return;
    if (hitList.x < this.x-radius || hitList.y < this.y-radius || hitList.x >= this.x+this.w+radius || hitList.y >= this.y+this.h+radius) return;
    for (const g of this.gadgets) if (g) g.getHits(hitList, radius); else console.log("Bad gadget", this);
  }
}
class DividerView extends View {
	constructor(parent, type, ratio, dividerSize) {
		super(parent);
		this.type = type; this.state = ''; this.stateNew = ''; this.stateProg = 0;
		this.size = dividerSize;
		this.ratio = ratio; this.threshold = 1/1;
		this.ratioMin = {h: 0, v: 0}; this.ratioMax = {h: 1, v: 1};
		this.a = undefined; this.b = undefined; this.c = undefined;
		this.prevTime = 0;
	}
	layoutAll(s) {
		super.layoutAll(s);
		var s1 = new LayoutState(s.totalWidth, s.totalHeight);
		var s2 = new LayoutState(s.totalWidth, s.totalHeight);
		var s3 = new LayoutState(s.totalWidth, s.totalHeight);
		if (s.hasArea()) {
			if (this.layoutBeginFunc) this.layoutBeginFunc.call(this);
			var size = ~~(this.size * this.getScale());

			// Horizontal/vertical state init/transitions
			var oldState = this.stateNew;
			if (this.stateNew == '') {
				var wide = (s.remainingWidth / this.threshold > s.remainingHeight)
					? true : false;
				if (this.type == 'a') {
					this.stateNew = wide ? 'v' : 'h';
				} else {
					this.stateNew = this.type;
				}
				this.state = this.stateNew;
			}
			var targetratio = this.ratio;
			if (this.type == 'a') {

				var delta = 0, thisTime = Date.now();
				if (this.prevTime != 0) delta = thisTime - this.prevTime;
				this.prevTime = thisTime;
				if (delta > 17) delta = 17;

				if (s.remainingWidth / this.threshold > s.remainingHeight + 2)
					this.stateNew = 'v';
				if (s.remainingWidth / this.threshold < s.remainingHeight + 2)
					this.stateNew = 'h';
				if (this.stateNew != this.state || this.stateProg > 0) {
					if (this.stateNew != this.state) {
						this.stateProg += 0.008 * delta;
						if (this.stateProg >= 1) {
							this.stateProg = 1;
							this.state = this.stateNew;
							if (this.setPoint && this.stateNew in this.setPoint)
								this.ratio = this.setPoint[this.stateNew];
						}
						if (layoutViews.indexOf(this) === -1) layoutViews.push(this);
					} else {
						this.stateProg -= 0.008 * delta;
						if (this.stateProg < 0) this.stateProg = 0;
						if (this.stateProg > 0) {
							if (layoutViews.indexOf(this) === -1) layoutViews.push(this);
						}
					}
				}
				var stateOther = this.state == 'v'? 'h':'v';
				if (this.setPoint && stateOther in this.setPoint)
					targetratio = this.setPoint[stateOther];
			}

			// View calculations
			if (this.layoutFunc && this.state != oldState) this.layoutFunc.call(this);
			var ratio = clamp(this.ratio, this.ratioMin[this.state], this.ratioMax[this.state]);
			if (ratio != this.ratio) {
				this.ratio = ratio;
				if (layoutViews.indexOf(this) === -1) layoutViews.push(this);
			}
			var f1 = 1 - this.stateProg * (1 - targetratio);
			var f2 = 1 - this.stateProg * (0 + targetratio);
			if (this.state == 'v') {
				var size1 = ~~((s.remainingWidth - size) * this.ratio);
				s1.remainingWidth = size1;
				 s1.remainingHeight = ~~(s.remainingHeight * f1);
					s1.remainingX = s.remainingX; s1.remainingY = s.remainingY;
				s2.remainingWidth = s.remainingWidth - size - size1;
				 s2.remainingHeight = ~~(s.remainingHeight * f2);
					s2.remainingX = s.remainingX + size1 + size;
					 s2.remainingY = s.remainingY + s.remainingHeight - s2.remainingHeight;
				s3.remainingX = s.remainingX + size1; s3.remainingY = s.remainingY;
				 s3.remainingWidth = size; s3.remainingHeight = s.remainingHeight;
			} else if (this.state == 'h') {
				var size1 = ~~((s.remainingHeight - size) * this.ratio);
				s1.remainingWidth = ~~(s.remainingWidth * f1);
				 s1.remainingHeight = size1;
					s1.remainingX = s.remainingX; s1.remainingY = s.remainingY;
				s2.remainingWidth = ~~(s.remainingWidth * f2);
				 s2.remainingHeight = s.remainingHeight - size - size1;
					s2.remainingX = s.remainingX + s.remainingWidth - s2.remainingWidth;
					 s2.remainingY = s.remainingY + size1 + size;
				s3.remainingX = s.remainingX; s3.remainingY = s.remainingY + size1;
				 s3.remainingWidth = s.remainingWidth; s3.remainingHeight = size;
			}
		} else {
			s1.clear();
			s2.clear();
			s3.clear();
		}
		if (this.a) { this.a.layoutAll(s1); }
		if (this.b) { this.b.layoutAll(s2); }
		if (this.c) { this.c.layoutAll(s3); }
		if (this.layoutEndFunc) this.layoutEndFunc.call(this);
		var ratio = clamp(this.ratio, this.ratioMin[this.state], this.ratioMax[this.state]);
		if (ratio != this.ratio) {
			this.ratio = ratio;
			if (layoutViews.indexOf(this) === -1) layoutViews.push(this);
		}
	}
	renderAll() {
		super.renderAll();
		if (this.a && (this.a.needsRender || this.a.childRender)) { this.a.renderAll(); }
		if (this.b && (this.b.needsRender || this.b.childRender)) { this.b.renderAll(); }
		if (this.c && (this.c.needsRender || this.c.childRender)) { this.c.renderAll(); }
	}
	getHits(hitList, radius) {
		if (this.a) { this.a.getHits(hitList, radius); }
		if (this.b) { this.b.getHits(hitList, radius); }
		if (this.c) { this.c.getHits(hitList, radius); }
	}
}
class SliceView extends View {
	constructor(parent, type, size1, size2) {
		super(parent);
		this.type = type; this.state = ''; this.stateNew = ''; this.stateProg = 0;
		this.sizeH = size1; this.sizeV = size2 ? size2 : size1;
		this.prop = false;
		this.threshold = 0.5;
		this.a = undefined; this.b = undefined;
		this.prevTime = 0;
		this.wideState = ''; this.tallState = '';

		// Sanity checks.
		if (!['t','l','r','b','tl','tr','bl','br'].includes(this.type))
			console.error("Warning: Invalid 'type' for SliceView.");
	}
	layoutAll(s) {
		super.layoutAll(s);
		var s1 = new LayoutState(s.totalWidth, s.totalHeight);
		var s2 = new LayoutState(s.totalWidth, s.totalHeight);
		if (s.hasArea()) {
			var sizeH = ~~(this.sizeH * (this.prop? this.w : this.getScale()));
			var sizeV = ~~(this.sizeV * (this.prop? this.h : this.getScale()));

			// Horizontal/vertical state init/transitions
			var oldState = this.stateNew;
			if (this.stateNew == '') {
				var wide = (s.remainingWidth * this.threshold
									> s.remainingHeight * (1 - this.threshold))
					? true : false;
				if (this.type == 'tl') {
					this.wideState = 'l'; this.tallState = 't';
					this.stateNew = wide ? this.wideState : this.tallState;
				} else if (this.type == 'tr') {
					this.wideState = 'r'; this.tallState = 't';
					this.stateNew = wide ? this.wideState : this.tallState;
				} else if (this.type == 'bl') {
					this.wideState = 'l'; this.tallState = 'b';
					this.stateNew = wide ? this.wideState : this.tallState;
				} else if (this.type == 'br') {
					this.wideState = 'r'; this.tallState = 't';
					this.stateNew = wide ? this.wideState : this.tallState;
				} else {
					this.stateNew = this.type;
				}
				this.state = this.stateNew;
			}
			if (this.type.length > 1) {

				var delta = 0, thisTime = Date.now();
				if (this.prevTime != 0) delta = thisTime - this.prevTime;
				this.prevTime = thisTime;
				if (delta > 17) delta = 17;

				if (s.remainingWidth * this.threshold > s.remainingHeight * (1 - this.threshold) + 2)
					this.stateNew = this.wideState;
				if (s.remainingHeight * this.threshold > s.remainingWidth * (1 - this.threshold) + 2)
					this.stateNew = this.tallState;
				if (this.stateNew != this.state || this.stateProg > 0) {
					if (this.stateNew != this.state) {
						this.stateProg += 0.008 * delta;
						if (this.stateProg >= 1) {
							this.stateProg = 1;
							this.state = this.stateNew;
						}
						if (layoutViews.indexOf(this) === -1) layoutViews.push(this);
					} else {
						this.stateProg -= 0.008 * delta;
						if (this.stateProg < 0) this.stateProg = 0;
						if (this.stateProg > 0) {
							if (layoutViews.indexOf(this) === -1) layoutViews.push(this);
						}
					}
				}
			}

			// View calculations
			if (this.layoutFunc && this.state != oldState && this.w > 0 && this.h > 0)
				this.layoutFunc.call(this);
			var ratio = (this.state == 't' || this.state == 'b')
								? sizeV / s.remainingWidth
								: sizeH / s.remainingHeight;
			var f1 = 1 - this.stateProg * (1 - ratio);
			var f2 = 1 - this.stateProg * (0 + ratio);
			if (this.state == 'l') {
				s1.remainingWidth = sizeV;
				s1.remainingHeight = ~~(s.remainingHeight * f1);
				s1.remainingX = s.remainingX;
				s2.remainingWidth = s.remainingWidth - sizeV;
				s2.remainingHeight = ~~(s.remainingHeight * f2);
				s2.remainingX = s.remainingX + sizeV;
				if (this.tallState == 't') {
					s1.remainingY = s.remainingY;
					s2.remainingY = s.remainingY + s.remainingHeight - s2.remainingHeight;
				} else {
					s1.remainingY = s.remainingY + s.remainingHeight - s1.remainingHeight;
					s2.remainingY = s.remainingY;
				}
			} else if (this.state == 'r') {
				s1.remainingWidth = sizeV;
				s1.remainingHeight = ~~(s.remainingHeight * f1);
				s1.remainingX = s.remainingX + s.remainingWidth - sizeV;
				s2.remainingWidth = s.remainingWidth - sizeV;
				s2.remainingHeight = ~~(s.remainingHeight * f2);
				s2.remainingX = s.remainingX;
				if (this.tallState == 't') {
					s1.remainingY = s.remainingY;
					s2.remainingY = s.remainingY + s.remainingHeight - s2.remainingHeight;
				} else {
					s1.remainingY = s.remainingY + s.remainingHeight - s1.remainingHeight;
					s2.remainingY = s.remainingY;
				}
			} else if (this.state == 't') {
				s1.remainingWidth = ~~(s.remainingWidth * f1);
				s1.remainingHeight = sizeH;
				s1.remainingY = s.remainingY;
				s2.remainingWidth = ~~(s.remainingWidth * f2);
				s2.remainingHeight = s.remainingHeight - sizeH;
				s2.remainingY = s.remainingY + sizeH;
				if (this.wideState == 'l') {
					s1.remainingX = s.remainingX;
					s2.remainingX = s.remainingX + s.remainingWidth - s2.remainingWidth;
				} else {
					s1.remainingX = s.remainingX + s.remainingWidth - s1.remainingWidth;
					s2.remainingX = s.remainingX;
				}
			} else if (this.state == 'b') {
				s1.remainingWidth = ~~(s.remainingWidth * f1);
				s1.remainingHeight = sizeH;
				s1.remainingY = s.remainingY + s.remainingHeight - sizeH;
				s2.remainingWidth = ~~(s.remainingWidth * f2);
				s2.remainingHeight = s.remainingHeight - sizeH;
				s2.remainingY = s.remainingY;
				if (this.wideState == 'l') {
					s1.remainingX = s.remainingX;
					s2.remainingX = s.remainingX + s.remainingWidth - s2.remainingWidth;
				} else {
					s1.remainingX = s.remainingX + s.remainingWidth - s1.remainingWidth;
					s2.remainingX = s.remainingX;
				}
		  }
		} else {
			s1.clear();
			s2.clear();
		}
		if (this.a) { this.a.layoutAll(s1); }
		if (this.b) { this.b.layoutAll(s2); }
	}
	renderAll() {
		super.renderAll();
		if (this.a && (this.a.needsRender || this.a.childRender)) { this.a.renderAll(); }
		if (this.b && (this.b.needsRender || this.b.childRender)) { this.b.renderAll(); }
	}
	getHits(hitList, radius) {
		if (this.a) { this.a.getHits(hitList, radius); }
		if (this.b) { this.b.getHits(hitList, radius); }
  }
/*
      findGad(s, r) {
        if (this.a) this.a.findGad(s, r);
        if (this.b) this.b.findGad(s, r);
      }
      findViewport(p) {
        return (this.a && this.a.findViewport(p)) || (this.b && this.b.findViewport(p));
      }
*/
}
class PagesView extends View {
	constructor(parent, type) {
		super(parent);
		this.type = type; this.index = 0; this.indexNew = 0; this.indexProg = 0;
		this.a = undefined; this.b = undefined;
		this.pages = [];
		this.snaps = [];
		this.prevTime = 0;
		this.keepPageFlag = false;

		this.gadgets.push(this.swipeGad = new vp.SwipeGadget(this));
		switch (this.type) {
		case 'h':
			this.swipeGad.actionFlags =
				vp.GAF_SWIPEABLE_LEFTRIGHT |
				vp.GAF_SCROLLABLE_LEFTRIGHT;
			break;
		case 'v':
			this.swipeGad.actionFlags =
				vp.GAF_SWIPEABLE_UPDOWN |
				vp.GAF_SCROLLABLE_UPDOWN;
			break;
		default: this.swipeGad.actionFlags = 0;
		}
		this.layoutFunc = function() {
			var v = this;
			if (v.pages.length == 0) return;
			v.minX = 0; v.maxX = v.sw * v.pages.length;
			v.minY = 0; v.maxY = v.sh * v.pages.length;
			v.swipeGad.layout.call(v.swipeGad);
		}
		this.layoutPageFunc = function() {
			var v = this;
			v.sw = v.parent.sw;
			v.sh = v.parent.sh;
			if (v.layoutFunc_) v.layoutFunc_();
		}
		this.toPage = function(pageIndex) {
			var v = this, g = v.swipeGad;
			var index = clamp(pageIndex, 0, v.pages.length);
			if (index > this.index) {
				g.doSwipe(true, index);
			} else if (index < this.index) {
				g.doSwipe(false, index);
			}
		}
	}
	keepPage() {
		this.keepPageFlag = true;
	}
	getPageIndex(page) {
		for (var i=0; i<this.pages.length; i++) if (this.pages[i] === page) return i;
		return -1;
	}
	getPageOffset(index) {
		if (this.type == 'h') {
			return this.userX - index*this.sw;
		} else {
			return this.userY - index*this.sh;
		}
	}
	layoutAll(s) {
		super.layoutAll(s);
		if (this.pages.length == 0) return;
		var s1 = new LayoutState(s.totalWidth, s.totalHeight);
		var s2 = new LayoutState(s.totalWidth, s.totalHeight);
		if (s.hasArea()) {
			var delta = 0, thisTime = Date.now();
			if (this.prevTime != 0) delta = thisTime - this.prevTime;
			this.prevTime = thisTime;
			if (delta > 17) delta = 17;

			var h = (this.type == 'h');
			var v = (this.type == 'v');

			this.snaps = [];
			for (var i = 0; i < this.pages.length; i++) {
				this.snaps.push([
					this.sw * i * (h?1:0),
					this.sh * i * (v?1:0)]);
			}

			if (this.viewScale != this.prevScale || this.keepPageFlag) {
				this.userX = this.index*this.sw;
				this.prevScale = this.viewScale;
				this.keepPageFlag = false;
			}

			// Get the index of the page that should be mostly visible.
//if (this.name === 'checkoutpages') console.log(this.index, this.userX);
			var oldIndex = this.index, pageChangeFlag = false;
			if (h) this.index = clamp(Math.round(this.userX / this.sw), 0, this.pages.length-1);
			if (v) this.index = clamp(Math.round(this.userY / this.sh), 0, this.pages.length-1);
			if (this.index != oldIndex && this.pageChangeFunc) {
				pageChangeFlag = true;
				this.pageChangeFunc.call(this);
			}

			// Determine which pages are visible and what their offsets are.
			var curPage = this.pages[this.index];
//if (this.name === 'checkoutpages') console.log(this.index, this.pages);
			var curX = this.userX + (h?-this.index*this.sw:0);
			var curY = this.userY + (v?-this.index*this.sh:0);
			var otherPage = undefined, otherX, otherY;
			if (h && this.index * this.sw > this.userX
			||  v && this.index * this.sh > this.userY) {
				if (h) curPage.userX = 0;
				if (v) curPage.userY = 0;
				var otherI = this.index - 1;
				if (otherI >= 0 && otherI < this.pages.length) {
					otherPage = this.pages[otherI];
					otherX = this.userX + (h?-this.index*this.sw+this.sw:0);
					otherY = this.userY + (v?-this.index*this.sh+this.sh:0);
					if (h) otherPage.userX = h?otherX*this.viewScale/otherPage.viewScale:0;
					if (v) otherPage.userY = v?otherY*this.viewScale/otherPage.viewScale:0;
				}
			} else if (h && this.index * this.sw < this.userX
							|| v && this.index * this.sh < this.userY) {
				if (h) curPage.userX = h?curX*this.viewScale/curPage.viewScale:0;
				if (v) curPage.userY = v?curY*this.viewScale/curPage.viewScale:0;
				var otherI = this.index + 1;
				if (otherI >= 0 && otherI < this.pages.length) {
					otherPage = this.pages[otherI];
					otherX = this.userX + (h?-this.index*this.sw-this.sw:0);
					otherY = this.userY + (v?-this.index*this.sh-this.sh:0);
					if (h) otherPage.userX = 0;
					if (v) otherPage.userY = 0;
				}
			} else {
				if (h) curPage.userX = 0;
				if (v) curPage.userY = 0;
			}
			this.a = curPage; curPage.parent = this;
			this.b = otherPage; if (otherPage) otherPage.parent = this;

			// These interceptions keeps the sw and sh values whole.
			if (this.a && this.a.layoutFunc !== this.layoutPageFunc) {
				if (this.a.layoutFunc) this.a.layoutFunc_ = this.a.layoutFunc;
				this.a.layoutFunc = this.layoutPageFunc;
			}
			if (this.b && this.b.layoutFunc !== this.layoutPageFunc) {
				if (this.b.layoutFunc) this.b.layoutFunc_ = this.b.layoutFunc;
				this.b.layoutFunc = this.layoutPageFunc;
			}

			if (pageChangeFlag) {
				if (curPage.pageFocusFunc) {
					curPage.pageFocusFunc();
				}
			}

			// View calculations
			curX = Math.round(curX * this.viewScale);
			curY = Math.round(curY * this.viewScale);
			s1.remainingWidth = clamp(s.remainingWidth - Math.abs(curX),
				0, s.remainingWidth);
			s1.remainingHeight = clamp(s.remainingHeight - Math.abs(curY),
				0, s.remainingHeight);
			s1.remainingX = clamp(s.remainingX - (curX < 0 ? curX : 0),
				s.remainingX, s.remainingX + s.remainingWidth);
			s1.remainingY = clamp(s.remainingY - (curY < 0 ? curY : 0),
				s.remainingY, s.remainingY + s.remainingHeight);
			if (otherPage) {
/*
				otherX *= this.viewScale;
				otherY *= this.viewScale;
				s2.remainingWidth = clamp(s.remainingWidth - Math.abs(otherX),
					0, s.remainingWidth);
				s2.remainingHeight = clamp(s.remainingHeight - Math.abs(otherY),
					0, s.remainingHeight);
				s2.remainingX = clamp(s.remainingX - (otherX < 0 ? otherX : 0),
					s.remainingX, s.remainingX + s.remainingWidth);
				s2.remainingY = clamp(s.remainingY - (otherY < 0 ? otherY : 0),
					s.remainingY, s.remainingY + s.remainingHeight);
*/
				if (h) {
					s2.remainingWidth = s.remainingWidth - s1.remainingWidth;
					s2.remainingHeight = s.remainingHeight;
					s2.remainingX = s.remainingX;
					s2.remainingY = s.remainingY;
					if (s1.remainingX == s.remainingX)
						s2.remainingX += s1.remainingWidth;
				} else if (v) {
					s2.remainingWidth = s.remainingWidth;
					s2.remainingHeight = s.remainingHeight - s1.remainingHeight;
					s2.remainingX = s.remainingX;
					s2.remainingY = s.remainingY;
					if (s1.remainingY == s.remainingY)
						s2.remainingY += s1.remainingHeight;
				}
			} else {
				s2.clear();
			}
		} else {
			s1.clear();
			s2.clear();
		}
		if (this.a) { this.a.layoutAll(s1); }
		if (this.b) { this.b.layoutAll(s2); }
	}
	renderAll() {
		super.renderAll();
		if (this.a && (this.a.needsRender || this.a.childRender)) { this.a.renderAll(); }
		if (this.b && (this.b.needsRender || this.b.childRender)) { this.b.renderAll(); }
	}
	getHits(hitList, radius) {
		super.getHits(hitList, radius);
		if (this.a) { this.a.getHits(hitList, radius); }
		if (this.b) { this.b.getHits(hitList, radius); }
  }
}
class PopupView extends View {
	constructor(parent, type, size1, size2) {
		super(parent);
		this.type = type; this.state = ''; this.stateNew = ''; this.stateProg = 0;
		this.sizeH = size1; this.sizeV = size2 ? size2 : size1;
		this.prop = false;
		this.threshold = 0.5;
		this.a = undefined; this.b = undefined;
		this.prevTime = 0;
		this.wideState = ''; this.tallState = '';
	}
	layoutAll(s) {
		super.layoutAll(s);
		var s1 = new LayoutState(s.totalWidth, s.totalHeight);
		var s2 = new LayoutState(s.totalWidth, s.totalHeight);
		if (s.hasArea()) {
			var sizeH = ~~(this.sizeH * (this.prop? this.w : this.getScale()));
			var sizeV = ~~(this.sizeV * (this.prop? this.h : this.getScale()));

			// Horizontal/vertical state init/transitions
			var oldState = this.stateNew;
			if (this.stateNew == '') {
				var wide = (s.remainingWidth * this.threshold
									> s.remainingHeight * (1 - this.threshold))
					? true : false;
				if (this.type == 'tl') {
					this.wideState = 'l'; this.tallState = 't';
					this.stateNew = wide ? this.wideState : this.tallState;
				} else if (this.type == 'tr') {
					this.wideState = 'r'; this.tallState = 't';
					this.stateNew = wide ? this.wideState : this.tallState;
				} else if (this.type == 'bl') {
					this.wideState = 'l'; this.tallState = 'b';
					this.stateNew = wide ? this.wideState : this.tallState;
				} else if (this.type == 'br') {
					this.wideState = 'r'; this.tallState = 't';
					this.stateNew = wide ? this.wideState : this.tallState;
				} else {
					this.stateNew = this.type;
				}
				this.state = this.stateNew;
			}
			if (this.type.length > 1) {

				var delta = 0, thisTime = Date.now();
				if (this.prevTime != 0) delta = thisTime - this.prevTime;
				this.prevTime = thisTime;
				if (delta > 17) delta = 17;

				if (s.remainingWidth * this.threshold > s.remainingHeight * (1 - this.threshold) + 2)
					this.stateNew = this.wideState;
				if (s.remainingHeight * this.threshold > s.remainingWidth * (1 - this.threshold) + 2)
					this.stateNew = this.tallState;
				if (this.stateNew != this.state || this.stateProg > 0) {
					if (this.stateNew != this.state) {
						this.stateProg += 0.008 * delta;
						if (this.stateProg >= 1) {
							this.stateProg = 1;
							this.state = this.stateNew;
						}
						if (layoutViews.indexOf(this) === -1) layoutViews.push(this);
					} else {
						this.stateProg -= 0.008 * delta;
						if (this.stateProg < 0) this.stateProg = 0;
						if (this.stateProg > 0) {
							if (layoutViews.indexOf(this) === -1) layoutViews.push(this);
						}
					}
				}
			}

			// View calculations
			if (this.layoutFunc && this.state != oldState && this.w > 0 && this.h > 0)
				this.layoutFunc.call(this);
			var ratio = (this.state == 't' || this.state == 'b')
								? sizeV / s.remainingWidth
								: sizeH / s.remainingHeight;
			var f1 = 1 - this.stateProg * (1 - ratio);
			var f2 = 1 - this.stateProg * (0 + ratio);
			if (this.state == 'l') {
				s1.remainingWidth = sizeV;
				s1.remainingHeight = ~~(s.remainingHeight * f1);
				s1.remainingX = s.remainingX;
				s2.remainingWidth = s.remainingWidth - sizeV;
				s2.remainingHeight = ~~(s.remainingHeight * f2);
				s2.remainingX = s.remainingX + sizeV;
				if (this.tallState == 't') {
					s1.remainingY = s.remainingY;
					s2.remainingY = s.remainingY + s.remainingHeight - s2.remainingHeight;
				} else {
					s1.remainingY = s.remainingY + s.remainingHeight - s1.remainingHeight;
					s2.remainingY = s.remainingY;
				}
			} else if (this.state == 'r') {
				s1.remainingWidth = sizeV;
				s1.remainingHeight = ~~(s.remainingHeight * f1);
				s1.remainingX = s.remainingX + s.remainingWidth - sizeV;
				s2.remainingWidth = s.remainingWidth - sizeV;
				s2.remainingHeight = ~~(s.remainingHeight * f2);
				s2.remainingX = s.remainingX;
				if (this.tallState == 't') {
					s1.remainingY = s.remainingY;
					s2.remainingY = s.remainingY + s.remainingHeight - s2.remainingHeight;
				} else {
					s1.remainingY = s.remainingY + s.remainingHeight - s1.remainingHeight;
					s2.remainingY = s.remainingY;
				}
			} else if (this.state == 't') {
				s1.remainingWidth = ~~(s.remainingWidth * f1);
				s1.remainingHeight = sizeH;
				s1.remainingY = s.remainingY;
				s2.remainingWidth = ~~(s.remainingWidth * f2);
				s2.remainingHeight = s.remainingHeight - sizeH;
				s2.remainingY = s.remainingY + sizeH;
				if (this.wideState == 'l') {
					s1.remainingX = s.remainingX;
					s2.remainingX = s.remainingX + s.remainingWidth - s2.remainingWidth;
				} else {
					s1.remainingX = s.remainingX + s.remainingWidth - s1.remainingWidth;
					s2.remainingX = s.remainingX;
				}
			} else if (this.state == 'b') {
				s1.remainingWidth = ~~(s.remainingWidth * f1);
				s1.remainingHeight = sizeH;
				s1.remainingY = s.remainingY + s.remainingHeight - sizeH;
				s2.remainingWidth = ~~(s.remainingWidth * f2);
				s2.remainingHeight = s.remainingHeight - sizeH;
				s2.remainingY = s.remainingY;
				if (this.wideState == 'l') {
					s1.remainingX = s.remainingX;
					s2.remainingX = s.remainingX + s.remainingWidth - s2.remainingWidth;
				} else {
					s1.remainingX = s.remainingX + s.remainingWidth - s1.remainingWidth;
					s2.remainingX = s.remainingX;
				}
		  }
		} else {
			s1.clear();
			s2.clear();
		}
		if (this.a) { this.a.layoutAll(s1); }
		if (this.b) { this.b.layoutAll(s2); }
	}
	renderAll() {
		super.renderAll();
		if (this.a && (this.a.needsRender || this.a.childRender)) { this.a.renderAll(); }
		if (this.b && (this.b.needsRender || this.b.childRender)) { this.b.renderAll(); }
	}
	getHits(hitList, radius) {
		if (this.a) { this.a.getHits(hitList, radius); }
		if (this.b) { this.b.getHits(hitList, radius); }
  }
/*
      findGad(s, r) {
        if (this.a) this.a.findGad(s, r);
        if (this.b) this.b.findGad(s, r);
      }
      findViewport(p) {
        return (this.a && this.a.findViewport(p)) || (this.b && this.b.findViewport(p));
      }
*/
}
class ViewOverlay extends View {
  constructor(parent) {
    super(parent);
    this.a = undefined; this.b = undefined;
  }
  layoutAll(s) {
    super.layoutAll(s);
    if (this.layoutFunc) this.layoutFunc.call(this);
    var s1 = new LayoutState(s.totalWidth, s.totalHeight);
    var s2 = new LayoutState(s.totalWidth, s.totalHeight);
    s1.remainingX = s.remainingX; s1.remainingY = s.remainingY;
    s1.remainingWidth = s.remainingWidth; s1.remainingHeight = s.remainingHeight;
    s2.remainingX = s.remainingX; s2.remainingY = s.remainingY;
    s2.remainingWidth = s.remainingWidth; s2.remainingHeight = s.remainingHeight;
    if (this.a) { this.a.layoutAll(s1); }
    if (this.b) { this.b.layoutAll(s2); }
  }
  setRenderFlag(value) {
    super.setRenderFlag(true);
  }
  renderAll() {
    super.renderAll();
    if ((this.a && (this.a.needsRender || this.a.childRender)) || (this.b && (this.b.needsRender || this.b.childRender))) {
      this.b.renderAll(); this.a.renderAll(false);
    }
  }
  getHits(hitList, radius) {
    if (this.a) { this.a.getHits(hitList, radius); }
    if (this.b) { this.b.getHits(hitList, radius); }
  }
}
    class ViewMultiverse extends View {
      constructor(parent) {
        super(parent);
/*
        var g = this.gadgets = new Gadget(this);
        g.w = 10; g.h = 1000; //g.f = GF_RELH;
       // g.convexHull = g.computeHull([0,0, 0,1000, 10,1000, 10,0]);
        g.click = function() {
//console.log('click', this);
        }
        this.layoutFunc = function() {
          g.convexHull = g.computeHull([0,0, 0,this.h, 0,this.h, 0,0]);
        }
*/
        var g; this.gadgets.push(g = new Gadget(this));
        g.w = 10; g.h = 1000; //g.f = GF_RELH;
        g.convexHull = g.computeHull([50,50, 100,200, 200,200, 200,100]);
        g.click = function() {
//console.log('click', this);
        }

      }
     // layoutFunc() {
     // }
    }
class ViewPicker extends View {
  constructor(parent) {
    super(parent);
    var g; this.gadgets.push(g = new Gadget(this));
    g.w = 1000; g.h = 1000;
    g.convexHull = g.computeHull([0,0, 0,1000, 1000,1000, 1000,0]);
    g.click = function() {
//console.log('click', this);
    }
  }
}
    // Gadget Flags
    const GF_RELX = 1; // left edge of gadget is relative to right edge of viewport
    const GF_RELY = 2; // top edge of gadget is relative to bottom edge of viewport
    const GF_RELW = 4; // width is relative to viewport width
    const GF_RELH = 8; // height is relative to viewport height

    // Gadget Action Flags
    var GAF_CLICKABLE = 1; // whether this gadget can be clicked or tapped
    var GAF_HOLDABLE = 2; // whether it can be held down (invalid with GAF_CONTEXT_MENU)
    var GAF_CONTEXTMENU = 4; // whether this gadget can show a context menu
    var GAF_STRETCHABLE = 8; // whether this gadget can be stretched
    var GAF_DRAGGABLE_UPDOWN = 16; // whether this gadget can be dragged up or down
    var GAF_DRAGGABLE_LEFTRIGHT = 32; // whether this gadget can be dragged left or right
    var GAF_SWIPEABLE_UPDOWN = 64;
    var GAF_SWIPEABLE_LEFTRIGHT = 128;
    var GAF_SCROLLABLE_UPDOWN = 256;
    var GAF_SCROLLABLE_LEFTRIGHT = 512;
    var GAF_SCALABLE = 1024;
    var GAF_ROTATABLE = 2048;
    var GAF_DRAGGABLE = GAF_DRAGGABLE_UPDOWN | GAF_DRAGGABLE_LEFTRIGHT;
    var GAF_SWIPEABLE = GAF_SWIPEABLE_UPDOWN | GAF_SWIPEABLE_LEFTRIGHT;
    var GAF_SCROLLABLE = GAF_SCROLLABLE_UPDOWN | GAF_SCROLLABLE_LEFTRIGHT;
    var GAF_PINCHABLE = GAF_SCALABLE | GAF_ROTATABLE;
    var GAF_ALL = GAF_CLICKABLE | GAF_CONTEXTMENU | GAF_STRETCHABLE | GAF_DRAGGABLE | GAF_SCROLLABLE | GAF_PINCHABLE;
    var GAF_NUMINPUT = 4096;
    var GAF_TEXTINPUT = 8192;
    var GAF_GONEXT = 16384;
    class Gadget {
      constructor(viewport) {
        this.viewport = viewport;
        this.mat = mat4.create(); mat4.identity(this.mat);
        this.x = 0; this.y = 0; this.w = 0; this.h = 0; this.H = 0;
        this.convexHull = []; this.extendedHulls = {}; this.boundingBoxes = {};
        this.xo = 0; this.yo = 0;
        this.enabled = true;
        this.selected = false;
        this.actionFlags = 0;
      }
      getHits(hitList, radius) {
        if (!this.enabled || this.convexHull.length == 0) return;
        var v = this.viewport, matS = vec3.create(); mat4.getScaling(matS, v.userMat);
        var r = radius/v.getScale()/matS[0], key = ''+r;
        if (!(key in this.extendedHulls)) { this.computeExtendedHull(r); this.computeBoundingBox(r); }
        var h = this.extendedHulls[key], bb = this.boundingBoxes[key];

        // bounding box check
        var ss = 1/v.getScale();
        var rxy = vec3.create();
        rxy[0] = (hitList.x - v.x - this.x / ss);
        rxy[1] = (hitList.y - v.y - this.y / ss);
        var inv = mat4.create(); mat4.invert(inv, v.userMat);
        vec3.transformMat4(rxy, rxy, inv);
        //var rx = rxy[0] * ss, ry = rxy[1] * ss;
        var rx = (hitList.x - v.x - v.ox) * ss + v.userX - this.x - this.xo, ry = (hitList.y - v.y - v.oy) * ss + v.userY - this.y - this.yo;
        if (rx < bb.x1 || rx >= bb.x2 || ry < bb.y1 || ry >= bb.y2) return;

        // extended hull check
        function orient(ax,ay, bx,by, px,py) { return (bx-ax)*(py-ay) - (by-ay)*(px-ax); }
        var n = h.length;
        var flag = true;
        for (var i=0; i<n; i+=2) {
          var o = orient(h[i+0],h[i+1], h[(i+2)%n],h[(i+3)%n], rx,ry);
          if (o<0) flag = false;
        }
        if (!flag) return;

        // convex hull check
        var n = this.convexHull.length;
        var flag = true;
        for (var i=0; i<n; i+=2) {
          var o = orient(this.convexHull[i+0],this.convexHull[i+1], this.convexHull[(i+2)%n],this.convexHull[(i+3)%n], rx,ry);
          if (o<0) flag = false;
        }
        var d = 0; if (!flag) d = this.distToHull(rx, ry);
        hitList.hits.push({ gad: this, dist: d });
      }
			autoHull() {
				var g = this;
				g.convexHull = g.computeHull([0,0, g.w,0, g.w,g.h, 0,g.h]);
				g.extendedHulls = {}; g.boundingBoxes = {};
			}
      computeHull(points) {
        var S = [...points];
        var T = [];
        var a = 0, b = 0, ax = S[0], bx = S[0];
        for (var i = 0; i < ~~(S.length / 2); i++) {
          if (S[i*2] < ax) { ax = S[i*2]; a = i; }
          if (S[i*2] > bx) { bx = S[i*2]; b = i; }
        }
        T[T.length] = S[a*2+0]; T[T.length] = S[a*2+1];
        T[T.length] = S[b*2+0]; T[T.length] = S[b*2+1];
        S.splice(a*2, 2); if (b < a) S.splice(b*2, 2); else S.splice(b*2-2, 2);
        var S1 = [], S2 = [];
        function orient(ax,ay, bx,by, px,py) { return (bx-ax)*(py-ay) - (by-ay)*(px-ax); }
        for (var i = 0; i < ~~(S.length / 2); i++) {
          if (orient(points[a*2+0],points[a*2+1], points[b*2+0],points[b*2+1], S[i*2+0],S[i*2+1]) < 0) {
            S1[S1.length] = S[i*2+0]; S1[S1.length] = S[i*2+1]; } else { S2[S2.length] = S[i*2+0]; S2[S2.length] = S[i*2+1];
          }
        }
        function sqr(x) { return x * x }
        function dist2(vx,vy, wx,wy) { return sqr(vx - wx) + sqr(vy - wy) }
        function distToSegmentSquared(px,py, vx,vy, wx,wy) {
          var l2 = dist2(vx,vy, wx,wy);
          if (l2 == 0) return dist2(px,py, vx,vy);
          var t = ((px - vx) * (wx - vx) + (py - vy) * (wy - vy)) / l2;
          t = Math.max(0, Math.min(1, t));
          return dist2(px,py, vx + t * (wx - vx), vy + t * (wy - vy));
        }
        function distToSegment(px,py, vx,vy, wx,wy, ddd) { return Math.sqrt(distToSegmentSquared(px,py, vx,vy, wx,wy)); }
        function recurse(T, Sk, Px,Py, Qx,Qy) {
          if (Sk.length < 2) return;
          var p = 0, pd = 0;
          for (var i = 0; i < ~~(Sk.length/2); i++) {
            var d = distToSegment(Sk[i*2+0],Sk[i*2+1], Px,Py, Qx,Qy);
            if (d > pd) { pd = d; p = i; }
          }
          var Cx = Sk[p*2+0], Cy = Sk[p*2+1];
          Sk.splice(p*2, 2);
          for (i = 0; i < ~~(T.length/2); i++) {
            if ((T[i*2+0] == Px && T[i*2+1] == Py && T[(i*2+2)%T.length] == Qx && T[(i*2+3)%T.length] == Qy)
            ||  (T[i*2+0] == Qx && T[i*2+1] == Qy && T[(i*2+2)%T.length] == Px && T[(i*2+3)%T.length] == Py)) {
              T.splice(i*2+2, 0, Cx,Cy); break;
            }
          }
          var S1 = [], S2 = [];
          for (var i = 0; i < ~~(Sk.length / 2); i++) {
            if (orient(Px,Py, Cx,Cy, Sk[i*2+0],Sk[i*2+1]) < 0) {
              S1[S1.length] = Sk[i*2+0]; S1[S1.length] = Sk[i*2+1];
            } // else { S2[S2.length] = Sk[i*2+0]; S2[S2.length] = Sk[i*2+1]; }
            if (orient(Cx,Cy, Qx,Qy, Sk[i*2+0],Sk[i*2+1]) < 0) {
              S2[S2.length] = Sk[i*2+0]; S2[S2.length] = Sk[i*2+1];
            } // else { S2[S2.length] = Sk[i*2+0]; S2[S2.length] = Sk[i*2+1]; }
          }
          recurse(T, S1, Px,Py, Cx,Cy);
          recurse(T, S2, Cx,Cy, Qx,Qy);
        }
        recurse(T, S1, points[a*2+0],points[a*2+1], points[b*2+0],points[b*2+1]);
        recurse(T, S2, points[b*2+0],points[b*2+1], points[a*2+0],points[a*2+1]);
        var flag = 1;
        while(flag) {
          flag = 0;
          for (var i = 0; i < ~~(T.length/2); i++) {
            if (distToSegment(T[(i*2+2)%T.length],T[(i*2+3)%T.length], T[i*2+0],T[i*2+1], T[(i*2+4)%T.length],T[(i*2+5)%T.length]) < 0.01) {
              T.splice(i*2+2, 2); flag = 1; break;
            }
          }
        }
        var newPoints = this.sortHull(T);
        return newPoints;
      }
      sortHull(points) {
        var r = [];
        var cx = 0,cy = 0, l = points.length; for (var i = 0; i < l; i+=2) { cx += points[i+0]; cy += points[i+1]; } cx /= l/2; cy /= l/2;
        var ax = cx+102, ay = cy + 1;
        function angle(i) {
          var bx = points[i+0], by = points[i+1];
          var a = Math.atan2(by - cy, bx - cx) - Math.atan2(ay - cy, ax - cx);
          while (a >  Math.PI) a -= 2*Math.PI;
          while (a < -Math.PI) a += 2*Math.PI;
          return a;
        }
        while (points.length > 0) {
          var best = 0, a = angle(0);
          for (var i = 0; i < points.length; i+=2) {
            if (angle(i) < a) { best = i; a = angle(i); }
          }
          r.push(points[best+0]); r.push(points[best+1]); points.splice(best, 2);
        }
        return r;
      }
      computeExtendedHull(radius) {
        var hull = [];
        var j=0, n=this.convexHull.length;
        for (var i=0; i<n; i+=2) {
          var ex = (this.convexHull[(i+3)%n]-this.convexHull[i+1]); // perpendicular extension vector
          var ey =-(this.convexHull[(i+2)%n]-this.convexHull[i+0]);
          var s = radius / Math.sqrt(ex*ex + ey*ey); // amount of side extension
          hull[j+0] = this.convexHull[i+0] + ex*s;
          hull[j+1] = this.convexHull[i+1] + ey*s;
          j+=2;
          hull[j+0] = this.convexHull[(i+2)%n] + ex*s;
          hull[j+1] = this.convexHull[(i+3)%n] + ey*s;
          j+=2;
        }
        for (var i=0; i<n; i+=2) {
          var v1x = this.convexHull[(i+2)%n] - this.convexHull[i+0], v1y = this.convexHull[(i+3)%n] - this.convexHull[i+1]; // corner edge vectors
          var v2x = this.convexHull[(i-2+n)%n] - this.convexHull[i+0], v2y = this.convexHull[(i-1+n)%n] - this.convexHull[i+1];
          var d = v1x * v2x + v1y * v2y;
          var m1 = Math.sqrt(v1x*v1x + v1y*v1y);
          var m2 = Math.sqrt(v2x*v2x + v2y*v2y);
          var a = Math.acos(d / (m1 * m2)); // corner angle
          var b = (Math.PI - a) / 4;
          var o = Math.tan(b) * radius // amount of corner extension

          j = i*2;
          v1x = hull[j+0] - hull[j+2];
          v1y = hull[j+1] - hull[j+3];
          m1 = Math.sqrt(v1x*v1x + v1y*v1y);
          v1x = v1x * (m1 + o) / m1;
          v1y = v1y * (m1 + o) / m1;
          hull[j+0] = v1x + hull[j+2];
          hull[j+1] = v1y + hull[j+3];

          j = ((i-2+n)%n)*2;
          v1x = hull[j+2] - hull[j+0];
          v1y = hull[j+3] - hull[j+1];
          m1 = Math.sqrt(v1x*v1x + v1y*v1y);
          v1x = v1x * (m1 + o) / m1;
          v1y = v1y * (m1 + o) / m1;
          hull[j+2] = v1x + hull[j+0];
          hull[j+3] = v1y + hull[j+1];
        }
        this.extendedHulls[''+radius] = hull;
      }
      computeBoundingBox(radius) {
        this.boundingBoxes[''+radius] = { };
        var h = this.extendedHulls[''+radius], bb = this.boundingBoxes[''+radius];
        if (h.length < 2) return;
        bb.x1 = h[0]; bb.x2 = h[0];
        bb.y1 = h[1]; bb.y2 = h[1];
        for (var i=2; i<h.length; i+=2) {
          if (h[i+0] < bb.x1) bb.x1 = h[i+0];
          if (h[i+0] > bb.x2) bb.x2 = h[i+0];
          if (h[i+1] < bb.y1) bb.y1 = h[i+1];
          if (h[i+1] > bb.y2) bb.y2 = h[i+1];
        }
      }
      distToHull(x,y) {
        function sqr(x) { return x * x }
        function dist2(vx,vy, wx,wy) { return sqr(vx - wx) + sqr(vy - wy) }
        function distToSegmentSquared(px,py, vx,vy, wx,wy) {
          var l2 = dist2(vx,vy, wx,wy);
          if (l2 == 0) return dist2(px,py, vx,vy);
          var t = ((px - vx) * (wx - vx) + (py - vy) * (wy - vy)) / l2;
          t = Math.max(0, Math.min(1, t));
          return dist2(px,py, vx + t * (wx - vx), vy + t * (wy - vy));
        }
        function distToSegment(px,py, vx,vy, wx,wy) { return Math.sqrt(distToSegmentSquared(px,py, vx,vy, wx,wy)); }
        var h = this.convexHull;
        var d = distToSegment(x,y, h[0],h[1], h[2],h[3]);
        for (var i=2; i<h.length; i+=2) {
          var t = distToSegment(x,y, h[i+0],h[i+1], h[(i+2)%h.length],h[(i+3)%h.length]);
          if (t<d) d=t;
        }
        return d;
      }
    }
class MiddleDividerGadget extends Gadget {
	constructor(viewport) {
		super(viewport);
		this.dragBeginFunc = function(p) {
			this.tempX = p.ox - this.viewport.x;
			this.tempY = p.oy - this.viewport.y;
		}
		this.dragMoveFunc = function(p) {
			var v = this.viewport.parent, h=(v.state == 'h');
			var a = h?
				p.y - this.tempY - v.a.y:
				p.x - this.tempX - v.a.x;
			var b = h?
				v.y + v.h - (p.y - this.tempY + this.viewport.h):
				v.x + v.w - (p.x - this.tempX + this.viewport.w);
			v.ratio = Math.max(0, Math.min(1, a/(a+b)));
			if (!v.setPoint) v.setPoint = {};
			v.setPoint[v.state] = v.ratio;
			if (layoutViews.indexOf(this.viewport.parent) === -1)
				layoutViews.push(this.viewport.parent);
		}
		this.dragEndFunc = function(p) { delete this.tempX; delete this.tempY; }
	}
	layout() {
		var g = this, v=this.viewport, x,y, s=v.getScale(), t=v.parent.size;
		var h=(v.parent.state == 'h');
		x = h?Math.max(1,v.w)/s:t;
		y = h?t:Math.max(1,v.h)/s;
		g.actionFlags = h?vp.GAF_DRAGGABLE_UPDOWN:vp.GAF_DRAGGABLE_LEFTRIGHT;
		g.convexHull = g.computeHull([0,0, 0,y, x,y, x,0]); g.extendedHulls = {}; g.boundingBoxes = {};
	}
}
    class MatrixGadget extends Gadget {
      getTargetMat() {
        return this.targetGad? this.targetGad.mat: this.targetView.userMat;
      }
      constructor(viewport) {
        super(viewport);
        this.targetView = viewport;
        this.targetGad = undefined;

        /** DRAG **/
        this.dragBeginFunc = function(p) {
          var g = this, v = g.targetView;
          g.grab1b = vec3.create(); g.grab1b[0] = p.x-v.x; g.grab1b[1] = p.y-v.y;
          g.viewMat = mat4.create(); mat4.copy(g.viewMat, v.userMat);
          g.grabMat = mat4.create(); mat4.copy(g.grabMat, g.getTargetMat());
          if (1) {
            const vi = mat4.create(); mat4.invert(vi, g.viewMat);
            vec3.transformMat4(g.grab1b, g.grab1b, vi);
          }
          if (this.targetGad) {
            const gi = mat4.create(); mat4.invert(gi, g.grabMat);
            vec3.transformMat4(g.grab1b, g.grab1b, gi);
          }
        }
        this.dragMoveFunc = function(p) {
          var g = this, v = g.targetView;
          var g1b = vec3.create(); g1b[0] = p.x-v.x; g1b[1] = p.y-v.y;
          if (1) {
            const vi = mat4.create(); mat4.invert(vi, g.viewMat);
            vec3.transformMat4(g1b, g1b, vi);
          }
          if (this.targetGad) {
            const gi = mat4.create(); mat4.invert(gi, g.grabMat);
            vec3.transformMat4(g1b, g1b, gi);
          }
          var delta = vec3.create(); vec3.subtract(delta, g1b, g.grab1b);
          if (this.targetGad) vec3.scale(delta, delta, 1/v.getScale());
          mat4.translate(g.getTargetMat(), g.grabMat, delta);
          v.rematrix(); v.setRenderFlag(true);
        }
        this.dragEndFunc = function(p) {
          var g = this, v = g.targetView;
          delete g.grab1b;
          delete g.viewMat; delete g.grabMat;
          v.setRenderFlag(true);
        }

        /** PINCH **/
        this.pinchBeginFunc = function(p1, p2) {
          var g = this, v = g.targetView;
          g.grab1 = vec3.create(); g.grab1[0] = p1.x-v.x; g.grab1[1] = p1.y-v.y;
          g.grab2 = vec3.create(); g.grab2[0] = p2.x-v.x; g.grab2[1] = p2.y-v.y;
          g.viewMat = mat4.create(); mat4.copy(g.viewMat, v.userMat);
          g.grabMat = mat4.create(); mat4.copy(g.grabMat, g.getTargetMat());
          //vec3.scale(g.grab1, g.grab1, 1/v.getScale());
          //vec3.scale(g.grab2, g.grab2, 1/v.getScale());
          g.grabC = vec3.create();
          g.grab1b = vec3.create(); vec3.copy(g.grab1b, g.grab1);
          g.grab2b = vec3.create(); vec3.copy(g.grab2b, g.grab2);
          g.grabCb = vec3.create();
          if (1) {
            const vi = mat4.create(); mat4.invert(vi, g.viewMat);
            vec3.transformMat4(g.grab1b, g.grab1b, vi);
            vec3.transformMat4(g.grab2b, g.grab2b, vi);
          }
          if (this.targetGad) {
            const gi = mat4.create(); mat4.copy(gi, g.grabMat); //mat4.invert(gi, g.grabMat);
            vec3.transformMat4(g.grab1b, g.grab1b, gi);
            vec3.transformMat4(g.grab2b, g.grab2b, gi);
          }
          for (var i=0; i<3; i++) { g.grabC[i] = (g.grab1[i] + g.grab2[i]) / 2; g.grabCb[i] = (g.grab1b[i] + g.grab2b[i]) / 2; }
          var x = g.grab2[0]-g.grab1[0], y = g.grab2[1]-g.grab1[1];
          g.grabA = Math.atan2(y, x);
          g.grabM = Math.sqrt(x*x + y*y);
        }
        this.pinchMoveFunc = function(p1, p2) {
          var g = this, v = g.targetView;
          var g1 = vec3.create(); g1[0] = p1.x-v.x; g1[1] = p1.y-v.y;
          var g2 = vec3.create(); g2[0] = p2.x-v.x; g2[1] = p2.y-v.y;
          //vec3.scale(g1, g1, 1/v.getScale());
          //vec3.scale(g2, g2, 1/v.getScale());
          var gC = vec3.create();
          var g1b = vec3.create(), g2b = vec3.create(), gCb = vec3.create();
          vec3.copy(g1b, g1); vec3.copy(g2b, g2);
          if (1) {
            const vi = mat4.create(); mat4.invert(vi, g.viewMat);
            vec3.transformMat4(g1b, g1b, vi);
            vec3.transformMat4(g2b, g2b, vi);
          }
          if (this.targetGad) {
            const gi = mat4.create(); mat4.copy(gi, g.grabMat); //mat4.invert(gi, g.grabMat);
            vec3.transformMat4(g1b, g1b, gi);
            vec3.transformMat4(g2b, g2b, gi);
          }
          for (var i=0; i<3; i++) { gC[i] = (g1[i] + g2[i]) / 2; gCb[i] = (g1b[i] + g2b[i]) / 2; }
          var x = g2[0]-g1[0], y = g2[1]-g1[1];
          var gA = Math.atan2(y, x);
          var gM = Math.sqrt(x*x + y*y);

          //const vi = mat4.create(); mat4.invert(vi, v.userMat);

          const m = mat4.create(); mat4.copy(m, g.grabMat);
          if (!this.targetGad) {
            if (g.actionFlags & vp.GAF_DRAGGABLE) mat4.translate(m, m, [gCb[0], gCb[1], 0]);
            else mat4.translate(m, m, [g.grabCb[0], g.grabCb[1], 0]);
            if (g.actionFlags & vp.GAF_SCALABLE) mat4.scale(m, m, [gM/g.grabM,gM/g.grabM,1]);
            if (g.actionFlags & vp.GAF_ROTATABLE) mat4.rotate(m, m, gA-g.grabA, [0,0,1]);
            mat4.translate(m, m, [-g.grabCb[0], -g.grabCb[1], 0]);
            v.rematrix(); v.setRenderFlag(true);
          } else {
            if (g.actionFlags & vp.GAF_DRAGGABLE) mat4.translate(m, m, [gCb[0]/v.getScale(), gCb[1]/v.getScale(), 0]);
            else mat4.translate(m, m, [g.grabCb[0]/v.getScale(), g.grabCb[1]/v.getScale(), 0]);
            if (g.actionFlags & vp.GAF_SCALABLE) mat4.scale(m, m, [gM/g.grabM,gM/g.grabM,1]);
            if (g.actionFlags & vp.GAF_ROTATABLE) mat4.rotate(m, m, gA-g.grabA, [0,0,1]);
            mat4.translate(m, m, [-g.grabCb[0]/v.getScale(), -g.grabCb[1]/v.getScale(), 0]);
            v.rematrix(); v.setRenderFlag(true);
          }
          mat4.copy(g.getTargetMat(), m);
        }
        this.pinchEndFunc = function(p1, p2) {
          var g = this, v = g.targetView;
          delete g.grab1; delete g.grab1b;
          delete g.grab2; delete g.grab2b;
          delete g.grabC; delete g.grabCb;
          delete g.grabA; delete g.grabM; delete g.grabMat;
        }
        this.zoomFunc = function(p, z) {
          const g = this, v = g.targetView, m = this.getTargetMat();
          const q = vec3.create(); if (!!(g.actionFlags & vp.GAF_DRAGGABLE)) { q[0] = p.x-v.x; q[1] = p.y-v.y; }
          else { mat4.getTranslation(q, m); }
          const ui = mat4.create(); mat4.invert(ui, m);
          vec3.transformMat4(q, q, ui);
          mat4.translate(m, m, [q[0], q[1], 0]);
          mat4.scale(m, m, [Math.exp(z/10), Math.exp(z/10), 1]);
          mat4.translate(m, m, [-q[0], -q[1], 0]);
          v.rematrix(); v.setRenderFlag(true);
        }
        this.rotateFunc = function(p, z) {
          const g = this, v = g.targetView, m = this.getTargetMat();
          const q = vec3.create(); if (!!(g.actionFlags & vp.GAF_DRAGGABLE)) { q[0] = p.x-v.x; q[1] = p.y-v.y; }
          else { mat4.getTranslation(q, m); }
          const ui = mat4.create(); mat4.invert(ui, m);
          vec3.transformMat4(q, q, ui);
          mat4.translate(m, m, [q[0], q[1], 0]);
          mat4.rotate(m, m, -Math.PI/18*z, [0, 0, 1]);
          mat4.translate(m, m, [-q[0], -q[1], 0]);
          v.rematrix(); v.setRenderFlag(true);
        }
      }
      getHits(hitList, radius) {
        if (!this.enabled) return;
        if (this.convexHull.length == 0)
          hitList.hits.push({ gad: this, dist: 0 });
        else super.getHits(hitList, radius);
      }
      layout() {
        var g = this; v = g.viewport;
        console.log('MatrixGadget::layout()');
      }
    }
class SwipeGadget extends Gadget {
	constructor(viewport) {
		super(viewport);
		this.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
		this.flingFar = false;
		this.followUp = false; this.animState = '';
		this.doSwipe = function(next, snapIndex = undefined) {
//console.group('doSwipe');
			var g = this, v = g.viewport;
			var index; if (snapIndex !== undefined) index = clamp(snapIndex, 0, v.snaps.length);
			if (g.actionFlags & (vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN)) {
				v.tempVX = 0;
				if (v.tempVY === undefined) v.tempVY = 0;
				v.tempVY = next? Math.min(v.tempVY, -0.001): Math.max(v.tempVY, 0.001);
				v.userY = v.userY - v.tempVY;
			}
			if (g.actionFlags & (vp.GAF_SWIPEABLE_LEFTRIGHT | vp.GAF_SCROLLABLE_LEFTRIGHT)) {
				if (v.tempVX === undefined) v.tempVX = 0;
				v.tempVX = next? Math.min(v.tempVX, -0.001): Math.max(v.tempVX, 0.001);
				v.tempVY = 0;
				v.userX = v.userX - v.tempVX;
			}
			g.followUp = false;
			v.relayout();
			v.setRenderFlag(true);
			g.swipeEndFunc(undefined, snapIndex !== undefined? v.snaps[index] : undefined);
//console.groupEnd();
		}
		this.swipeBeginFunc = function(p) {
			var g = this, v = g.viewport, s = v.getScale();
			if (g.actionFlags & (vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN)) {
				this.tempY = (p.oy - v.y - v.oy)/s + v.userY;
			}
			if (g.actionFlags & (vp.GAF_SWIPEABLE_LEFTRIGHT | vp.GAF_SCROLLABLE_LEFTRIGHT)) {
				this.tempX = (p.ox - v.x - v.ox)/s + v.userX;
			}
			this.followUp = false;
		}
		this.swipeMoveFunc = function(p) {
			const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
			var v = this.viewport, s = v.getScale(), dx=0, dy=0, k=1, m=1;
			var minX = v.minX, maxX = Math.max(v.maxX - v.sw, minX);
			var minY = v.minY, maxY = Math.max(v.maxY - v.sh, minY);
			if (this.maxX) maxX = Math.min(maxX, this.maxX - v.sw);
			if (this.maxY) maxY = Math.min(maxY, this.maxY - v.sh);
			switch (this.actionFlags & vp.GAF_SWIPEABLE) {
			case vp.GAF_SWIPEABLE_UPDOWN:
				dy = (p.y - v.y - v.oy)/s + v.userY - this.tempY;
				//v.userY = clamp(clamp(v.userY - dy - v.oy/s, minY, maxY) + v.oy/s, minY, maxY);
				v.userY = clamp(v.userY - dy, minY, maxY);
				v.rematrix(); this.layout();
				v.tempVX = 0; v.tempVY = p.dy;
				break;
			case vp.GAF_SWIPEABLE_LEFTRIGHT:
				dx = (p.x - v.x - v.ox)/s + v.userX - this.tempX;
				//v.userX = clamp(clamp(v.userX - dx - v.ox/s, minX, maxX) + v.ox/s, minX, maxX);
				v.userX = clamp(v.userX - dx, minX, maxX);
				v.rematrix(); this.layout();
				v.tempVX = p.dx; v.tempVY = 0;
				break;
			case vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SWIPEABLE_LEFTRIGHT:
				dx = (p.x - v.x - v.ox)/s + v.userX - this.tempX;
				dy = (p.y - v.y - v.oy)/s + v.userY - this.tempY;
				//v.userX = clamp(clamp(v.userX - dx - v.ox/s, minX, maxX) + v.ox/s, minX, maxX);
				//v.userY = clamp(clamp(v.userY - dy - v.oy/s, minY, maxY) + v.oy/s, minY, maxY);
				v.userX = clamp(v.userX - dx, minX, maxX);
				v.userY = clamp(v.userY - dy, minY, maxY);
				v.rematrix(); this.layout();
				v.tempVX = p.dx; v.tempVY = p.dy;
				break;
			}
			this.followUp = false;
			v.relayout();
			v.setRenderFlag(true);
		}
		this.swipeEndFunc = function(p, restingPoint) {
			var g = this, v = g.viewport;
			function calcRestingPoint(o, r) {
				var s = v.getScale(), x = o[0], y = o[1], dx = r[0], dy = r[1], m, n;
				m = Math.sqrt(dx*dx + dy*dy);
				n = Math.floor(m * 10);
				var rem = (m * 10 - n) / 10;
				var sum = (n+1)*n / 2;
				if (m > 0) {
					x -= dx / m * (sum/10 + rem*n) * 1000/30 / s;
					y -= dy / m * (sum/10 + rem*n) * 1000/30 / s;
				}
				return [x, y];
			}
			function calcNextPoint(o, r, snaps) {
				var a = vec2.fromValues(o[0], o[1]), b = vec2.fromValues(-r[0], -r[1]);
				vec2.normalize(b, b);
				var a1 = vec2.dot(a, b);
				var bestd = 'unset', best, snap;
				if (snaps) for (snap of snaps) {
					var c = vec2.fromValues(snap[0], snap[1])
					var c1 = vec2.dot(c, b);
					var d = c1 - a1;
					if (d >= 0 && (bestd == 'unset' || d < bestd)) { bestd = d; best = snap; }
				}
				if (bestd != 'unset') return best;
				if (snaps) for (snap of snaps) {
					var c = vec2.fromValues(snap[0], snap[1])
					var c1 = vec2.dot(c, b);
					var d = Math.abs(c1 - a1);
					if (bestd == 'unset' || (d < bestd)) { bestd = d; best = snap; }
				}
				return best;
			}
			function calcNeededVelocity(d) {
				var s = v.getScale(), x, y;
				var f = d[0]<0? 1: -1;
				x = (-0.5 + f * Math.sqrt(0.25 - f * 4*5*d[0] * s * 30/1000) / 2/5);
				y = 0;//(-0.5 + Math.sqrt(0.25 - 4*5*d[0] * s * 30/1000) / 2/5);
				return [x, y];
			}
			function findNearest(s, t) {
				var b = 'unset', best, snap;
				if (t) for (snap of t) {
					var d = Math.sqrt((s[0]-snap[0])**2 + (s[1]-snap[1])**2);
					if (b == 'unset' || d < b) { b = d; best = snap; }
				}
				return best;
			}
			function outOfBounds(p, a) {
				var s = a.getScale();
				//var minX = Math.max(a.minX + a.w/s, a.maxX) - a.w/s, maxX = Math.min(a.maxX - a.w/s, a.minX);
				//var minY = Math.max(a.minY + a.h/s, a.maxY) - a.h/s, maxY = Math.min(a.maxY - a.h/s, a.minY);
				var minX = a.minX;
				var minY = a.minY;
				var maxX = a.maxX;
				var maxY = a.maxY;
				//if (maxX < minX) { var t=minX; minX=maxX; maxX=t; }
				//if (maxY < minY) { var t=minY; minY=maxY; maxY=t; }
				return p[0] - a.ox/s < minX || p[0] - a.ox/s > maxX || p[1] - a.oy/s < minY || p[1] - a.oy/s > maxY;
			}

			// This avoids the edge case of a motionless release.
			if (Math.abs(v.tempVX) < 0.001 && (g.actionFlags & vp.GAF_SWIPEABLE_LEFTRIGHT))
				v.tempVX = 0.001;
			if (Math.abs(v.tempVY) < 0.001 && (g.actionFlags & vp.GAF_SWIPEABLE_UPDOWN))
				v.tempVY = 0.001;

			delete this.tempX; delete this.tempY;
			this.targetRest = undefined;
			this.inflect = false;
			this.animState = 'decel';
			if (v.snaps && v.snaps.length > 0) {
				var xy;
				if (g.flingFar)
					xy = calcRestingPoint([v.userX, v.userY], [v.tempVX, v.tempVY]);
				else
					xy = calcNextPoint([v.userX, v.userY], [v.tempVX, v.tempVY], v.snaps);
				var nxy = findNearest(xy, v.snaps);
				this.targetRest = restingPoint? restingPoint : nxy;
				//if (nxy[0] < v.userX) v.whenLessX = true; else v.whenLessX = false;
				//if (nxy[1] < v.userY) v.whenLessY = true; else v.whenLessY = false;
				if (nxy[0] < v.userX && v.tempVX > 0) this.animState = 'accel';
				if (nxy[0] > v.userX && v.tempVX < 0) this.animState = 'accel';
				if (nxy[1] < v.userY && v.tempVY > 0) this.animState = 'accel';
				if (nxy[1] > v.userY && v.tempVY < 0) this.animState = 'accel';
			}
			v.origVX = v.tempVX;
			v.newX = v.userX;
			v.origVY = v.tempVY;
			v.newY = v.userY;
      v.magOrig = Math.sqrt(v.tempVX * v.tempVX + v.tempVY * v.tempVY);
      v.magCur = v.magOrig;
			this.followUp = true;
			this.viewport.queueLayout();
		}
		this.followUpFunc = function() {
//console.log('followUpFunc', this.followUp);
			if (!this.followUp) return;
			var g = this, v = g.viewport;
//console.log('animState', g.animState);
			switch (g.animState) {
			case 'decel':
				if (g.coast(false)) g.animState = 'done';
				break;
			case 'accel':
				if (g.coast(true)) g.animState = 'done';
				break;
			default:
				g.followUp = false;
			}
			v.queueLayout();
		}
		this.coast = function(accel) {
			var g = this, v = g.viewport;
			var a = v;
      var s = a.getScale();
			var minX = v.minX, maxX = Math.max(v.maxX - v.sw, minX);
			var minY = v.minY, maxY = Math.max(v.maxY - v.sh, minY);
			if (this.maxX) maxX = Math.min(maxX, this.maxX - v.sw);
			if (this.maxY) maxY = Math.min(maxY, this.maxY - v.sh);
      var newX = v.newX - (v.tempVX * 1000/30 / s /*- fx*/);
      var newY = v.newY - (v.tempVY * 1000/30 / s /*- fy*/);
			if (g.targetRest && (accel || g.inflect)) {
				if (Math.sign(newX - g.targetRest[0]) != Math.sign(v.newX - g.targetRest[0])
				||  Math.sign(newY - g.targetRest[1]) != Math.sign(v.newY - g.targetRest[1])) {
					delete v.newX; delete v.newY;
					delete v.tempVX; delete v.tempVY;
					delete v.origVX; delete v.origVY;
					delete v.magOrig; delete v.magCur;
					if (g.actionFlags & (vp.GAF_SWIPEABLE_LEFTRIGHT | vp.GAF_SCROLLABLE_LEFTRIGHT)) {
						v.userX = g.targetRest[0];
					}
					if (g.actionFlags & (vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN)) {
						v.userY = g.targetRest[1];
					}
					return true;
				}
			}
			v.newX = newX;
			v.newY = newY;
			if (g.actionFlags & (vp.GAF_SWIPEABLE_LEFTRIGHT | vp.GAF_SCROLLABLE_LEFTRIGHT)) {
				v.userX = clamp(newX, minX, maxX);
			}
			if (g.actionFlags & (vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN)) {
				v.userY = clamp(newY, minY, maxY);
			}
			var magCur = accel ? v.magCur + 0.1 : v.magCur - 0.1;
			if (g.animState == 'decel' && Math.sign(magCur) != Math.sign(v.magCur)) {
				if (g.targetRest) {
					g.inflect = true;
				} else {
					delete v.newX; delete v.newY;
					delete v.tempVX; delete v.tempVY;
					delete v.origVX; delete v.origVY;
					delete v.magOrig; delete v.magCur;
					return true;
				}
			}
			v.magCur = magCur;
      v.tempVX = v.origVX / v.magOrig * v.magCur;
      v.tempVY = v.origVY / v.magOrig * v.magCur;
			return false;
		}
	}
	layout() {
		var g=this, v=g.viewport;
		if (v.maxX - v.minX <= 0
		||  v.maxY - v.minY <= 0
		||  v.sw <= 0 || v.sh <= 0)
			return;
		g.convexHull = g.computeHull([
			Math.min(v.minX, 0), Math.min(v.minY, 0),
			Math.min(v.minX, 0), Math.max(v.maxY, v.sh),
			Math.max(v.maxX, v.sw), Math.max(v.maxY, v.sh),
			Math.max(v.maxX, v.sw), Math.min(v.minY, 0)]);
		g.extendedHulls = {}; g.boundingBoxes = {};
		if (g.actionFlags & (vp.GAF_SWIPEABLE_LEFTRIGHT | vp.GAF_SCROLLABLE_LEFTRIGHT)) {
			v.userX = clamp(v.userX, v.minX, Math.max(v.maxX - v.sw, v.minX));
		}
		if (g.actionFlags & (vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN)) {
			v.userY = clamp(v.userY, v.minY, Math.max(v.maxY - v.sh, v.minY));
		}
		if (g.followUp && g.followUpFunc) g.followUpFunc.call(g);
	}
}
var inputSelected;

function endInput() {
	inputSelected = false;
	if (!inputGad) return;
	var g = inputGad, el;
	if (g.actionFlags & vp.GAF_NUMINPUT) el = kbnum;
	if (g.actionFlags & vp.GAF_TEXTINPUT) el = kbalpha;
	if (el) {
		el.blur();
		el.style.display = 'none';
	}
	inputGad = undefined;
}

function beginInput(g) {
	endInput();
	inputGad = g;
	if (g.textBeginFunc) g.textBeginFunc.call(g);
	if (g.actionFlags & vp.GAF_GONEXT) {
		kbnext.style.display = 'inline';
		kbprev.style.display = 'inline';
	}
	let el;
	if (g.actionFlags & vp.GAF_NUMINPUT) el = kbnum;
	if (g.actionFlags & vp.GAF_TEXTINPUT) el = kbalpha;
	if (el) {
		el.value = g.text;
		el.style.display = 'inline';
		el.focus();
		el.select();
		inputSelected = true;
	}
}

  function useProg() {
    gl.useProgram(plainProgram);
    gl.bindBuffer(gl.ARRAY_BUFFER, buf2);
    var a = gl.getAttribLocation(plainProgram, 'aVertexPosition')
    gl.vertexAttribPointer(
	a,
	2, // numComponents
	gl.FLOAT, // type
	false, // normalize
	0, // stride
	0); // offset
    gl.enableVertexAttribArray(a);
  }

let vpStack = [];
function pushRoot(viewport) {
	vpStack.push(rootViewport);
	rootViewport = viewport;
	rootViewport.queueLayout();
console.log('pushRoot');
	resizeCanvas();
}
function popRoot() {
	rootViewport = vpStack.pop();
	rootViewport.queueLayout();
console.log('popRoot');
	resizeCanvas();
}

rootViewport = new ViewPicker();
var refresherTimeStamp = -1, refresherFrame = 0;
var v=0, continuous=0, nframes=0, showdebug=0;
function refresher(timeStamp) {
	if (timeStamp != refresherTimeStamp) {
		var delta=0;
		if (refresherTimeStamp > 0) delta = timeStamp - refresherTimeStamp;
		refresherTimeStamp = timeStamp;

//if (delta < 10) console.log(delta);

		const todoViews = []; var lv;
		while (lv = layoutViews.pop()) todoViews.push(lv);
		if (layoutSignal) {
			layoutSignal = false;
			gl.viewport(0, 0, canvas.width, canvas.height);
			mat4.identity(pixelPM);
			mat4.translate(pixelPM, pixelPM, [-1, 1, 0]);
			mat4.scale(pixelPM, pixelPM, [2/canvas.width, -2/canvas.height, 1]);
			if (rootViewport) {
				var s = new vp.LayoutState(canvas.width, canvas.height);
				rootViewport.layoutAll(s);
			}
		} else while (lv = todoViews.pop()) lv.relayout();

      if (nframes) {
				nframes -= 1;
				if (!nframes) rootViewport.setRenderFlag(true);
			}
      if (continuous) rootViewport.setRenderFlag(true);
      if (rootViewport && (rootViewport.needsRender || rootViewport.childRender)) {
        //gl.viewport(0, 0, canvas.width, canvas.height);
        //gl.disable(gl.SCISSOR_TEST);
        //gl.clearColor(v,0,0,1); v+=delta*0.001; if(v>1) v=0;
        //gl.clear(gl.COLOR_BUFFER_BIT);


        var windspeed = 0;
        for (const [key, pointer] of Object.entries(pointers)) {
          pointer.dx = (pointer.x - pointer.px)/delta; pointer.px = pointer.x;
          pointer.dy = (pointer.y - pointer.py)/delta; pointer.py = pointer.y;
          windspeed += Math.sqrt(pointer.dx*pointer.dx + pointer.dy*pointer.dy)/diagonal;
        }
        if (windSound) windSound.setValueAtTime(windspeed, ac.currentTime);

				if (debug1 && !continuous) {
					if (nframes)
						console.log('rootViewport.renderAll()', nframes? 'n = '+nframes:'');
					else
						console.log('rootViewport.renderAll()');
				}
        rootViewport.renderAll();

if (showdebug) {
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.disable(gl.SCISSOR_TEST);
        useProg();
        gl.enable(gl.BLEND);

        gl.uniform4fv(gl.getUniformLocation(plainProgram, 'uVertexColor'), new Float32Array([1, 1, 1, 1]));
        gl.uniformMatrix4fv(gl.getUniformLocation(plainProgram, 'uProjectionMatrix'), false, pixelPM);

        const mat = mat4.create();

        if (continuous) {

        // Get a list of active gadgets.
        var gads = [];
        for (const [key, pointer] of Object.entries(pointers)) if (pointer.hitList) {
          var gs = pointer.hitList.getActionableGads(vp.GAF_ALL);
          for (const g of gs) {
            if (!gads.includes(g)) gads.push(g);
          }
        }

        // Show active gadgets.
        for (const g of gads) {
          /*
          mat4.identity(mat);
          mat4.translate(mat, mat, [g.x, g.y, 0]);
          mat4.scale(mat, mat, [g.w, g.h, 0]);
          gl.uniformMatrix4fv(
            gl.getUniformLocation(plainProgram, 'uModelViewMatrix'),
            false, mat);
          gl.drawArrays(gl.LINE_LOOP, beg2.unitSquare, len2.unitSquare);
          */
          if (g.ownedBy) switch (g.gestureState) {
          //case 'begin-tap':
          //case 'begin-click':
          //case 'recover-click':
          //case 'drag':
          default:
            var h = g.convexHull;
            for (p = 0; p < h.length; p += 2) {
              mat4.fromTranslation(mat, [g.viewport.x, g.viewport.y, 0]);
              mat4.mul(mat, mat, g.viewport.userMat);
             // mat4.translate(mat, mat, [g.viewport.x + g.viewport.ox, g.viewport.y + g.viewport.oy, 0]);
              mat4.scale(mat, mat, [g.viewport.getScale(), g.viewport.getScale(), 1]);
              mat4.translate(mat, mat, [g.x+h[p+0] - g.viewport.userX, g.y+h[p+1] - g.viewport.userY, 0]);
              mat4.scale(mat, mat, [h[(p+2)%h.length]-h[p+0], h[(p+3)%h.length]-h[p+1], 1]);
              gl.uniformMatrix4fv(
                gl.getUniformLocation(plainProgram, 'uModelViewMatrix'),
                false, mat);
              gl.drawArrays(gl.LINE_LOOP, beg2.unitLine, len2.unitLine);
            }
            var matS = vec3.create(); mat4.getScaling(matS, g.viewport.userMat);
/*
            for (const k in g.extendedHulls) if (k == ''+(getPointerRadius()/g.viewport.getScale()/matS[0])) {
              var h=g.extendedHulls[k];
              for (p = 0; p < h.length; p += 2) {
                mat4.fromTranslation(mat, [g.viewport.x, g.viewport.y, 0]);
                mat4.mul(mat, mat, g.viewport.userMat);
              //  mat4.translate(mat, mat, [g.viewport.x + g.viewport.ox, g.viewport.y + g.viewport.oy, 0]);
                mat4.scale(mat, mat, [g.viewport.getScale(), g.viewport.getScale(), 1]);
                mat4.translate(mat, mat, [g.x+h[p+0] - g.viewport.userX, g.y+h[p+1] - g.viewport.userY, 0]);
                mat4.scale(mat, mat, [h[(p+2)%h.length]-h[p+0], h[(p+3)%h.length]-h[p+1], 0]);
                gl.uniformMatrix4fv(
                  gl.getUniformLocation(plainProgram, 'uModelViewMatrix'),
                  false, mat);
                gl.drawArrays(gl.LINE_LOOP, beg2.unitLine, len2.unitLine);
              }
            }
*/
            break;
          }

        }

        for (const [key, pointer] of Object.entries(pointers)) {
          // pointer circle
          mat4.identity(mat);
          mat4.translate(mat, mat, [pointer.x, pointer.y, 0]);
          gl.uniformMatrix4fv(
            gl.getUniformLocation(plainProgram, 'uModelViewMatrix'),
            false, mat);
          if (pointer.e.pointerType == 'mouse') {
            gl.drawArrays(gl.LINE_LOOP, beg2.roundMouse, len2.roundMouse);
          } else {
            gl.drawArrays(gl.LINE_LOOP, beg2.roundTouch, len2.roundTouch);
          }
        }


        } // continuous

          refresherFrame = (refresherFrame + 1) % 16;
          mat4.identity(mat);
          mat4.translate(mat, mat, [160, 45, 0]);
          mat4.rotate(mat, mat, Math.PI/8 * refresherFrame, [0, 0, 1]);
          mat4.scale(mat, mat, [40, 10, 0]);
          gl.uniformMatrix4fv(
            gl.getUniformLocation(plainProgram, 'uModelViewMatrix'),
            false, mat);
          gl.drawArrays(gl.LINE_LOOP, beg2.unitSquare, len2.unitSquare);

          mat4.identity(mat);
          mat4.translate(mat, mat, [10, 10, 0]);
          mat4.scale(mat, mat, [50, 10, 0]);
          gl.uniformMatrix4fv(
            gl.getUniformLocation(plainProgram, 'uModelViewMatrix'),
            false, mat);
          gl.drawArrays(gl.LINE_LOOP, beg2.unitSquare, len2.unitSquare);

          mat4.identity(mat);
          mat4.translate(mat, mat, [10, 25, 0]);
          mat4.scale(mat, mat, [50 * window.visualViewport.scale, 10, 0]);
          gl.uniformMatrix4fv(
            gl.getUniformLocation(plainProgram, 'uModelViewMatrix'),
            false, mat);
          gl.drawArrays(gl.LINE_LOOP, beg2.unitSquare, len2.unitSquare);

          mat4.identity(mat);
          mat4.translate(mat, mat, [10, 40, 0]);
          mat4.scale(mat, mat, [50 * window.devicePixelRatio, 10, 0]);
          gl.uniformMatrix4fv(
            gl.getUniformLocation(plainProgram, 'uModelViewMatrix'),
            false, mat);
          gl.drawArrays(gl.LINE_LOOP, beg2.unitSquare, len2.unitSquare);

          mat4.identity(mat);
          mat4.translate(mat, mat, [10, 55, 0]);
          mat4.scale(mat, mat, [50 * window.innerWidth/1000, 10, 0]);
          gl.uniformMatrix4fv(
            gl.getUniformLocation(plainProgram, 'uModelViewMatrix'),
            false, mat);
          gl.drawArrays(gl.LINE_LOOP, beg2.unitSquare, len2.unitSquare);
        for (const [key, p] of Object.entries(pointers)) {
          mat4.identity(mat);
          mat4.translate(mat, mat, [12, 57, 0]);
          mat4.scale(mat, mat, [46 * p.x/wi2px/1000, 6, 0]);
          gl.uniformMatrix4fv(
            gl.getUniformLocation(plainProgram, 'uModelViewMatrix'),
            false, mat);
          gl.drawArrays(gl.LINE_LOOP, beg2.unitSquare, len2.unitSquare);
        }

          mat4.identity(mat);
          mat4.translate(mat, mat, [10, 70, 0]);
          mat4.scale(mat, mat, [50 * window.innerHeight/1000, 10, 0]);
          gl.uniformMatrix4fv(
            gl.getUniformLocation(plainProgram, 'uModelViewMatrix'),
            false, mat);
          gl.drawArrays(gl.LINE_LOOP, beg2.unitSquare, len2.unitSquare);
        for (const [key, p] of Object.entries(pointers)) {
          mat4.identity(mat);
          mat4.translate(mat, mat, [12, 72, 0]);
          mat4.scale(mat, mat, [46 * p.y/wi2px/1000, 6, 0]);
          gl.uniformMatrix4fv(
            gl.getUniformLocation(plainProgram, 'uModelViewMatrix'),
            false, mat);
          gl.drawArrays(gl.LINE_LOOP, beg2.unitSquare, len2.unitSquare);
        }

}



      }
	} // refresher time stamp changed
	window.requestAnimationFrame(refresher);
};

function resizeCanvas() {
	if (debug1) console.log('resizeCanvas()');
	nframes = 10;
	var w = window.innerWidth, h = window.innerHeight;
//console.log(w, h, 'window.inner');
	if (1) {
		canvas.width = w * window.visualViewport.scale * window.devicePixelRatio;
		canvas.height = h * window.visualViewport.scale * window.devicePixelRatio;
		canvas.style.width = w * window.visualViewport.scale;
		canvas.style.height = h * window.visualViewport.scale;
	}
	diagonal = Math.sqrt(canvas.width*canvas.width + canvas.height*canvas.height);
	wi2px = window.visualViewport.scale * window.devicePixelRatio;
	px2wi = 1/wi2px;
	layoutSignal = true;
	if (rootViewport.resizeFunc) rootViewport.resizeFunc.call(rootViewport);
}

  var pointers = {};
  const TAP_WINDOW = 250; // ms
  const TAP_WIGGLE = 15 * window.devicePixelRatio;
  function eventHandler(e, action) {

    var index;

		// Helper: On commitment to drag, disown ambiguously selected click gadgets.
		function DisownAllOtherGads(p, g) {
			for (const o of p.hitList.hits) if (o.gad !== g) {
				if (o.gad.ownedBy == index) {
					o.gad.gestureState = o.gad.gestureState + '-disowned';
					o.gad.viewport.setRenderFlag(true);
					delete o.gad.ownedBy;
				}
			}
		}

    if (action == 'touches' && e.touches && e.touches.length == 0) {
   //   window.speechSynthesis.speak(new SpeechSynthesisUtterance(' '+e.touches.length));
      var toDel = [];
      for (const [key, p] of Object.entries(pointers)) p.tempIsActive = !!(p.e.pointerType == 'mouse');
   //   for (var i = 0; i < e.touches.length; i++) if (pointers['p-'+e.touches[i].identifier]) pointers['p-'+e.touches[i].identifier].tempIsActive = 1;
      for (const [key, p] of Object.entries(pointers)) if (!p.tempIsActive) toDel.push(key);
      while (toDel.length) delete pointers[toDel.pop()];
      for (const [key, p] of Object.entries(pointers)) delete p.tempIsActive;
      return;
    }
    if (wi2px != window.visualViewport.scale * window.devicePixelRatio) resizeCanvas();
var speak = 0;
    index = 'p-'+e.pointerId;
/*
    var numTouches;
    var touches = [];
    function recalc() {
      var n = 0, t = [];
      for (const [key, pointer] of Object.entries(pointers)) {
        if (pointer.touching && pointer.e.pointerType!='mouse') { t[n] = pointer; n += 1; }
      }
      numTouches = n;
      touches = t;
    }
*/
    var dir;
    function calcSwipeDir(p) {
      const xdiff = p.x - p.ox;
      const ydiff = p.y - p.oy;
      if (xdiff*xdiff > ydiff*ydiff) {
        if (xdiff > 0) return 'right'; else return 'left';
      } else {
        if (ydiff > 0) return 'down'; else return 'up';
      }
    }
    var p, hl;
    switch (action) {
    case 'down':
			endInput();
      if (!pointers.hasOwnProperty(index)) pointers[index] = { gestureState: '', touching: false, px: e.layerX * wi2px, py: e.layerY * wi2px };
      p = pointers[index]; p.e = e; p.touching = true;
      p.x = e.layerX * wi2px;
      p.y = e.layerY * wi2px;
      p.ox = p.x;
      p.oy = p.y;
    //  recalc();
      p.hitList = new vp.HitList(p.x, p.y);
      rootViewport.getHits(p.hitList, getPointerRadius());
      p.hitList.sortHits();
      if (e.pointerType=='mouse') {
        if (e.button == 0) {
          for (const h of p.hitList.hits) {
            const g = h.gad;
            if (!g.ownedBy && !!(g.actionFlags & vp.GAF_CLICKABLE)) {
              g.gestureState = 'begin-click'; g.ownedBy = index;
              g.viewport.setRenderFlag(true);
            }
            if (!g.ownedBy && !!(g.actionFlags & vp.GAF_DRAGGABLE)) {
              g.gestureState = 'begin-drag'; g.ownedBy = index;
              g.viewport.setRenderFlag(true);
            }
            if (!g.ownedBy && !!(g.actionFlags & (vp.GAF_NUMINPUT | vp.GAF_TEXTINPUT))) {
              g.gestureState = 'begin-input'; g.ownedBy = index;
              g.viewport.setRenderFlag(true);
            }
            g.gestureTimerId = setTimeout(eventHandler, TAP_WINDOW, e, 'drag time reached');
          }
        }
        if (e.button == 2) {
          for (const h of p.hitList.hits) {
            const g = h.gad;
            if (!g.ownedBy && !!(g.actionFlags & vp.GAF_CONTEXTMENU)) {
              g.gestureState = 'begin-menu'; g.ownedBy = index;
              g.viewport.setRenderFlag(true);
              PlatformUtil.AudioClick()
            }
          }
        }
      } else { // not mouse (down)
        var clickableAlreadyFound = false;
        for (const h of p.hitList.hits) {
          const g = h.gad;
          if (!g.ownedBy) {
            if (!!(g.actionFlags & vp.GAF_CLICKABLE) && !clickableAlreadyFound) {
              g.gestureState = 'begin-tap'; g.ownedBy = index; clickableAlreadyFound = true;
              g.viewport.setRenderFlag(true);
              g.gestureBeginTime = e.timeStamp;
              if (!!(g.actionFlags & (
              vp.GAF_CONTEXTMENU | vp.GAF_HOLDABLE | vp.GAF_DRAGGABLE))) {
                g.gestureTimerId = setTimeout(eventHandler, TAP_WINDOW, e, 'tap-and-hold time reached');
     if(speak) window.speechSynthesis.speak(new SpeechSynthesisUtterance('begin tap hold'));
              } else
if(speak) window.speechSynthesis.speak(new SpeechSynthesisUtterance('begin tap '+g.actionFlags));
            } else if (!!(g.actionFlags & (vp.GAF_NUMINPUT | vp.GAF_TEXTINPUT))) {
              g.gestureState = 'begin-input'; g.ownedBy = index;
              g.viewport.setRenderFlag(true);
              g.gestureBeginTime = e.timeStamp;
              if (!!(g.actionFlags & vp.GAF_CONTEXTMENU)) {
                g.gestureTimerId = setTimeout(eventHandler, TAP_WINDOW, e,
									'tap-and-hold time reached');
              }
            } else if (!!(g.actionFlags & vp.GAF_CONTEXTMENU)) {
              g.gestureState = 'begin-menu'; g.ownedBy = index;
              g.viewport.setRenderFlag(true);
              g.gestureTimerId = setTimeout(eventHandler, TAP_WINDOW, e, 'tap-and-hold time reached');
            } else if (!!(g.actionFlags & vp.GAF_HOLDABLE)) {
              g.gestureState = 'begin-hold'; g.ownedBy = index;
              g.viewport.setRenderFlag(true);
              g.gestureTimerId = setTimeout(eventHandler, TAP_WINDOW, e, 'tap-and-hold time reached');
            } else if (!!(g.actionFlags & vp.GAF_DRAGGABLE)) {
              g.gestureState = 'begin-drag'; g.ownedBy = index;
              g.viewport.setRenderFlag(true);
              g.gestureTimerId = setTimeout(eventHandler, TAP_WINDOW, e, 'drag time reached');
            } else if (!!(g.actionFlags & vp.GAF_SWIPEABLE)) {
              g.gestureState = 'begin-swipe'; g.ownedBy = index;
              g.viewport.setRenderFlag(true);
 // if(speak) window.speechSynthesis.speak(new SpeechSynthesisUtterance('begin swipe'));
            } else if (!!(g.actionFlags & vp.GAF_PINCHABLE)) {
              g.gestureState = 'await-pinch'; g.ownedBy = index;
              g.viewport.setRenderFlag(true);
            }
          } else if (g.ownedBy != index) {
            if (g.gestureState == 'await-pinch' || (!!(g.actionFlags & vp.GAF_PINCHABLE) && (g.gestureState == 'begin-drag' || g.gestureState == 'begin-tap'))) {
              g.gestureState = 'pinch'; g.secondTouch = index;
              g.viewport.setRenderFlag(true);
              if (g.pinchBeginFunc) g.pinchBeginFunc.call(g, pointers[g.ownedBy], pointers[g.secondTouch]);
            } else if (g.gestureState == 'drag' && !!(g.actionFlags & vp.GAF_PINCHABLE)) {
              g.gestureState = 'pinch'; g.secondTouch = index;
              g.viewport.setRenderFlag(true);
              if (g.dragEndFunc) g.dragEndFunc.call(g, pointers[g.ownedBy]);
              if (g.pinchBeginFunc) g.pinchBeginFunc.call(g, pointers[g.ownedBy], pointers[g.secondTouch]);
            }
          }
        }
      }
      break;
    case 'move':
      if (!mouseEnabled && e.pointerType=='mouse') { mouseEnabled = 1; if (rootViewport.enableMouse) rootViewport.enableMouse.call(rootViewport); }
      if (!pointers.hasOwnProperty(index)) pointers[index] = { gestureState: e.pointerType=='mouse'?'hover':'', touching: e.pointerType=='mouse'?false:true };
      p = pointers[index]; p.e = e;
      p.px = p.x; p.x = e.layerX * wi2px;
      p.py = p.y; p.y = e.layerY * wi2px;
      if (e.pointerType=='mouse') {
        if (p.hitList) for (const h of p.hitList.hits) {
          const g = h.gad;
          if (g.ownedBy == index) {
            switch (g.gestureState) {
            case 'begin-click':
            case 'recover-click':
              var tempHit = new vp.HitList(p.x, p.y);
              g.getHits(tempHit, getPointerRadius());
              if (tempHit.hits.length == 0) {
                g.gestureState = 'abandon-click';
                g.viewport.setRenderFlag(true);
              }
              break;
            case 'begin-input':
              var tempHit = new vp.HitList(p.x, p.y);
              g.getHits(tempHit, getPointerRadius());
              if (tempHit.hits.length == 0) {
                g.gestureState = 'abandon-input';
                g.viewport.setRenderFlag(true);
              }
              break;
            case 'hold':
              var tempHit = new vp.HitList(p.x, p.y);
              g.getHits(tempHit, getPointerRadius());
              if (tempHit.hits.length == 0) {
                g.gestureState = 'abandon-hold';
                g.viewport.setRenderFlag(true);
								if (g.holdEndFunc) g.holdEndFunc.call(g, p);
              }
              break;
            case 'abandon-click':
              var tempHit = new vp.HitList(p.x, p.y);
              g.getHits(tempHit, getPointerRadius());
              if (tempHit.hits.length != 0) {
                g.gestureState = 'recover-click';
                g.viewport.setRenderFlag(true);
              }
              break;
            case 'abandon-hold':
              var tempHit = new vp.HitList(p.x, p.y);
              g.getHits(tempHit, getPointerRadius());
              if (tempHit.hits.length != 0) {
                g.gestureState = 'hold';
                g.viewport.setRenderFlag(true);
								if (g.holdBeginFunc) g.holdBeginFunc.call(g, p);
              }
              break;
            case 'begin-drag':
              dir = calcSwipeDir(p);
              if (Math.sqrt((p.ox - p.x)**2 + (p.oy - p.y)**2) > TAP_WIGGLE) {
                if (g.hasOwnProperty('gestureTimerId')) { clearTimeout(g.gestureTimerId); delete g.gestureTimerId; }
                if ( ((dir == 'up' || dir == 'down') && !!(g.actionFlags & vp.GAF_DRAGGABLE_UPDOWN))
                  || ((dir == 'left' || dir == 'right') && !!(g.actionFlags & vp.GAF_DRAGGABLE_LEFTRIGHT)) ) {
                  g.gestureState = 'drag';
                  g.viewport.setRenderFlag(true);
									DisownAllOtherGads(p, g);
                  if (g.dragBeginFunc) g.dragBeginFunc.call(g, p);
                  if (g.dragMoveFunc) g.dragMoveFunc.call(g, p);
                }
              }
              break;
            case 'drag':
              if (g.dragMoveFunc) g.dragMoveFunc.call(g, p);
              break;
            }
          }
        }
      } else { // not mouse (move)
        for (const h of p.hitList.hits) {
          const g = h.gad;
          if (g.ownedBy == index) {
            switch (g.gestureState) {
            case 'begin-tap':
              if (Math.sqrt((p.ox - p.x)**2 + (p.oy - p.y)**2) > TAP_WIGGLE) {
                g.gestureState = 'invalid-tap';
                g.viewport.setRenderFlag(true);
     if(speak) window.speechSynthesis.speak(new SpeechSynthesisUtterance('invalid'));
                if (!p.swiping) {
                  dir = calcSwipeDir(p);
                  if ( ((dir == 'up' || dir == 'down') && !!(g.actionFlags & vp.GAF_SWIPEABLE_UPDOWN))
                    || ((dir == 'left' || dir == 'right') && !!(g.actionFlags & vp.GAF_SWIPEABLE_LEFTRIGHT)) ) {
                    g.gestureState = 'swipe'; p.swiping = true;
                    g.viewport.setRenderFlag(true);
                    for (const o of p.hitList.hits) if (o.gad !== g && o.gad.ownedBy == index) delete o.gad.ownedBy;
										delete p.cancel;
                    if (g.swipeBeginFunc) g.swipeBeginFunc.call(g, p);
										if (p.cancel) {
											g.gestureState = 'prog-cancel-swipe';
										} else {
	                    if (g.swipeMoveFunc) g.swipeMoveFunc.call(g, p);
  console.log('swipe '+dir);
  if(speak) window.speechSynthesis.speak(new SpeechSynthesisUtterance('swipe '+dir));
										}
                  } else
                  if ( ((dir == 'up' || dir == 'down') && !!(g.actionFlags & vp.GAF_DRAGGABLE_UPDOWN))
                    || ((dir == 'left' || dir == 'right') && !!(g.actionFlags & vp.GAF_DRAGGABLE_LEFTRIGHT)) ) {
                    g.gestureState = 'drag'; p.swiping = true;
                    g.viewport.setRenderFlag(true);
										DisownAllOtherGags(p, g);
										delete p.cancel;
                    if (g.dragBeginFunc) g.dragBeginFunc.call(g, p);
										if (p.cancel) {
											g.gestureState = 'prog-cancel-drag';
										} else {
	                    if (g.dragMoveFunc) g.dragMoveFunc.call(g, p);
  console.log('drag '+dir);
  if(speak) window.speechSynthesis.speak(new SpeechSynthesisUtterance('drag '+dir));
										}
                  }
                }
              }
              break;
            case 'begin-input':
              if (Math.sqrt((p.ox - p.x)**2 + (p.oy - p.y)**2) > TAP_WIGGLE) {
                if (g.hasOwnProperty('gestureTimerId')) { clearTimeout(g.gestureTimerId); delete g.gestureTimerId; }
                g.gestureState = 'invalid-input';
                g.viewport.setRenderFlag(true);
              }
              break;
            case 'begin-menu':
              if (Math.sqrt((p.ox - p.x)**2 + (p.oy - p.y)**2) > TAP_WIGGLE) {
                if (g.hasOwnProperty('gestureTimerId')) { clearTimeout(g.gestureTimerId); delete g.gestureTimerId; }
                g.gestureState = 'invalid-menu';
                g.viewport.setRenderFlag(true);
              }
              break;
            case 'begin-hold':
              if (Math.sqrt((p.ox - p.x)**2 + (p.oy - p.y)**2) > TAP_WIGGLE) {
                if (g.hasOwnProperty('gestureTimerId')) { clearTimeout(g.gestureTimerId); delete g.gestureTimerId; }
                g.gestureState = 'invalid-hold';
                g.viewport.setRenderFlag(true);
              }
              break;
            case 'begin-swipe':
              dir = calcSwipeDir(p);
              if (Math.sqrt((p.ox - p.x)**2 + (p.oy - p.y)**2) > TAP_WIGGLE) {
                if (g.hasOwnProperty('gestureTimerId')) { clearTimeout(g.gestureTimerId); delete g.gestureTimerId; }
                if (!p.swiping) {
                  if ( ((dir == 'up' || dir == 'down') && !!(g.actionFlags & vp.GAF_SWIPEABLE_UPDOWN))
                    || ((dir == 'left' || dir == 'right') && !!(g.actionFlags & vp.GAF_SWIPEABLE_LEFTRIGHT)) ) {
                    g.gestureState = 'swipe'; p.swiping = true;
                    g.viewport.setRenderFlag(true);
										DisownAllOtherGads(p, g);
										delete p.cancel;
                    if (g.swipeBeginFunc) g.swipeBeginFunc.call(g, p);
										if (p.cancel) {
											g.gestureState = 'prog-cancel-swipe';
										} else {
	                    if (g.swipeMoveFunc) g.swipeMoveFunc.call(g, p);
     if(speak) window.speechSynthesis.speak(new SpeechSynthesisUtterance('swipe '+dir));
										}
                  }
                }
              }
              break;
            case 'hold':
              var tempHit = new vp.HitList(p.x, p.y);
              g.getHits(tempHit, getPointerRadius());
              if (tempHit.hits.length == 0) {
                g.gestureState = 'abandon-hold';
                g.viewport.setRenderFlag(true);
								if (g.holdEndFunc) g.holdEndFunc.call(g, p);
              }
              break;
            case 'swipe':
              if (g.swipeMoveFunc) g.swipeMoveFunc.call(g, p);
              break;
            case 'begin-drag':
              dir = calcSwipeDir(p);
              if (Math.sqrt((p.ox - p.x)**2 + (p.oy - p.y)**2) > TAP_WIGGLE) {
                if (g.hasOwnProperty('gestureTimerId')) { clearTimeout(g.gestureTimerId); delete g.gestureTimerId; }
                if (!p.swiping) {
                  if ( ((dir == 'up' || dir == 'down') && !!(g.actionFlags & vp.GAF_DRAGGABLE_UPDOWN))
                    || ((dir == 'left' || dir == 'right') && !!(g.actionFlags & vp.GAF_DRAGGABLE_LEFTRIGHT)) ) {
                    g.gestureState = 'drag'; p.swiping = true;
                    g.viewport.setRenderFlag(true);
										DisownAllOtherGads(p, g);
                    for (const o of p.hitList.hits) if (o.gad !== g) {
                      if (o.gad.secondTouch == index) {
                        switch (o.gad.gestureState) {
                        case 'pinch':
                          o.gad.gestureState = 'drag'; delete o.gad.secondTouch;
                          o.gad.viewport.setRenderFlag(true);
                          if (o.gad.pinchEndFunc) o.gad.pinchEndFunc.call(o.gad);
                          if (o.gad.dragBeginFunc) o.gad.dragBeginFunc.call(o.gad, pointers[o.gad.ownedBy]);
                          break;
                        }
                      }
                    }
                    if (g.dragBeginFunc) g.dragBeginFunc.call(g, p);
                    if (g.dragMoveFunc) g.dragMoveFunc.call(g, p);
                  }
                }
              }
              break;
            case 'drag':
              if (g.dragMoveFunc) g.dragMoveFunc.call(g, p);
              break;
            case 'pinch':
              if (g.pinchMoveFunc) g.pinchMoveFunc.call(g, pointers[g.ownedBy], pointers[g.secondTouch]);
              break; 
            }
          } else if (g.secondTouch == index) {
            switch (g.gestureState) {
            case 'pinch':
              if (g.pinchMoveFunc) g.pinchMoveFunc.call(g, pointers[g.ownedBy], pointers[g.secondTouch]);
              break;
            } 
          }
        }
      }
      break;
    case 'up':
      if (!pointers.hasOwnProperty(index)) pointers[index] = { gestureState: '', touching: false, x: 0, y: 0, px: 0, py: 0 };
      p = pointers[index]; p.e = e; p.touching = false;
     // recalc();
      if (e.pointerType=='mouse') {
        if (e.button == 0) {
          var skipflag = 0;
          if (p.hitList) for (const h of p.hitList.hits) {
            const g = h.gad;
            if (g.ownedBy == index) {
              if (!skipflag) switch (g.gestureState) {
              case 'begin-click':
              case 'recover-click':
                PlatformUtil.AudioClick()
                if (g.clickFunc) g.clickFunc.call(g, p);
                skipflag=1;
                break;
              case 'begin-input':
                PlatformUtil.AudioClick()
								beginInput(g);
                skipflag=1;
                break;
							case 'hold':
                if (g.holdEndFunc) g.holdEndFunc.call(g, p);
								break;
              case 'abandon-click':
                break;
              case 'begin-drag':
                if (g.hasOwnProperty('gestureTimerId')) { clearTimeout(g.gestureTimerId); delete g.gestureTimerId; }
                break;
              case 'drag':
                if (g.dragMoveFunc) g.dragMoveFunc.call(g, p);
                if (g.dragEndFunc) g.dragEndFunc.call(g, p);
                break;
              }
              delete g.gestureState; delete g.ownedBy;
              g.viewport.setRenderFlag(true);
            }
          }
        }
        if (e.button == 2) {
          for (const h of p.hitList.hits) {
            const g = h.gad;
            if (g.ownedBy == index) {
              switch (g.gestureState) {
              case 'begin-menu':
                if (g.contextMenuFunc) g.contextMenuFunc.call(g, p);
                break;
              }
              delete g.gestureState; delete g.ownedBy;
              g.viewport.setRenderFlag(true);
            }
          }
        }
        delete p.hitList;
      } else { // not mouse (up)
        var skipflag = 0;
        for (const h of p.hitList.hits) {
          const g = h.gad;
          var skipDel = 0;
          if (g.ownedBy == index) {
            if (g.hasOwnProperty('gestureTimerId')) { clearTimeout(g.gestureTimerId); delete g.gestureTimerId; }
            if (!skipflag) switch (g.gestureState) {
            case 'begin-tap':
              PlatformUtil.AudioClick()
              if (g.clickFunc) g.clickFunc.call(g, p);
              skipflag=1;
              break;
            case 'begin-input':
              PlatformUtil.AudioClick()
							beginInput(g);
              skipflag=1;
              break;
						case 'hold':
     if(speak) window.speechSynthesis.speak(new SpeechSynthesisUtterance('end hold'));
              if (g.holdEndFunc) g.holdEndFunc.call(g, p);
							break;
            case 'tap-and-hold':
console.log('tap-and-hold release');
if(speak) window.speechSynthesis.speak(new SpeechSynthesisUtterance('release'));
              break;
            case 'swipe':
              if (g.swipeMoveFunc) g.swipeMoveFunc.call(g, p);
              if (g.swipeEndFunc) g.swipeEndFunc.call(g, p);
              break;
            case 'drag':
              if (g.dragMoveFunc) g.dragMoveFunc.call(g, p);
              if (g.dragEndFunc) g.dragEndFunc.call(g, p);
              break;
            case 'pinch':
if(speak) window.speechSynthesis.speak(new SpeechSynthesisUtterance('releasing'));
              g.gestureState = 'drag'; g.ownedBy = g.secondTouch; delete g.secondTouch;
              g.viewport.setRenderFlag(true);
              if (g.pinchEndFunc) g.pinchEndFunc.call(g);
              if (g.dragBeginFunc) g.dragBeginFunc.call(g, pointers[g.ownedBy]);
              skipDel = 1;
              break;
            }
            if (!skipDel) {
              delete g.gestureState; delete g.ownedBy;
              g.viewport.setRenderFlag(true);
            }
          } else if (g.secondTouch == index) {
            switch (g.gestureState) {
            case 'pinch':
if(speak) window.speechSynthesis.speak(new SpeechSynthesisUtterance('releasing'));
              g.gestureState = 'drag'; delete g.secondTouch;
              g.viewport.setRenderFlag(true);
              if (g.pinchEndFunc) g.pinchEndFunc.call(g);
              if (g.dragBeginFunc) g.dragBeginFunc.call(g, pointers[g.ownedBy]);
              break;
            } 
          }
        }
      }
      if (e.pointerType == 'touch') delete pointers[index];
      delete p.swiping;
      break;
    case 'wheel':
      if (!pointers.hasOwnProperty(index)) pointers[index] = { gestureState: '', touching: false, px: e.layerX * wi2px, py: e.layerY * wi2px };
      p = pointers[index]; p.e = e; p.touching = true;
      p.x = e.layerX * wi2px;
      p.y = e.layerY * wi2px;
      //p.ox = p.x;
      //p.oy = p.y;
     // recalc();
      p.hitList = new vp.HitList(p.x, p.y);
      rootViewport.getHits(p.hitList, getPointerRadius());
      p.hitList.sortHits();
      if (e.type=='wheel') {
        var skipflag = 0;
        for (const h of p.hitList.hits) {
          const g = h.gad;
          if (!skipflag && !g.ownedBy) {
            if (!!(g.actionFlags & vp.GAF_SCROLLABLE_UPDOWN)) {
              p = pointers[index]; p.e = e;
              p.x = e.layerX * wi2px; p.ox = p.x; p.px = p.x;
              p.y = e.layerY * wi2px; p.oy = p.y; p.py = p.y;
							delete p.cancel;
              if (g.swipeBeginFunc) g.swipeBeginFunc.call(g, p);
							if (!p.cancel) {
		            p.dx = 0; p.x = p.x;
		            p.dy = Math.sign(e.wheelDelta) * 0.8 * window.devicePixelRatio; p.y = p.y + p.dy;
		            if (g.swipeMoveFunc) g.swipeMoveFunc.call(g, p);
		            if (g.swipeEndFunc) g.swipeEndFunc.call(g, p);
							}
              skipflag=1;
            } else if (!!(g.actionFlags & vp.GAF_SCROLLABLE_LEFTRIGHT)) {
              p = pointers[index]; p.e = e;
              p.x = e.layerX * wi2px; p.ox = p.x; p.px = p.x;
              p.y = e.layerY * wi2px; p.oy = p.y; p.py = p.y;
							delete p.cancel;
              if (g.swipeBeginFunc) g.swipeBeginFunc.call(g, p);
							if (!p.cancel) {
		            p.dx = Math.sign(e.wheelDelta) * 0.8 * window.devicePixelRatio; p.x = p.x + p.dx;
		            p.dy = 0; p.y = p.y;
		            if (g.swipeMoveFunc) g.swipeMoveFunc.call(g, p);
		            if (g.swipeEndFunc) g.swipeEndFunc.call(g, p);
							}
              skipflag=1;
            } else if (!!(g.actionFlags & vp.GAF_PINCHABLE)) {
              p = pointers[index]; p.e = e;
              p.x = e.layerX * wi2px; p.ox = p.x; p.px = p.x;
              p.y = e.layerY * wi2px; p.oy = p.y; p.py = p.y;
              if (!!(g.actionFlags & vp.GAF_ROTATABLE) && e.altKey && g.rotateFunc)
                g.rotateFunc.call(g, p, Math.sign(e.wheelDelta));
              else if (!!(g.actionFlags & vp.GAF_SCALABLE) && g.zoomFunc)
                g.zoomFunc.call(g, p, Math.sign(e.wheelDelta));
              skipflag=1;
            }
          }
	       }
      }
      break;
    case 'drag time reached':
      if (!pointers.hasOwnProperty(index)) pointers[index] = { gestureState: '', touching: true };
      p = pointers[index]; p.e = e;
      if (p.hitList) for (const h of p.hitList.hits) {
        const g = h.gad;
        if (g.ownedBy == index) {
          if (g.gestureState == 'begin-click' && (g.actionFlags & vp.GAF_HOLDABLE)) {
            g.gestureState = 'hold';
            g.viewport.setRenderFlag(true);
						DisownAllOtherGads(p, g);
            if (g.holdBeginFunc) g.holdBeginFunc.call(g, p);
					}
          if (g.gestureState == 'begin-drag' && !p.swiping) {
            g.gestureState = 'drag'; p.swiping = true;
            g.viewport.setRenderFlag(true);
						DisownAllOtherGads(p, g);
            if (g.dragBeginFunc) g.dragBeginFunc.call(g, p);
          }
          if (g.hasOwnProperty('gestureTimerId')) { delete g.gestureTimerId; }
        }
      }
      break;
    case 'tap-and-hold time reached':
console.log('tap-and-hold time reached');
      if (!pointers.hasOwnProperty(index)) pointers[index] = { gestureState: '', touching: true };
      p = pointers[index]; p.e = e;
      for (const h of p.hitList.hits) {
        const g = h.gad;
        if (g.ownedBy == index) {
          if (Math.sqrt((p.ox - p.x)**2 + (p.oy - p.y)**2) <= TAP_WIGGLE)
          switch (g.gestureState) {
          case 'begin-tap':
          case 'begin-menu':
          case 'begin-input':
          case 'begin-swipe':
          case 'begin-drag':
          case 'begin-hold':
            if (!!(g.actionFlags & vp.GAF_CONTEXTMENU) && !p.swiping) {
              g.gestureState = 'menu-hold';
              g.viewport.setRenderFlag(true);
              DisownAllOtherGads(p, g);
              if (g.contextMenuFunc) g.contextMenuFunc.call(g, p);
            } else if (!!(g.actionFlags & vp.GAF_HOLDABLE) && !p.swiping) {
              g.gestureState = 'hold';
console.log('hold');
              g.viewport.setRenderFlag(true);
							DisownAllOtherGads(p, g);
		          if (g.holdBeginFunc) g.holdBeginFunc.call(g, p);
if(speak) window.speechSynthesis.speak(new SpeechSynthesisUtterance('hold'));
            } else if (!!(g.actionFlags & vp.GAF_DRAGGABLE) && !p.swiping) {
              g.gestureState = 'drag'; p.swiping = true;
              g.viewport.setRenderFlag(true);
							DisownAllOtherGads(p, g);
              if (g.dragBeginFunc) g.dragBeginFunc.call(g, p);
            } else if (!!(g.actionFlags & vp.GAF_SWIPEABLE) && !p.swiping) {
              g.gestureState = 'swipe'; p.swiping = true;
              g.viewport.setRenderFlag(true);
              for (const o of p.hitList.hits) if (o.gad !== g && o.gad.ownedBy == index) delete o.gad.ownedBy;
							delete p.cancel;
              if (g.swipeBeginFunc) g.swipeBeginFunc.call(g, p);
							if (p.cancel) {
								g.gestureState = 'prog-cancel-swipe';
							}
            } else {
              g.gestureState = 'invalid-tap-and-hold';
              g.viewport.setRenderFlag(true);
            }
            break;
          }
          if (g.hasOwnProperty('gestureTimerId')) { delete g.gestureTimerId; }
        }
      }
      break;
    }
  }

function initialize(c, inputalpha, inputnum, inputnext, inputprev) {
	canvas = c;
	kbalpha = inputalpha;
	kbnum = inputnum;
	kbnext = inputnext;
	kbprev = inputprev;
	gl = canvas.getContext('webgl2', {
		antialias: true,
		alpha: false,
		desynchronized: true,
		preserveDrawingBuffer: true,
	});
	var viewportOrigFunc = gl.viewport.bind(gl), curDims;
	gl.viewport = function(x,y,w,h) {
		curDims = [x,y,w,h];
		viewportOrigFunc(x,y,w,h);
	}
	var getParameterOrigFunc = gl.getParameter.bind(gl);
	gl.getParameter = function(pname) {
		return (pname == gl.VIEWPORT && !!curDims)?
			curDims:
			getParameterOrigFunc(pname);
	}
}

function start(root) {

	// WEBGL INITIALIZATION

	if (!gl) return;

	const plainVertexShader = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(plainVertexShader, `
        attribute vec4 aVertexPosition;
        uniform vec4 uVertexColor;
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        varying vec4 v_Color;
        void main() {
          gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
          v_Color = uVertexColor;
        }
	`);
	gl.compileShader(plainVertexShader);
	if (!gl.getShaderParameter(plainVertexShader, gl.COMPILE_STATUS)) return;

	const plainFragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(plainFragmentShader, `
        varying lowp vec4 v_Color;
        void main() {
          gl_FragColor = v_Color;
        }
	`);
	gl.compileShader(plainFragmentShader);
	if (!gl.getShaderParameter(plainFragmentShader, gl.COMPILE_STATUS)) return;

	plainProgram = gl.createProgram();
	gl.attachShader(plainProgram, plainVertexShader);
	gl.attachShader(plainProgram, plainFragmentShader);
	gl.linkProgram(plainProgram);
	if (!gl.getProgramParameter(plainProgram, gl.LINK_STATUS)) return;

	buf2 = gl.createBuffer(); // buffer for 2-value vertices
	gl.bindBuffer(gl.ARRAY_BUFFER, buf2);
	gl.vertexAttribPointer(
		gl.getAttribLocation(plainProgram, 'aVertexPosition'),
		2, // numComponents
		gl.FLOAT, // type
		false, // normalize
		0, // stride
		0); // offset
	gl.enableVertexAttribArray(
		gl.getAttribLocation(plainProgram, 'aVertexPosition'));

	const cum2 = []; // accumulator to build data for buffer

	beg2.unitLine = cum2.length/2; cum2.splice(cum2.length, 0,
		0,0, 1,1,
	); len2.unitLine = cum2.length/2 - beg2.unitLine;

	beg2.unitSquare = cum2.length/2; cum2.splice(cum2.length, 0,
		1,1, 0,1, 0,0, 1,0,
	); len2.unitSquare = cum2.length/2 - beg2.unitSquare;

	beg2.roundTouch = cum2.length/2;
	for (var i = 0; i < 36; i++) {
		cum2.splice(cum2.length, 0,
			touchRadius*Math.sin(i/18*Math.PI),
			touchRadius*Math.cos(i/18*Math.PI));
	}
	len2.roundTouch = cum2.length/2 - beg2.roundTouch;

	beg2.squareTouch = cum2.length/2; cum2.splice(cum2.length, 0,
		 touchRadius-.5,  touchRadius-.5,
		-touchRadius+.5,  touchRadius-.5,
		-touchRadius+.5, -touchRadius+.5,
		 touchRadius-.5, -touchRadius+.5,
	); len2.squareTouch = cum2.length/2 - beg2.squareTouch;

	beg2.roundMouse = cum2.length/2;
	for (var i = 0; i < 36; i++) {
		cum2.splice(cum2.length, 0,
			clickRadius*Math.sin(i/18*Math.PI),
			clickRadius*Math.cos(i/18*Math.PI));
	}
	len2.roundMouse = cum2.length/2 - beg2.roundMouse;

	beg2.squareMouse = cum2.length/2; cum2.splice(cum2.length, 0,
		 clickRadius-.5,  clickRadius-.5,
		-clickRadius+.5,  clickRadius-.5,
		-clickRadius+.5, -clickRadius+.5,
		 clickRadius-.5, -clickRadius+.5,
	); len2.squareMouse = cum2.length/2 - beg2.squareMouse;

	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cum2), gl.STATIC_DRAW);


	// AUDIO INITIALIZATION

	var audioInit = false;
	var initState = 0;
	async function initAudio() {
		if (initState == 0) {
			ac = new AudioContext();
			initState = 1;
		} else if (initState == 1) {
			await ac.audioWorklet.addModule(
				"data:application/javascript;base64," +
				btoa(`
            class AudioProcessor extends AudioWorkletProcessor {
              constructor() {
                super();
                this.lastClick = 0;
                this.wave = 0;
                this.fx = 0;
              }
              process (inputs, outputs, parameters) {
                const output = outputs[0];
                output.forEach(channel => {
                  for (var i = 0; i < channel.length; i++) {
                    var sfx = 0;
                    if (parameters['beep'][0] != this.fx) {
                      this.fx = parameters['beep'][0];
                      this.wave = 0;
                    }
                    switch (this.fx) {
                      case 1:
                        if (this.wave >= 200) this.wave = 0;
                        sfx = this.wave >= 100? -0.1 : 0.1;
                        break;
                      case 2:
                        if (this.wave >= 100) this.wave = 0;
                        sfx = this.wave >= 50? -0.1 : 0.1;
                        break;
                      case 3:
                        if (this.wave >= 50) this.wave = 0;
                        sfx = this.wave >= 25? -0.1 : 0.1;
                        break;
                    }
                    this.wave += 1;
                    var wind = (Math.random() * 2 - 1)
                      * (0.000 + (parameters['windspeed'][0]));
                    channel[i] =
                      wind +
                      0.5 * (parameters['click'].length > 1 ? parameters['click'][i] : parameters['click'][0]) + sfx;
                  }
                });
                return true;
              }
              static get parameterDescriptors() {
                return [
                  {
                    name: "windspeed",
                    automationRate: "a-rate",
                    defaultValue: 0,
                    minValue: 0,
                    maxValue: 1,
                  },
                  {
                    name: "click",
                    automationRate: "a-rate",
                    defaultValue: 0,
                    minValue: 0,
                    maxValue: 1,
                  },
                  {
                    name: "beep",
                    automationRate: "k-rate",
                    defaultValue: 0,
                    minValue: 0,
                    maxValue: 1,
                  },
                ];
              }
            }
            registerProcessor('audio-processor', AudioProcessor);
				`));

			var source = ac.createBufferSource();
			var processor = ac.createScriptProcessor(2048);
			source.start();
			initState = 2;
		} else if (initState == 2) {
			const audioNode = new AudioWorkletNode(ac, 'audio-processor');
			audioNode.connect(ac.destination);
			clickSound = audioNode.parameters.get('click');
			beepSound = audioNode.parameters.get('beep');
			windSound = audioNode.parameters.get('windspeed');
			initState = 3;
			audioInit = true;
		}
	}

	// START PROCESSING EVENTS
	if (root) rootViewport = root;

function hideAllTextInputs() {
	kbalpha.style.display = 'none';
	kbnum.style.display = 'none';
	kbnext.style.display = 'none';
	kbprev.style.display = 'none';
}

	// Add event listeners.
	// NOTE: Some events are used to trigger audio initialization.
	window.addEventListener("resize",
		function(e) { resizeCanvas(); }, false); resizeCanvas();
	window.requestAnimationFrame(refresher);
/*
	kbalpha.addEventListener("keydown",
		function(e) {
			var g = inputGad;
			if (g && g.specialKeys && g.specialKeys.includes(e.key)) {
				e.preventDefault();
				if (g.specialFunc) g.specialFunc.call(g, e);
			} else if (g && g.specialCodes && g.specialCodes.includes(e.code)) {
				e.preventDefault();
				if (g.specialFunc) g.specialFunc.call(g, e);
			} else if (g && e.key.length == 1 && g.limitChars && !g.limitChars.includes(e.key)) {
				e.preventDefault();
				beep();
			} else if (!inputSelected && g && e.key.length == 1
			&& g.limitLenFunc && g.limitLenFunc()) {
				e.preventDefault();
				beep();
			}
		  inputSelected = false;
		}, false);
	kbalpha.addEventListener("input",
		function(e) {
//console.log('kbalpha.input');
			var g = inputGad;
			g.text = kbalpha.value;
			if (g.textFunc) g.textFunc.call(g);
		  inputSelected = false;
		}, false);
	kbalpha.addEventListener("blur",
		function(e) {
//console.log('kbalpha.blur');
			var g = inputGad;
			kbalpha.style.display = 'none';
			if (g && g.textEndFunc) g.textEndFunc.call(g);
			inputGadPrev = g;
			inputGad = undefined;
		  inputSelected = false;
		}, false);
	kbnum.addEventListener("keydown",
		function(e) {
			var g = inputGad;
			if (kbnum.value == '00') kbnum.value = '0';
			if (g && g.specialKeys && g.specialKeys.includes(e.key)) {
				e.preventDefault();
				if (g.specialFunc) g.specialFunc.call(g, e);
			} else if (g && g.specialCodes && g.specialCodes.includes(e.code)) {
				e.preventDefault();
				if (g.specialFunc) g.specialFunc.call(g, e);
			} else if (g && e.key.length == 1 && g.limitChars && !g.limitChars.includes(e.key)) {
				e.preventDefault();
				beep();
			} else if (!inputSelected && g && e.key.length == 1
			&& g.limitLenFunc && g.limitLenFunc()) {
				e.preventDefault();
				beep();
			}
		  inputSelected = false;
		}, false);
	kbnum.addEventListener("input",
		function(e) {
//console.log('kbnum.input', e);
			var g = inputGad;
			g.text = kbnum.value;
			if (g.textFunc) g.textFunc.call(g);
		  inputSelected = false;
		}, false);
	kbnum.addEventListener("blur",
		function(e) {
//console.log('kbnum.blur', inputGad, e);
			var g = inputGad;
			kbnum.style.display = 'none';
			if (g && g.textEndFunc) g.textEndFunc.call(g);
			inputGadPrev = g;
			inputGad = undefined;
		  inputSelected = false;
		}, false);
	kbnext.addEventListener("focus",
		function(e) {
//console.log('kbnext.focus');
			var g = inputGadPrev;
			hideAllTextInputs();
			inputGad = undefined;
			if (g && g.textNextFunc) g.textNextFunc.call(g);
		}, false);
	kbprev.addEventListener("focus",
		function(e) {
//console.log('kbprev.focus');
			var g = inputGadPrev;
			hideAllTextInputs();
			inputGad = undefined;
			if (g && g.textPrevFunc) g.textPrevFunc.call(g);
		}, false);
*/
	canvas.addEventListener("touchend",
		function(e) { eventHandler(e, 'touches'); }, false);
	canvas.addEventListener("pointerdown",
		function(e) {
			if (!audioInit) initAudio();
			e.preventDefault();
			eventHandler(e, 'down');
		}, false);
	canvas.addEventListener("pointermove",
		function(e) { e.preventDefault(); eventHandler(e, 'move'); }, false);
	canvas.addEventListener("pointerup",
		function(e) {
			if (!audioInit) initAudio();
			e.preventDefault();
			eventHandler(e, 'up');
		}, false);
	canvas.addEventListener("contextmenu",
		function(e) { e.preventDefault(); }, false);
	canvas.addEventListener("wheel",
		function(e) { e.preventDefault(); eventHandler(e, 'wheel'); }, false);
	document.addEventListener('paste', function(e) {
		var g = inputGad;
		if (g && g.pasteFunc) {
			g.pasteFunc.call(g, e);
		}
	});
	document.addEventListener('keydown', function(e) {
		var g = inputGad;
		if (g && g.keydownFunc) {
			g.keydownFunc.call(g, e);
		}
/*
		if (e.key == 'Enter' && g && g.textNextFunc) {
			e.preventDefault();
			g.textNextFunc.call(g);
		}
*/
	});
}

  function setDebugFlags(debug, cont) { showdebug=!!debug; continuous=!!cont; }
  function beep(type = '') {
		if (!beepSound) return;
		switch (type) {
		case 'qr-scan':
			beepSound.setValueAtTime(2, ac.currentTime);
			beepSound.setValueAtTime(3, ac.currentTime+0.05);
			beepSound.setValueAtTime(0, ac.currentTime+0.1);
			break;
		case 'qr-part':
			beepSound.setValueAtTime(2, ac.currentTime);
			beepSound.setValueAtTime(0, ac.currentTime+0.05);
			break;
		case 'click':
			clickSound.setValueAtTime(0.1, ac.currentTime);
			clickSound.setValueAtTime(0, ac.currentTime+0.001);
			break;
		default:
			beepSound.setValueAtTime(1, ac.currentTime);
			beepSound.setValueAtTime(0, ac.currentTime+0.1);
		}
	};

  return {
    initialize: initialize,
    start: start,
		pushRoot: pushRoot,
		popRoot: popRoot,
    setDebugFlags: setDebugFlags,
    getContext: getContext,
    getPointerRadius: getPointerRadius,
    isMouseEnabled: isMouseEnabled,
		getInputGad: getInputGad,
		beginInput: beginInput,
		endInput: endInput,
		setImage: setImage,
		drawImage: drawImage,
		beep: beep,
    View: View,
    DividerView: DividerView,
    SliceView: SliceView,
    PagesView: PagesView,
		PopupView: PopupView,
    ViewOverlay: ViewOverlay,
    ViewMultiverse: ViewMultiverse,
    ViewPicker: ViewPicker,
    Gadget: Gadget,
    MatrixGadget: MatrixGadget,
    SwipeGadget: SwipeGadget,
    MiddleDividerGadget: MiddleDividerGadget,
    GAF_CLICKABLE: GAF_CLICKABLE,
    GAF_HOLDABLE: GAF_HOLDABLE,
    GAF_CONTEXTMENU: GAF_CONTEXTMENU,
    GAF_STRETCHABLE: GAF_STRETCHABLE,
    GAF_DRAGGABLE_UPDOWN: GAF_DRAGGABLE_UPDOWN,
    GAF_DRAGGABLE_LEFTRIGHT: GAF_DRAGGABLE_LEFTRIGHT,
    GAF_DRAGGABLE: GAF_DRAGGABLE,
    GAF_SWIPEABLE_UPDOWN: GAF_SWIPEABLE_UPDOWN,
    GAF_SWIPEABLE_LEFTRIGHT: GAF_SWIPEABLE_LEFTRIGHT,
    GAF_SWIPEABLE: GAF_SWIPEABLE,
    GAF_SCROLLABLE_UPDOWN: GAF_SCROLLABLE_UPDOWN,
    GAF_SCROLLABLE_LEFTRIGHT: GAF_SCROLLABLE_LEFTRIGHT,
    GAF_SCROLLABLE: GAF_SCROLLABLE,
    GAF_SCALABLE: GAF_SCALABLE,
    GAF_ROTATABLE: GAF_ROTATABLE,
    GAF_PINCHABLE: GAF_PINCHABLE,
    GAF_NUMINPUT: GAF_NUMINPUT,
    GAF_TEXTINPUT: GAF_TEXTINPUT,
		GAF_GONEXT: GAF_GONEXT,
    GAF_ALL: GAF_ALL,
    HitList: HitList,
    LayoutState: LayoutState,
  };
})();
/* Convenience API to wrap the browser-internal barcode scanner function.
 *
 * Description:
 *
 *   This encapsulation handles creation of the barcode scanner object and the video
 *   element and all of the necessary wiring, so that all the user has to do is
 *   supply the barcode handler and say when to begin/end scanning.
 *
 * Usage:
 *
 *   s = BarcodeScanner.beginSession( barcode => console.log(barcode.rawValue) );
 *
 *   BarcodeScanner.endSession(s);
 *
 * Optional:
 *
 *   if (BarcodeScanner.present) ... // checks browser support
 *
 *   if (BarcodeScanner.active) ... // checks for active session(s)
 *
 */

var BarcodeScanner = (function() {

	var mBarcodeDetector = undefined;
	var mVideo = undefined;
	var mCameraId = '';

	const sessions = []; var sessionCounter = 0;

	function present() { return !!("BarcodeDetector" in window); }
	function videoElement() { return mVideo; }

	var init = false;
	var scanning = false;
	var detectorReady = false;
	var streamReady = false;
	function checkReadiness() {
		if (detectorReady && streamReady) {
			scanning = true;
			setTimeout(barcodeScannerFunc, 100);
		}
	}

	function barcodeScannerFunc() {
		mBarcodeDetector
			.detect(mVideo)
			.then((barcodes) => {
				barcodes.forEach((barcode) => {
					for (const s of sessions) {
						if (barcode.rawValue == s.lastScan && Date.now() - s.lastScanTime < 2000)
							continue;
						s.lastScan = barcode.rawValue;
						s.lastScanTime = Date.now();
						s.callback(barcode);
					}
				});
			})
			.catch(e => console.log(e));
		if (sessions.length > 0)
			setTimeout(barcodeScannerFunc, 100);
		else
			scanning = false;
	}

	function beginSession(callback) {
		if (!present()) return 0;
		if (sessions.length == 0) {
			if (!init) {
				init = true;
				BarcodeDetector.getSupportedFormats().then(f => {
					mBarcodeDetector = new BarcodeDetector({
						formats: ["upc_a","qr_code"],
					});
					detectorReady = true;
					checkReadiness();
				});
				mVideo = document.createElement('video');
				mVideo.style.display = 'none';
				document.body.appendChild(mVideo);
				mVideo.addEventListener("loadedmetadata", () => {
					mVideo.play();
					streamReady = true;
					checkReadiness();
				});
			}
			let mediaDevices = navigator.mediaDevices;
			var constraints;
			if (mCameraId != '') constraints = {
				video: { deviceId: { exact: mCameraId } },
				audio: false,
			}; else constraints = {
				video: { facingMode: 'environment' },
				audio: false,
			};
			mediaDevices.getUserMedia(constraints)
			.then((stream) => {
				mVideo.srcObject = stream;
			})
			.catch(e => console.log(e));
		}
		sessionCounter += 1;
		var s = {
			id: sessionCounter,
			callback: callback,
			lastScan: '', lastScanTime: 0,
		};
		sessions.push(s);
		return s.id;
	}

	function endSession(id) {
		if (!present()) return;
		for (var i=0; i<sessions.length; i++) {
			if (sessions[i].id == id) {
				sessions.splice(i, 1);
				break;
			}
		}
		if (sessions.length == 0) {
			if (mVideo.srcObject) {
				mVideo.srcObject.getTracks().forEach(function(track) {
					track.stop();
				});
			}
			streamReady = false;
		}
	}

	return {
		get present() { return present(); },
		get active() { return sessions.length > 0; },
		set cameraId(id) { mCameraId = id; },
		beginSession: beginSession,
		endSession: endSession,
	};
})();
// Top of module

var defaultFont, iconFont, dotMatrixFont, financeGraphicsFont, emojiFile;
var clickTapActive = ['begin-click','recover-click','begin-tap'];
var lang_db = {};

function main() {
	const canvas = document.querySelector('#app1');
	vp.initialize(canvas,
		document.getElementById('kb'),
		document.getElementById('numpad'),
		document.getElementById('next'),
		document.getElementById('prev'),
	);
	const gl = vp.getContext();

	df.glSet(gl);
	defaultFont.init();
	iconFont.init();
	dotMatrixFont.init();


	var v, g;
var db, dbNotifier

/*
if (false) { // wipe database for testing purposes
	const req = indexedDB.deleteDatabase("DB")
	req.onsuccess = (e) => {
		console.log('Database deleted.')
	}
	req.onerror = (e) => {
		console.log('Error deleting database.')
	}
}
*/

function openDatabase() {
	const dbreq = indexedDB.open("DB", 2)
	dbreq.onerror = (event) => {
		console.error(`Error requesting database`)
		console.error(event)
	}
	dbreq.onsuccess = (event) => {
//		console.log("Database opened")
		db = event.target.result
		db.onerror = (event) => {
			console.error(`Database error: ${event.target.errorCode}`)
		}
    db.transaction(["sales"], "readwrite").objectStore("sales").clear()
    db.transaction(["nostrmarket-orders"], "readwrite").objectStore("nostrmarket-orders").clear()
		dbNotifier(event)
	};
	dbreq.onupgradeneeded = (event) => {
		console.log(`Upgrading database`, event)
		const db = event.target.result
		var objectStore
		if (event.oldVersion < 1) {
			objectStore = db.createObjectStore("accounts")
			objectStore = db.createObjectStore("settings")
			objectStore = db.createObjectStore("sales", { autoIncrement: true })
			objectStore = db.createObjectStore("prices")
			objectStore = db.createObjectStore("inventory", { autoIncrement: true })
			objectStore = db.createObjectStore("barcodes")
		}
    if (event.oldVersion < 2) {
      objectStore = db.createObjectStore("nostrmarket-orders")
    }
	}
}

openDatabase()
class Convert {
  constructor() {
    throw new Error()
  }
  static currencies = [
    { app: '₿', LNbits: 'BTC' },
    { app: '₲', LNbits: 'PYG' },
    { app: '$', LNbits: 'USD' },
    { app: '€', LNbits: 'EUR' },
  ]
  static LNbitsCurrencyToAppCurrency(input) {
    for (const c of Convert.currencies) {
      if (c.LNbits == input) return c.app
    }
  }
  static AppCurrencyToLNbitsCurrency(input) {
    for (const c of Convert.currencies) {
      if (c.app == input) return c.LNbits
    }
  }
}
class ColorTheme {
	constructor() {

		// Colors that are generally theme-independent.
		this.uiPillOrange = [1, 0.55, 0.1, 1];
		this.uiLightningPurple = [0.5, 0, 1, 1];
		this.uiLightningYellow = [1, 0.9, 0, 1];
		this.uiFiatGreen = [112/255, 130/255, 56/255, 1];
		this.uiCoinSilver = [212/255, 212/255, 220/255, 1];
		this.uiCoinCopper = [0xb8/255, 0x73/255, 0x33/255, 1];
		this.uiBarcodeScannerBeam = [1,0,0, 1];
		this.uiErrorRed = [1,0,0, 1];
		this.uiSuccessGreen = [0,1,0, 1];

		// Colors that generally should be set for each theme.
		this.uiBackground			= [0,0,0, 1];
		this.uiForeground			= [1,1,1, 1];
		this.uiButton					= [0.7,0.7,0.7, 1];
		this.uiButtonSel			= [0.2,1.0,0.2, 1];
		this.uiButtonGhost		= [0.2,0.2,0.2, 1];
		this.uiVideoOverlayButton					= [1.0,1.0,1.0, 1];
		this.uiVideoOverlayButtonSel			= this.uiButtonSel;
		this.uiVideoOverlayButtonGhost		= [1.0,1.0,1.0, 0.33];
		this.uiLedger1				= [0.00,0.00,0.00, 1];
		this.uiLedger2				= [0.05,0.05,0.05, 1];
		this.uiSpeechCloud		= [0.05,0.05,0.05, 1];
		this.uiSilverLining		= [0.10,0.10,0.10, 1];
		this.uiReceiptBg			= [0.9,0.9,0.9, 1];
		this.uiReceiptText		= [0.2,0.2,0.2, 1];

		// Derived colors (can be overridden).
		// If this list is changed, the set function (below) must be updated to correspond.
		this.uiTextLabelArea	= this.uiButtonGhost;
		this.uiTextField			= this.uiBackground;
		this.uiTextFocus			= this.uiButtonSel;
		this.uiText						= this.uiForeground;
		this.uiTextLabel			= this.uiForeground;
		this.uiGhostText			= this.uiButton;

		// For the settings area
		this.uiSettingsBubble		= this.uiSilverLining;
		this.uiSettingsDivider	= this.uiButtonGhost;
		this.uiSettingsText			= this.uiForeground;
		this.uiSettingsSubText	= this.uiGhostText;
		this.uiSettingSelect		= this.uiButtonSel;

		// For the checkout panes

		// Data entry textbox
		Object.defineProperty(this, "uiDataEntryArea", { get : function () { return this.uiSettingsBubble; } } );
		Object.defineProperty(this, "uiDataEntryText", { get : function () { return this.uiText; } } );
		Object.defineProperty(this, "uiDataEntryGhostText", { get : function () { return blend(this.uiDataEntryText, this.uiDataEntryArea, 0.1); } } );
		Object.defineProperty(this, "uiDataEntryCursor", { get : function () { return this.uiPillOrange; } } );

		// Bill of items
		Object.defineProperty(this, "uiBillChargeText",				{ get : function () { return this.uiText; } } );
		Object.defineProperty(this, "uiBillCharge",						{ get : function () { return colorize(this.uiBillChargeText, this.uiBackground, this.uiSettingsBubble); } } );
		Object.defineProperty(this, "uiBillChargeTextLight",	{ get : function () { return blend(this.uiBillChargeText, this.uiBillCharge, 0.5); } } );
		Object.defineProperty(this, "uiBillCredit",						{ get : function () { return [1,1,0,1]; } } );
		Object.defineProperty(this, "uiBillCreditText",				{ get : function () { return [0,0,0,1]; } } );
		Object.defineProperty(this, "uiBillCreditTextLight",	{ get : function () { return blend(this.uiBillCreditText, this.uiBillCredit, 0.5); } } );

		// Subtotal bar
		Object.defineProperty(this, "uiBillSubtotalArea",				{ get : function () { return this.uiDataEntryArea; } } );
		Object.defineProperty(this, "uiBillSubtotalText",				{ get : function () { return this.uiDataEntryText; } } );
		Object.defineProperty(this, "uiBillSubtotalLabel",			{ get : function () { return this.uiButton; } } );
		Object.defineProperty(this, "uiBillSubtotalLabelGhost",	{ get : function () { return this.uiButtonGhost; } } );



	}
	get uiBackgroundPattern() { return colorize([0.5,0.5,0.5,1], this.uiBackground, this.uiSettingsBubble); }
	set(variable, value) {

		// Helper.
		const me = this;
		function subset(variable, sub, value) {
			if (me[sub] == me[variable]) me[sub] = value;
		}

		// This switch block must correspond to derived colors list.
		switch (variable) {
		case 'uiButtonGhost':
			subset(variable, 'uiTextLabelArea', value);
			subset(variable, 'uiSettingsDivider', value);
			break;
		case 'uiBackground': subset(variable, 'uiTextField', value); break;
		case 'uiButtonSel':
			subset(variable, 'uiTextFocus', value);
			subset(variable, 'uiSettingSelect', value);
			break;
		case 'uiSilverLining': subset(variable, 'uiSettingsBubble', value); break;
		case 'uiGhostText': subset(variable, 'uiSettingsSubText', value); break;
		case 'uiForeground':
			subset(variable, 'uiText', value);
			subset(variable, 'uiTextLabel', value);
			subset(variable, 'uiSettingsText', value);
			break;
		case 'uiButton': subset(variable, 'uiGhostText', value); break;
		}

		// Finally, do what we came for.
		this[variable] = value;
	}
}
class Configuration {
	constructor() {}
	log() {
		function listGetters (instance) {
			return Object.entries(
				Object.getOwnPropertyDescriptors(
				  Reflect.getPrototypeOf(instance)
				)
			)
			.filter(e => typeof e[1].get === 'function' && e[0] !== '__proto__')
			.map(e => e[0]);
		}
		let getters = listGetters(this);
		console.groupCollapsed('Configuration');
		for (let getter in getters) {
			var str = getters[getter];
			if (str == 'themeColors') console.log(str, colorsettings.themelist.list[colorsettings.themelist.index].title);
			else if (str == 'themeGraphics') console.log(str, this.themeGraphics.title);
			else if (str.startsWith('themeGraphics')) {}
			else if (str.startsWith('wallet')) {}
			else if (this[str] === '') {}
			else console.log(str, this[str]);
		}
		console.groupEnd();
	}
	hasCents(c) {
		return ['$', '€'].includes(c);
	}
	getDenoms(c) {
		switch (c) {
		case '$': return [
			{icon: "\x18", color: config.themeColors.uiFiatGreen , value: 10000, label: "100"},
			{icon: "\x18", color: config.themeColors.uiFiatGreen , value:  5000, label:  "50"},
			{icon: "\x18", color: config.themeColors.uiFiatGreen , value:  2000, label:  "20"},
			{icon: "\x18", color: config.themeColors.uiFiatGreen , value:  1000, label:  "10"},
			{icon: "\x18", color: config.themeColors.uiFiatGreen , value:   500, label:   "5"},
			{icon: "\x18", color: config.themeColors.uiFiatGreen , value:   100, label:   "1"},
			{icon: "\x1B", color: config.themeColors.uiCoinSilver, value:    25, label:  "25"},
			{icon: "\x19", color: config.themeColors.uiCoinSilver, value:    10, label:  "10"},
			{icon: "\x1A", color: config.themeColors.uiCoinSilver, value:     5, label:   "5"},
			{icon: "\x19", color: config.themeColors.uiCoinCopper, value:     1, label:   "1"},
			];
		case '₲': return [
			{icon: "\x18", color: config.themeColors.uiFiatGreen , value: 100000},
			{icon: "\x18", color: config.themeColors.uiFiatGreen , value:  50000},
			{icon: "\x18", color: config.themeColors.uiFiatGreen , value:  20000},
			{icon: "\x18", color: [200/255,  90/255, 80/255, 1]  , value:  10000},
			{icon: "\x18", color: [200/255,  60/255, 60/255, 1]  , value:   5000},
			{icon: "\x18", color: [120/255, 112/255, 112/255, 1] , value:   2000},
			{icon: "\x1B", color: config.themeColors.uiCoinSilver, value:   1000},
			{icon: "\x1A", color: config.themeColors.uiCoinSilver, value:    500},
			{icon: "\x19", color: config.themeColors.uiCoinSilver, value:    100},
			];
		}
		return [];
	}
	getLeeway(c) {
		const ds = this.getDenoms(c);
		const d = ds[ds.length-1];
		return d.value/2;
	}
	get debugBuild() { return releasebuild != true; }
	get showChangeBreakdown() { try { return currencysettings.showchange.state && this.cashCurrency != 'none'; } catch (e) {} }
	get mainCurrency() { try { return maincurrency.list.value; } catch (e) {} }
	get cashCurrency() { try { return cashcurrency.list.value; } catch (e) {} }
	get lightningEnabled() { try { return maincurrency.list.value == '₿' || currencysettings.enablelightning.state; } catch (e) {} }
	get businessName() { try { return accounts.current().title; } catch (e) {} }
	get businessAddress() { try { return accountsettings.locaddress.value; } catch (e) {} }
	get businessCity() { try { return accountsettings.loccity.value; } catch (e) {} }
	get businessState() { try { return accountsettings.locstate.value; } catch (e) {} }
	get businessPostalCode() { try { return accountsettings.locpostalcode.value; } catch (e) {} }
	get businessTelephone() { try { return accountsettings.telephone.value; } catch (e) {} }
	get businessTaxId() { try { return accountsettings.taxid.value; } catch (e) {} }
	get businessLicenseNumber() { try { return accountsettings.license.value; } catch (e) {} }
	get businessLicenseValidFrom() {
		try { return accountsettings.licensevalidfrom.value; } catch (e) {}
	}
	get businessLicenseValidTill() {
		try { return accountsettings.licensevalidtill.value; } catch (e) {}
	}
	get lastInvoiceNum() { return 0; }
	get cashReg() { try { return accountsettings.cashreg.value; } catch (e) {} }
	get cashier() { try { return accountsettings.cashier.value; } catch (e) {} }
	get barcodeScanningEnabled() { try { return camerasettings.itemscan.state; } catch (e) {} }
	get lightningScanningEnabled() { try { return camerasettings.lnscan.state; } catch (e) {} }
	get themeColors() {
		try { var g = colorsettings.themelist; return g.list[g.index].theme; } catch (e) { return new DefaultLightTheme() }
	}
	get themeGraphics() {
		var g = colorsettings.texturelist;
		try { return g.list[g.index]; } catch (e) {}
	}
	get themeGraphicsFont() {
		var g = colorsettings.texturelist;
		try { return g.list[g.index].font; } catch (e) {}
	}
	get themeGraphicsPattern() {
		var g = colorsettings.texturelist;
		try { return g.list[g.index].pattern; } catch (e) {}
	}
	get themeGraphicsScale() {
		var g = colorsettings.texturelist;
		try { return g.list[g.index].scale; } catch (e) {}
	}
/*
	get wallet() { try {
		switch (wallettypes[walletsettings.typelist.index]) {
		case 'LNbits compatible': return new LNbitsWallet(); break;
		default: return new Wallet();
		}
	} catch (e) {console.error(e)} }
*/
	get wallet() { try { return walletsettings.wallet; } catch (e) {console.error(e)} }
	get walletType() { try { return wallettypes[walletsettings.typelist.index]; } catch (e) {} }
	get walletLNbitsURL() { try { return walletsettings.lnbitsurl.value; } catch (e) {} }
	get walletLNbitsKey() { try { return walletsettings.lnbitskey.value; } catch (e) {} }
	get walletStrikeURL() { try { return walletsettings.strikeurl.value; } catch (e) {} }
	get walletStrikeKey() { try { return walletsettings.strikekey.value; } catch (e) {} }
	get walletCoinosURL() { try { return walletsettings.coinosurl.value; } catch (e) {} }
	get walletCoinosKey() { try { return walletsettings.coinoskey.value; } catch (e) {} }
  
  get stallKeys() {
    if (pricelisttypes[pricelistsettings.typelist.index] !== 'NostrMarket compatible') return
    return {
      url: pricelistsettings.nostrmarketurl.value,
      key: pricelistsettings.nostrmarketwalletkey.value,
      stall: nostrmarketstall.list.value,
    }
  }

  get priceList() { return PriceList.instance || new PriceList() }
}
class Wallet {
	constructor() {}

	getConversionRate(amt, from, to, callback) {
		console.groupCollapsed(this.constructor.name+'.getConversionRate(',amt,from,to,'...)');

		if (from == to) { callback(1); return; }

		const asyncLogic = async () => {
			let myJson = '';
			let amt_ = amt/(config.hasCents(from)?100:1);
			let from_ = from;
			let to_ = to;

			myJson = {};
			myJson[from_] = amt;
			myJson[to_] = amt * (Math.random()*1.5 + 0.5); // TODO configure what value to put here

			let convRate = 0;
			if (myJson && myJson[from_] && myJson[to_]) {
				convRate = (myJson[to_] * (config.hasCents(to)?100:1)) / (myJson[from_] * (config.hasCents(from)?100:1));
			}
			callback(convRate);
		}
		asyncLogic();

		console.groupEnd();
	}

	generateInvoice(sats, invoiceCallback) {
		console.groupCollapsed(this.constructor.name+'.generateInvoice(',sats,'...)');

		total_sat = sats;
		if (total_sat <= 0 || total_sat != (+total_sat).toString()) {
			console.error('Amount sanity check failed:', total_sat);
			vp.beep('bad');
			return;
		}

		console.log('wallet not configured to generate invoice');
		invoiceCallback();

		console.groupEnd();
	}

	checkInvoice(checkingId, callback) {
		console.groupCollapsed(this.constructor.name+'.checkInvoice(',checkingId,'...)');

		console.log('wallet not configured to generate invoice');
		let json = '';

		json = { detail: "Payment does not exist." };

		json = { paid: false, preimage: "0000000000000000000000000000000000000000000000000000000000000000", details: { bolt11: "lnbc110n1pjv99kzsp57pjaz7d4pcyq44mqu39tk47jxw78fz3dp0dfefer76v5na3jnj8qpp5xxvattfa4dtgqdzea35lc8cf82qlgdnx8ps0txvs5wx5s20mhppsdqjd4ujqcn4wd5kuetnwvxqzjccqpjrzjq027t9tsc6jn5ve2k6gnn689unn8h239juuf9s3ce09aty6ed73t5z7nqsqqsygqqyqqqqqqqqqqztqq9q9qxpqysgqq58tj820ddffdc4fk82flnl3gj9sjhdt5gd57lgsl0kc40nqe4an50lq9w6p9ly5pmz0n69d9a40qdsmlae8f4scz2lg79zwrq867tspdd8rjz", checking_id: "3199d5ad3dab56803459ec69fc1f093a81f436663860f59990a38d4829fbb843", expiry: 1690474778, extra: {}, fee: 0, memo: "my business", payment_hash: "3199d5ad3dab56803459ec69fc1f093a81f436663860f59990a38d4829fbb843", pending: true, preimage: "0000000000000000000000000000000000000000000000000000000000000000", time: 1690474178, wallet_id: "0c2a142d0edf428e8a7d3379613fc424", webhook: null, webhook_status: null, } };

		json = { paid: (Math.random()>0.5)?true:false, preimage: "0000000000000000000000000000000000000000000000000000000000000000", details: { bolt11: "lnbc110n1pjv99kzsp57pjaz7d4pcyq44mqu39tk47jxw78fz3dp0dfefer76v5na3jnj8qpp5xxvattfa4dtgqdzea35lc8cf82qlgdnx8ps0txvs5wx5s20mhppsdqjd4ujqcn4wd5kuetnwvxqzjccqpjrzjq027t9tsc6jn5ve2k6gnn689unn8h239juuf9s3ce09aty6ed73t5z7nqsqqsygqqyqqqqqqqqqqztqq9q9qxpqysgqq58tj820ddffdc4fk82flnl3gj9sjhdt5gd57lgsl0kc40nqe4an50lq9w6p9ly5pmz0n69d9a40qdsmlae8f4scz2lg79zwrq867tspdd8rjz", checking_id: "3199d5ad3dab56803459ec69fc1f093a81f436663860f59990a38d4829fbb843", expiry: 1690474778, extra: {}, fee: 0, memo: "my business", payment_hash: "3199d5ad3dab56803459ec69fc1f093a81f436663860f59990a38d4829fbb843", pending: true, preimage: "0000000000000000000000000000000000000000000000000000000000000000", time: 1690474178, wallet_id: "0c2a142d0edf428e8a7d3379613fc424", webhook: null, webhook_status: null, } };

		console.log('faked json', json);
		callback(json);

		console.groupEnd();
	}

	readInvoice(invoice, callback) {
		console.groupCollapsed(this.constructor.name+'.readInvoice(',invoice.substr(0,20),'..., ...)');
		const asyncLogic = async () => {
			const desc = 'lightning invoice';
			var msats = 'some';
			var temp = invoice.substr(4,20);
			var digs = '';
			while (temp != '' && "0123456789".includes(temp.substr(0,1))) {
				digs = digs + temp.substr(0,1);
				temp = temp.substr(1);
			}
			if (digs != '' && temp != '') {
				var n = +digs;
				switch (temp.substr(0,1).toLowerCase()) {
				case 'm': msats = Math.round(n*(0.001*100000000*1000)); break;
				case 'u': msats = Math.round(n*(0.000001*100000000*1000)); break;
				case 'n': msats = Math.round(n*(0.000000001*100000000*1000)); break;
				case 'p': msats = Math.round(n*(0.000000000001*100000000*1000)); break;
				default:
				}
			}
			const sats = Math.round(msats/1000);

			var temp = tr('pay {AMNT} sats for {DESC}');
			temp = temp.replace('{AMNT}', isNumber(msats)? Math.round(msats/1000).toString(): tr(msats) );
			temp = temp.replace('{DESC}', tr(desc));
			temp = icap(temp);

			if (isNumber(msats)) {
				callback(sats, temp);
			} else {
				callback(msats, temp);
			}
		}
		asyncLogic();
		console.groupEnd();
	}

	payInvoice(invoice, callback) {
		console.groupCollapsed(this.constructor.name+'.payInvoice(',invoice.substr(0,20),'..., ...)');
		console.log('wallet not configured to pay invoice');
		callback(false);
		console.groupEnd();
	}

}class PriceList {
	constructor() {
    if (PriceList.instance) return PriceList.instance

    this.texture = initTexture(gl)
    this.clear()
    PriceList.instance = this
  }

  get length() { return 0 }
  get thumbnails() { return this.texture }
  get thumbnailData() { return this.emojiData }
  get thumbnailsPerRow() { return this.cols }
  get thumbnailsPerColumn() { return this.rows }

  clear() {
    this.priceData = []
    this.emojiData = []
    this.rows = 0
    this.cols = 0
  }

  setPriceData(uid, name, currency, price, size, unit) {
    this.priceData = this.priceData.filter(item => item.uid !== uid)
    this.priceData.push({ uid, name, currency, price, size, unit })
  }

  getPriceData(text) {
    for (const item of this.priceData) {
      if (item.uid == text) return item
    }
    for (const item of this.priceData) {
      if (item.name == text) return item
    }
  }

  setEmojiDefault() {
    console.log('loading PriceList texture')
    this.clear()
    this.rows = 57
    this.cols = 57
    const emojiEl = document.createElement('img')
    const ref = this
    emojiEl.addEventListener('load', function() {
      console.log('updating PriceList texture', ref.texture)
      updateTexture(gl, ref.texture, emojiEl)
      gl.generateMipmap(gl.TEXTURE_2D)
      // emojiReady = true
      // loadCheck()
      console.log('loaded PriceList texture')
    })
    emojiEl.src = emojiFile
    this.priceData = []
    this.emojiData = [
      { x:  6, y: 29, category: 'food', label: 'tomato', },
      { x: 55, y: 49, category: 'food', label: 'green bell pepper', },
      { x: 55, y: 50, category: 'food', label: 'yellow bell pepper', },
      { x: 55, y: 51, category: 'food', label: 'orange bell pepper', },
      { x: 55, y: 52, category: 'food', label: 'red bell pepper', },
      { x: 44, y: 13, category: 'food', label: 'onion', },
      { x: 44, y: 12, category: 'food', label: 'garlic', },
      { x: 55, y: 54, category: 'food', label: 'potato', },
      { x:  6, y: 56, category: 'food', label: 'sweet potato', },
      { x:  6, y: 14, category: 'food', label: 'chilipepper', },
      { x:  6, y: 30, category: 'food', label: 'eggplant', },
      { x: 42, y:  2, category: 'food', label: 'greens', },

      { x:  7, y: 21, category: 'food', label: 'milk', },
      { x: 44, y:  8, category: 'food', label: 'cheese', },
      { x: 44, y: 16, category: 'food', label: 'butter', },
  //	{ x:  7, y: 18, category: 'food', label: 'fried egg', },
      { x: 55, y: 53, category: 'food', label: 'eggs', },

      { x:  6, y: 54, category: 'food', label: 'bread', },
      { x:  6, y: 22, category: 'food', label: 'wheat', },
      { x:  6, y: 21, category: 'food', label: 'corn', },
  //	{ x:  7, y: 30, category: 'food', label: 'popcorn', },

      { x: 42, y:  3, category: 'food', label: 'mango', },
      { x:  6, y: 33, category: 'food', label: 'watermelon', },
      { x:  6, y: 37, category: 'food', label: 'pineapple', },
      { x:  6, y: 36, category: 'food', label: 'banana', },
      { x:  6, y: 34, category: 'food', label: 'orange', },
      { x:  6, y: 35, category: 'food', label: 'lemon', },
      { x:  6, y: 38, category: 'food', label: 'red apple', },
      { x:  6, y: 39, category: 'food', label: 'green apple', },
      { x:  6, y: 40, category: 'food', label: 'pear', },
      { x:  6, y: 31, category: 'food', label: 'grapes', },
      { x:  6, y: 32, category: 'food', label: 'cantaloupe', },
      { x:  6, y: 41, category: 'food', label: 'peach', },
      { x:  6, y: 42, category: 'food', label: 'cherries', },
      { x:  6, y: 43, category: 'food', label: 'strawberry', },

      { x:  6, y: 46, category: 'food', label: 'meat', },
      { x:  6, y: 47, category: 'food', label: 'chicken leg', },
      { x:  7, y:  3, category: 'food', label: 'shrimp', },

      { x:  7, y: 15, category: 'food', label: 'cake', },
      { x:  7, y: 33, category: 'food', label: 'birthday cake', },
      { x:  7, y:  5, category: 'food', label: 'ice cream', },
      { x:  7, y: 10, category: 'food', label: 'chocolate bar', },
      { x:  7, y: 11, category: 'food', label: 'candy', },
      { x:  7, y: 12, category: 'food', label: 'lollipop', },
      { x:  7, y:  9, category: 'food', label: 'cookie', },
      { x:  7, y: 14, category: 'food', label: 'honey', },

      { x: 44, y: 18, category: 'food', label: 'ice', },
      { x: 44, y: 17, category: 'food', label: 'terere', },
      { x:  7, y: 20, category: 'food', label: 'tea', },
      { x: 53, y:  0, category: 'food', label: 'coffee', },
      { x:  7, y: 25, category: 'food', label: 'beer', },
      { x:  7, y: 22, category: 'food', label: 'wine', },
      { x:  7, y: 29, category: 'food', label: 'champaigne', },
      { x: 44, y: 11, category: 'food', label: 'juice carton', },
      { x:  7, y: 27, category: 'food', label: 'baby formula', },

      { x: 44, y: 10, category: 'food', label: 'salt', },
      { x: 42, y:  1, category: 'food', label: 'can', },
      { x: 51, y: 39, category: 'food', label: 'bottle', },

      { x:  7, y: 17, category: 'food', label: 'soup', },
      { x:  6, y: 45, category: 'food', label: 'pizza', },
      { x: 42, y:  0, category: 'food', label: 'sandwich', },
      { x:  6, y: 44, category: 'food', label: 'hamburger', },
      { x:  6, y:  5, category: 'food', label: 'hotdog', },
      { x:  6, y:  6, category: 'food', label: 'taco', },
      { x:  6, y:  7, category: 'food', label: 'burrito', },

      { x:  5, y: 21, category: 'household', label: 'umbrella', },
      { x: 52, y: 51, category: 'household', label: 'umbrella', },
      { x:  7, y: 19, category: 'household', label: 'silverware', },
      { x:  7, y: 28, category: 'household', label: 'tableware', },
      { x:  7, y: 32, category: 'household', label: 'giftbox', },
      { x:  7, y: 44, category: 'household', label: 'balloon', },
      { x:  7, y: 54, category: 'household', label: 'backpack', },
      { x: 51, y: 43, category: 'household', label: 'teddy', },
      { x: 51, y: 44, category: 'household', label: 'broom', },
      { x: 51, y: 46, category: 'household', label: 'toilet paper', },
      { x: 51, y: 47, category: 'household', label: 'bar soap', },
      { x: 51, y: 48, category: 'household', label: 'sponge', },
      { x: 52, y:  5, category: 'household', label: 'chair', },
      { x:  6, y:  9, category: 'plant', label: 'seedling', },
      { x:  6, y: 10, category: 'plant', label: 'pinetree', },
      { x:  6, y: 11, category: 'plant', label: 'shadetree', },
      { x:  6, y: 12, category: 'plant', label: 'palmtree', },
      { x:  6, y: 13, category: 'plant', label: 'cactus', },
      { x:  6, y: 15, category: 'plant', label: 'tulip', },
      { x:  6, y: 16, category: 'plant', label: 'gardenia', },
      { x:  6, y: 17, category: 'plant', label: 'rose', },
      { x:  6, y: 18, category: 'plant', label: 'daffodil', },
      { x:  6, y: 19, category: 'plant', label: 'sunflower', },
      { x:  6, y: 20, category: 'plant', label: 'panzie', },
      { x:  6, y: 23, category: 'plant', label: 'leaves', },
      { x:  8, y:  1, category: 'tech', label: 'microphone', },
      { x:  8, y: 10, category: 'tech', label: 'microphone', },
      { x:  8, y: 13, category: 'tech', label: 'headphones', },
      { x:  8, y: 38, category: 'sports', label: 'basketball', },
      { x: 10, y: 35, category: 'sports', label: 'volleyball', },
      { x: 53, y: 56, category: 'sports', label: 'soccer ball', },
      { x: 54, y:  0, category: 'sports', label: 'baseball', },
      { x: 14, y:  6, category: 'clothing', label: 'hat', },
      { x: 14, y:  7, category: 'clothing', label: 'glasses', },
      { x: 14, y:  8, category: 'clothing', label: 'dress shirt', },
      { x: 14, y:  9, category: 'clothing', label: 'casual shirt', },
      { x: 14, y: 10, category: 'clothing', label: 'casual pants', },
      { x: 14, y: 11, category: 'clothing', label: 'sleeveless dress', },
      { x: 14, y: 14, category: 'clothing', label: 'blouse', },
      { x: 14, y: 18, category: 'clothing', label: 'casual shoe', },
      { x: 14, y: 19, category: 'clothing', label: 'sport shoe', },
      { x: 14, y: 20, category: 'clothing', label: 'high heel shoe', },
      { x: 14, y: 21, category: 'clothing', label: 'high heel sandal', },
      { x: 14, y: 22, category: 'clothing', label: 'high heel sandal', },
      { x: 14, y: 23, category: 'clothing', label: 'high heel boot', },
      { x: 51, y: 21, category: 'clothing', label: 'ball cap', },
      { x: 51, y: 22, category: 'clothing', label: 'scarf', },
      { x: 51, y: 23, category: 'clothing', label: 'gloves', },
      { x: 51, y: 24, category: 'clothing', label: 'coat', },
      { x: 51, y: 25, category: 'clothing', label: 'socks', },
      { x: 25, y: 18, category: 'category', label: 'barber', },
      { x: 25, y: 19, category: 'medical', label: 'syringe', },
      { x: 25, y: 20, category: 'medical', label: 'pill', },
      { x: 26, y:  6, category: 'financial', label: 'money bag', },
      { x: 26, y:  7, category: 'financial', label: 'currency exchange', },
      { x: 26, y:  9, category: 'financial', label: 'credit card', },
      { x: 55, y: 55, category: 'financial', label: 'lightning invoice', },
      { x: 54, y:  5, category: 'tools', label: 'pick', },
      { x: 55, y: 48, category: 'tools', label: 'barcode', },
    ];
  }

  loadNostrMarketData(url, key, stallId) {
    const loadKey = new Date()
    this._loadKey = loadKey
    if (!url || !key || !stallId) return

    const asyncLogic = async () => {
      this.clear()
      let stall, stallCurrency
      {
        console.log('searching for stall', key != '', stallId)
        const response = await fetch(url+'/stall?pending=false&api-key='+key, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
          },
        });
        const json = await response.json()
        console.log(json)
        json.map(e => {
          const { id, name, currency } = e
          if (id == stallId) {
            stall = name
            stallCurrency = currency
          }
        })
      }
      if (this._loadKey != loadKey) return
      const imageUrls = []
      {
        console.log('getting products for', stall, '(', stallId, ')')
        const response = await fetch(url+'/stall/product/'+stallId+'?pending=false&api-key='+key, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
          },
        });
        const json = await response.json()
        const tempList = []
        if (this._loadKey != loadKey) return
        this._emojiBase = Math.ceil(Math.sqrt(json.length))
        this.rows = this._emojiBase
        this.cols = this._emojiBase
        let xIter = 0, yIter = 0
        json.map(e => {
          const { id, name, price } = e
          const cur = Convert.LNbitsCurrencyToAppCurrency(stallCurrency)
          const amt = price
          tempList.push({ id, name, cur, amt, size: 1, unit: 'ea' })
          imageUrls.push(e.images[0])
          this.emojiData.push({ x: xIter, y: yIter, category: 'product', label: name, })
          xIter += 1
          if (xIter >= this._emojiBase) {
            xIter = 0
            yIter += 1
          }
        })
        for (const item of tempList) {
          this.setPriceData(item.id, item.name, item.cur, item.amt, item.size, item.unit)
        }
      }

      delete emojipane.lastBuilt
      delete emojipane.emojiPoints
      emojiShapes.build(this.emojiData, this._emojiBase, this._emojiBase, emojipane.emojiPoints)
      emojipane.queueLayout()

      {
        console.log('initializing texture')
        const emojiEl = document.createElement('canvas')
        const iconWidth = 96
        const textureWidth = this._emojiBase * iconWidth
        console.log('texture side', textureWidth)
        emojiEl.width = emojiEl.height = textureWidth
        const textureContext = emojiEl.getContext("2d")
        const textureImage = textureContext.createImageData(textureWidth, textureWidth);
        for (let i = 0; i < textureWidth; i += 1) {
          for (let j = 0; j < textureWidth; j += 1) {
            let index = (j * textureWidth + i) * 4
            textureImage.data[index + 0] = i/textureWidth*127+64
            textureImage.data[index + 1] = Math.floor(((i % iconWidth) + (j % iconWidth)) / 2)/iconWidth*127+64
            textureImage.data[index + 2] = j/textureWidth*127+64
            const r = Math.sqrt(((i % iconWidth) - iconWidth/2)**2 + ((j % iconWidth) - iconWidth/2)**2)
            const o = r - (iconWidth/2 - 2)
            textureImage.data[index + 3] = (0 < 0) ? 255 : (o > 1) ? 0 : 255 - (o * 255)
          }
        }
        textureContext.putImageData(textureImage, 0, 0)
        updateTexture(gl, this.texture, emojiEl)
        gl.generateMipmap(gl.TEXTURE_2D)

        {
          textureContext.imageSmoothingQuality = 'high'
          let pending = imageUrls.length
          const ref = this
          imageUrls.map((url, index) => {
            const img = document.createElement('img')
            img.crossOrigin ='anonymous'
            img.addEventListener('load', function() {
              if (ref._loadKey != loadKey) return
              console.log('updating icon from', img.src)
              let i = index % ref._emojiBase, j = Math.floor(index / ref._emojiBase)
              let targetWidth = iconWidth - 2, targetHeight = iconWidth - 2
              if (img.width > img.height) {
                targetHeight = targetWidth * img.height / img.width
              } else {
                targetWidth = targetHeight * img.width / img.height
              }
              textureContext.clearRect(i * iconWidth, j * iconWidth, iconWidth, iconWidth)
              textureContext.drawImage(img,
                i * iconWidth + Math.trunc((iconWidth-targetWidth)/2),
                j * iconWidth + Math.trunc((iconWidth-targetHeight)/2), targetWidth, targetHeight)
              i += 1
              if (i >= ref._emojiBase) {
                i = 0
                j += 1
              }
              updateTexture(gl, ref.texture, emojiEl)
              gl.generateMipmap(gl.TEXTURE_2D)
              emojipane.setRenderFlag(true)
              pending -= 1
              if (pending == 0) {
                console.log('done loading', imageUrls.length, 'emojis')
              }
            });
            img.src = url
          })
        }
      }
    }
    asyncLogic()
  }
}class DefaultDarkTheme extends ColorTheme {
	constructor() {
		super();
		this.set('uiBackground'			, [0,0,0, 1]);
		this.set('uiForeground'			, [1,1,1, 1]);
		this.set('uiButton'					, [0.6,0.6,0.6, 1]);
		this.set('uiButtonSel'			, [0.2,1.0,0.2, 1]);
		this.set('uiButtonGhost'		, [0.2,0.2,0.2, 1]);
		this.set('uiVideoOverlayButton'					, [1,1,1, 1]);
		this.set('uiVideoOverlayButtonGhost'		, [1,1,1, 0.33]);
		this.set('uiLedger1'				, [0.00,0.00,0.00, 1]);
		this.set('uiLedger2'				, [0.05,0.05,0.05, 1]);
		this.set('uiSpeechCloud'		, [0.05,0.05,0.05, 1]);
		this.set('uiSilverLining'		, [0.10,0.10,0.10, 1]);
//		Object.defineProperty(this, "uiDataEntryArea", { get : function () { return [1.10,0.10,0.10, 1]; } } );
	}
}
class DefaultLightTheme extends ColorTheme {
	constructor() {
		super();
		this.set('uiLightningYellow'	, [0.9,0.8,0, 1]);
		this.set('uiBackground'			, [1,1,1, 1]);
		this.set('uiForeground'			, [0,0,0, 1]);
		this.set('uiButton'					, [0.2,0.2,0.2, 1]);
		this.set('uiButtonSel'			, [0.0,0.8,0.0, 1]);
		this.set('uiButtonGhost'		, [0.8,0.8,0.8, 1]);
		this.set('uiVideoOverlayButton'					, [0,0,0, 1]);
		this.set('uiVideoOverlayButtonGhost'		, [0,0,0, 0.25]);
		this.set('uiLedger1'				, [1.00,1.00,1.00, 1]);
		this.set('uiLedger2'				, [0.95,0.95,0.95, 1]);
		this.set('uiSpeechCloud'		, [1.00,1.00,1.00, 1]);
		this.set('uiSilverLining'		, [0.90,0.90,0.90, 1]);
	}
}
lang_db['de-DE'] = {
".":	",",
",":	".",
"₿":	"BTC/LN",
"€":	"Euro",
"₲":	"Guaraní",
"$":	"Dollar",
"de-DE":	"Deutsch",
"en-US":	"Englisch",
"es-PY":	"Spanisch",
"gn-PY":	"Guaraní",
"account":	"Konto",
"account name:":	"Name des Kontos:",
"about @":	"etwa @",
"add new":	"Neu hinzufügen",
"all data has been deleted and/or reset to installation defaults":	"Alle Daten wurden gelöscht und/oder auf die Standardeinstellungen der Installation zurückgesetzt.",
"API auth token":	"API-Authentifizierungs-Token",
"API bearer token":	"API-Authentifizierungs-Token",
"are you sure?":	"Sind Sie sicher?",
"back":	"Rück",
"barcode scanning":	"Barcode-Scannen",
"base URL":	"Basis-URL",
"bill":	"RECHNUNG",
"business address":	"Geschäftsadresse",
"business telephone":	"Geschäftstelefon",
"camera selection":	"Auswahl der Kamera",
"cash":	"Bargeld",
"cash back amount":	"Betrage",
"cash register number":	"Kassennummer",
"cash tendered":	"angedientes Geld",
"cashier":	"Kassierer",
"change due":	"Wechselgeld",
"city":	"Stadt",
"coinos compatible":	"Coinos-kompatibel",
"colors":	"Farben",
"confirm":	"BESTÄTIGEN",
"currency":	"Währung",
"currencies":	"Währungen",
"customer bill":	"Kundenrechnung",
"danger zone":	"Gefahrenzone",
"dark/light mode":	"Dunkel-/Hellmodus",
"dark mode":	"Dunkelmodus",
"date":	"Datum",
"default vendor currency":	"Währung für die Preisgestaltung der Artikel",
"default vendor currency (title)":	"für die Preisgestaltung",
"delete '@'?":	"'@' löschen?",
"delete all data":	"Alle Daten für alle Konten löschen",
"delete data":	"Daten löschen",
"Discard this invoice?":	"Diese Rechnung verwerfen?",
"enabled currencies":	"Aktivierte Währungen",
"enabled payment methods":	"Aktivierte Zahlungsarten",
"enter":	"Eingabe",
"enumerate change due":	"Wechselgeld aufzählen",
"external":	"Extern",
"financial":	"finanzielle",
"How would you like to pay?":	"Wie möchten Sie bezahlen?",
"instant":	"DIREKT",
"invoice details":	"Rechnungsdaten",
"invoice number":	"Rechnungsnummer",
"invoice subtotal":	"Rechnungszwischensumme",
"item":	"Artikel",
"language":	"Sprache",
"layout":	"Gestaltung",
"license number":	"Lizenznummer",
"light mode":	"Hellmodus",
"lightning invoice":	"Lightningrechnung",
"lnbc item description":	"ZAHLUNG DER LIGHTNING-RECHNUNG",
"main currency":	"Hauptwährung",
"my business":	"Mein Geschäft",
"new account":	"Neues Konto",
"no":	"NEIN",
"not set":	"Nicht eingestellt",
"orders":	"Bestellungen",
"pay {AMNT} sats for {DESC}":	"{AMNT} sats für {DESC} bezahlen",
"pay {DESC} {AMNT} sats on {DATE}":	"{DESC} am {DATE} {AMNT} sats zahlen",
"payment":	"ZAHLUNG",
"payment method":	"Zahlungsart",
"payment methods":	"Zahlungsverfahren",
"plain":	"einfach",
"postal code":	"PLZ",
"price":	"Preis",
"pricing":	"Preisgestaltung",
"QR code and barcode scanning":	"QR- und Barcode-Scannen",
"qty":	"Quant.",
"receipt":	"Rechnung",
"rename":	"Umbenennen",
"scan product barcodes into description field":	"Produkt-Barcodes in das Beschreibungsfeld scannen",
"set API key":	"API-Schlüssel einstellen",
"settings":	"Einstellungen",
"shows how many of each denomination to return":	"zeigt an, wie viele der einzelnen Stückelungen",
"some":	"einige",
"state":	"Staat",
"strike compatible":	"Strike-kompatibel",
"subtotal":	"Zwischensumme",
"subtotal: #":	"Zwischensumme: #",
"switch account":	"Konto wechseln",
"tax":	"Steuer",
"tax id":	"Steueridentifikationsnummer",
"tax included":	"Steuer inbegriffen",
"terms of sale":	"Verkaufsbedingungen",
"textures":	"Texturen",
"theme":	"Theme",
"themes":	"Themen",
"tradfi":	"TradFi",
"valid from":	"gültig ab",
"valid till":	"gültig bis",
"wallet":	"Geldbeutel",
"Would you like cash back?":	"Möchten Sie Bargeld zurückerhalten?",
"Would you like money back?":	"Möchten Sie Bargeld zurückerhalten?",
}
lang_db['en-US'] = {
".":	".",
",":	",",
"₿":	"Bitcoin",
"€":	"Euro",
"₲":	"Guaraní",
"$":	"Dollar",
"de-DE":	"German",
"en-US":	"English",
"es-PY":	"Spanish",
"gn-PY":	"Guaraní",
"account":	"Account",
"account name:":	"Account name:",
"about @":	"about @",
"add new":	"Add new",
"all data has been deleted and/or reset to installation defaults":	"All data has been deleted and/or reset to installation defaults.",
"API auth token":	"API auth token",
"API bearer token":	"API bearer token",
"are you sure?":	"Are you sure?",
"back":	"back",
"barcode scanning":	"barcode scanning",
"base URL":	"Base URL",
"bill":	"INVOICE",
"business address":	"business address",
"business telephone":	"business telephone",
"camera selection":	"Camera selection",
"cash":	"cash",
"cash back amount":	"amount",
"cash register number":	"cash reg",
"cash tendered":	"cash tendered",
"cashier":	"cashier",
"change due":	"change due",
"city":	"city",
"coinos compatible":	"Coinos compatible",
"colors":	"colors",
"confirm":	"CONFIRM",
"currency":	"currency",
"currencies":	"currencies",
"customer bill":	"Customer Bill",
"danger zone":	"Danger zone",
"dark/light mode":	"Dark/light mode",
"dark mode":	"Dark mode",
"date":	"date",
"default vendor currency":	"currency for pricing items",
"default vendor currency (title)":	"currency for pricing",
"delete '@'?":	"Delete '@'?",
"delete all data":	"delete all data for all accounts",
"delete data":	"delete data",
"Discard this invoice?":	"Discard this invoice?",
"enabled currencies":	"Enabled currencies",
"enabled payment methods":	"Enabled payment methods",
"enter":	"enter",
"enumerate change due":	"enumerate change due",
"external":	"External",
"financial":	"financial",
"How would you like to pay?":	"How would you like to pay?",
"instant":	"INSTANT",
"invoice details":	"invoice details",
"invoice number":	"invoice #",
"invoice subtotal":	"subtotal",
"item":	"item",
"language":	"Language",
"layout":	"Layout",
"license number":	"license #",
"light mode":	"Light mode",
"lightning invoice":	"lightning invoice",
"lnbc item description":	"PAYMENT OF LIGHNING INVOICE",
"main currency":	"main currency",
"my business":	"My Business",
"new account":	"New account",
"no":	"NO",
"not set":	"Not set",
"orders":	"orders",
"pay {AMNT} sats for {DESC}":	"pay {AMNT} sats for {DESC}",
"pay {DESC} {AMNT} sats on {DATE}":	"pay {DESC} {AMNT} sats on {DATE}",
"payment":	"PAYMENT",
"payment method":	"Payment method",
"payment methods":	"Payment methods",
"plain":	"plain",
"postal code":	"ZIP code",
"price":	"price",
"pricing":	"Pricing",
"QR code and barcode scanning":	"QR and barcode scanning",
"qty":	"qty",
"receipt":	"receipt",
"rename":	"Rename",
"scan product barcodes into description field":	"scan product barcodes into description field",
"set API key":	"Set API key",
"settings":	"Settings",
"shows how many of each denomination to return":	"shows how many of each denomination to return",
"some":	"some",
"state":	"state",
"strike compatible":	"Strike compatible",
"subtotal":	"subtotal",
"subtotal: #":	"subtotal: #",
"switch account":	"Switch account",
"tax":	"tax",
"tax id":	"taxpayer identification number",
"tax included":	"tax included",
"terms of sale":	"terms of sale",
"textures":	"textures",
"theme":	"Theme",
"themes":	"Themes",
"tradfi":	"TradFi",
"valid from":	"valid from",
"valid till":	"valid till",
"wallet":	"Wallet",
"Would you like cash back?":	"Would you like cash back?",
"Would you like money back?":	"Would you like money back?",
}
lang_db['es-PY'] = {
".":	",",
",":	".",
"₿":	"Nuevo Guaraní",
"€":	"Euro",
"₲":	"Guaraní",
"$":	"Dólar",
"de-DE":	"Alemán",
"en-US":	"Inglés",
"es-PY":	"Español",
"gn-PY":	"Guaraní",
"account":	"Cuenta",
"account name:":	"Nombre de la cuenta:",
"about @":	"circa de @",
"add new":	"Añadir nuevo",
"all data has been deleted and/or reset to installation defaults":	"Se han borrado todos los datos y/o se han restablecido los valores predeterminados de instalación.",
"API auth token":	"Token de autenticación API",
"API bearer token":	"Token de autenticación API",
"are you sure?":	"¿Está seguro?",
"back":	"retro",
"barcode scanning":	"escaneo de códigos de barras",
"base URL":	"URL básica",
"bill":	"FACTURA",
"business address":	"dirección de la empresa",
"business telephone":	"teléfono de empressa",
"camera selection":	"Selección de cámara",
"cash":	"efectivo",
"cash back amount":	"importe",
"cash register number":	"caja na",
"cash tendered":	"efectivo",
"cashier":	"cajero",
"change due":	"su vuelto",
"city":	"ciudad",
"coinos compatible":	"Compatible con coinos",
"colors":	"colores",
"confirm":	"CONFIRME",
"currency":	"moneda",
"currencies":	"monedas",
"customer bill":	"Factura cliente",
"danger zone":	"Zona de peligro",
"dark/light mode":	"Modo oscuro/claro",
"dark mode":	"Modo oscuro",
"date":	"fecha",
"default vendor currency":	"moneda para la fijación de precios",
"default vendor currency (title)":	"fijación de precios",
"delete '@'?":	"¿Borrar '@'?",
"delete all data":	"borrar todos los datos de las cuentas",
"delete data":	"borrar datos",
"Discard this invoice?":	"¿Descartar esta factura?",
"enabled currencies":	"Monedas habilitadas",
"enabled payment methods":	"Formas de pago habilitados",
"enter":	"intro",
"enumerate change due":	"enumere su vuelto",
"external":	"Exterior",
"financial":	"financiero",
"How would you like to pay?":	"¿Cómo le gustaría pagar?",
"instant":	"INSTANTE",
"invoice details":	"factura contado",
"invoice number":	"factura na",
"invoice subtotal":	"importe total",
"item":	"artículo",
"language":	"Idioma",
"layout":	"Presentación",
"license number":	"timbrado na",
"light mode":	"Modo claro",
"lightning invoice":	"factura relámpago",
"lnbc item description":	"PAGO DE FACTURA NUEVO GUARANÍ",
"main currency":	"moneda principal",
"my business":	"Mi negocio",
"new account":	"Nueva cuenta",
"no":	"NO",
"not set":	"No configurado",
"orders":	"pedidos",
"pay {AMNT} sats for {DESC}":	"pagar {AMNT} sats por {DESC}",
"pay {DESC} {AMNT} sats on {DATE}":	"pagar a {DESC} {AMNT} sats el {DATE}",
"payment":	"PAGO",
"payment method":	"Forma de pago",
"payment methods":	"Formas de pagos",
"plain":	"simple",
"postal code":	"código postal",
"price":	"precio",
"pricing":	"Fijación de precios",
"QR code and barcode scanning":	"escaneo de códigos de barras y QR",
"qty":	"cant.",
"receipt":	"ticket",
"rename":	"Cambiar nombre",
"scan product barcodes into description field":	"escanear los códigos de los productos en el descripción",
"set API key":	"Establecer clave API",
"settings":	"Ajustes",
"shows how many of each denomination to return":	"muestra cuántos ejemplares de cada denominación",
"some":	"algunos",
"state":	"departamento",
"strike compatible":	"Compatible con strike",
"subtotal":	"importe total",
"subtotal: #":	"subtotal: #",
"switch account":	"Cambiar de cuenta",
"tax":	"IVA",
"tax id":	"RUC",
"tax included":	"IVA incluido",
"terms of sale":	"condición de venta contado",
"textures":	"texturas",
"theme":	"Tema",
"themes":	"Temas",
"tradfi":	"TradFi",
"valid from":	"valido desde",
"valid till":	"valido hasta",
"wallet":	"Monedero",
"Would you like cash back?":	"¿Quiere que le devolvamos dinero?",
"Would you like money back?":	"¿Quiere que le devolvamos dinero?",
}
const trs = {};
const supportedLangs = ['de-DE', 'en-US', 'es-PY', 'gn-PY'];
const langFallbacks = {'gn-PY': ['es-PY']};
function tr(s, l = lcode) {
	const enableWarnings = false;
	if (!(s in trs)) {
		trs[s] = {'source': s};
		for (var supLang of supportedLangs) {
			if (typeof lang_db[supLang] === 'object'
			&& typeof lang_db[supLang][s] === 'string') {
				trs[s][supLang] = lang_db[supLang][s];
			}
		}
		var missing = '';
		for (var supLang of supportedLangs) {
			if (!(supLang in trs[s])) missing += ', ' + supLang;
		}
		if(missing != '') {
			missing = missing.substring(2);
			if (enableWarnings) console.log("WARNING: Translation(s) "+missing+" missing for", trs[s]);
		}
	}
	if (l in trs[s]) {
		return trs[s][l];
	} else {
		var fallbacks;
		if (!(l in langFallbacks)) {
			fallbacks = ['en-US'];
		} else {
			fallbacks = [...langFallbacks[l], 'en-US'];
		}
		var best = -1, bestL = '';
		for(var v in trs[s]) {
			if(!trs[s].hasOwnProperty(v) || v == 'source') continue;
			var i = fallbacks.indexOf(v);
			if ((i >= 0 && i < best) || best == -1) {
				best = i;
				bestL = v;
			}
		}
		if (bestL) {
			if (enableWarnings) console.log("WARNING: Using '"+v+"' instead of '"+l+"' for", trs[s]);
			return trs[s][v];
		}
		if (enableWarnings) console.log("WARNING: No translations found for", trs[s]);
		return trs[s]['source'];
	}
}

function icap(str) {
	return str.charAt(0).toUpperCase() + str.slice(1);
}
function cap(str) {
	return str.toUpperCase();
}
function tcase(str) {
	return str.split(' ').map(function(word) {
		return word.replace(word[0], word[0].toUpperCase());
	}).join(' ');
}
/*
 * This file defines the format in which the receipt is encoded for
 * transmission from the vendor to the customer via QR code. It is
 * intentionally encoded in such a way as to convey vendor-provided data
 * (as on existing receipts) in a mostly human-readable format that can also
 * be machine interpreted.
 *
 * The data format consists of a JSON array in plaintext, with the following
 * constraints:
 *
 * o The top-level object is an array.
 *
 * o The first two elements are integers m, n such that 0 < m <= n.
 *
 *   Since the data will often exceed the capacity of a single QR code, these
 *   numbers shall be present to indicate which part of a multi-part
 *   transmission is being presented, and how many parts exist in total.
 *
 *   Example: [1,1,...] // for a small receipt that fits in one barcode
 *
 *   Example: [2,5,...] // the second of five QR codes during transmission of
 *                      // a longer receipt
 *
 * o The third element is an object containing zero or more fields.
 *
 * o Each field consists of an integer key wrapped in quotes (as required by
 *   the JSON format) and a value whose type is defined in the following
 *   table. Where the type {n,v} appears in the table, it always refers to a
 *   JSON object with key name n and value v of type string. This is
 *   intentionally the most common type of entry, which allows vendors to
 *   present names and values of data in the style of their choosing while
 *   the numeric key provides for automated decoding.
 *
 *   Example: [1,3,{...,"1":{"":"Mary's Produce"},...}]
 *   Explanation: This is a two-part receipt spread across two QR codes. This
 *   data string represents the first part and includes the vendor name, which
 *   would be printed without a label as "Mary's Produce". Automated tools
 *   would be able to recognize this as the name of the vendor because of the
 *   key of "1" (defined in the table below).
 *
 *   Example: [1,2,{...,"3":{"Date":"19/05/2023 11:36:11"},...}]
 *   Explanation: Similar to the previous example, this includes the date of
 *   the sale in the human-readable way that the vendor presents it according
 *   to their locale. Automated tools may know that this is intended to
 *   represent the date of sale because of the key of "3" (defined in the
 *   table below).
 *

Key Type  Detailed Definition
  0 {n:v} Protocol version v as an integer (wrapped in quotes).
  1 {n:v} The name of the business, store, vendor, or entity selling goods.
  2 {n:v} Street address.
  3 {n:v} Date and time of sale.
  4 {n:v} Phone number.
105 {n:v} RUC number for Paraguayan businesses.
106 {n:v} Seal number (timbrado) for Paraguayan businesses.
107 {n:v} Seal valid from date for Paraguayan businesses.
108 {n:v} Seal valid till date for Paraguayan businesses.
  5 {n:v} Vendor's receipt number.
  6 {n:v} Presence indicates that taxes are included in the item prices.
  7 {n:v} Presence indicates that taxes are not included in the item prices.
  8 {n:v} Cashier number
  9 {n:v} Cashier name
 10 {n:v} Customer name
109 {n:v} Customer RUC for Paraguayan businesses.
 11 [...] An array containing a list of key-value pairs corresponding to the
          data provided for the items purchased. The key is a (quoted) integer
          referring to a definition in this table and the value is a string
          as would be printed on the receipt in a header.
 12 [...] An array of arrays, with each sub array corresponding to one
          line-item purchased. Within the subarray, each element is a string
          corresponding to the definitions provided in type 11 above with the
          same number of elements and no gaps (empty strings are allowed).

 */

class Receipt {
	static get VENDOR() { return 1; }
	static get TELEPHONE() { return 2; }
  static get DATE_AND_TIME() { return 3; }

	// An array containing a list of key-value pairs corresponding to the
	// data provided for the items purchased. The key is a (quoted) integer
	// referring to a definition in this table and the value is a string
	// as would be printed on the receipt in a header.
  static get LIST_HEAD() { return 4; }

	// An array of arrays, with each sub array corresponding to one
	// line-item purchased. Within the subarray, each element is a string
	// corresponding to the definitions provided in type 11 above with the
	// same number of elements and no gaps (empty strings are allowed).
  static get LIST_ITEM() { return 5; }

  static get ITEM_NUM() { return 6; }
  static get ITEM_DESC() { return 7; }
  static get ITEM_QTY() { return 8; }
  static get ITEM_PRICE() { return 9; }

	static get LOC_ADDRESS() { return 10; }
	static get LOC_CITY() { return 11; }
	static get LOC_STATE() { return 12; }
	static get LOC_STATE_US() { return 12.1; }
	static get LOC_POSTAL_CODE() { return 13; }
	static get LOC_POSTAL_CODE_US() { return 13.1; }
	static get LOC_POSTAL_CODE_PY_OLD() { return 13.01; }
	static get LOC_POSTAL_CODE_PY_NEW() { return 13.02; }
	static get LOC_COUNTRY() { return 14; }
  static get VEND_TAX_ID() { return 15; }
  static get VEND_TAX_ID_PY_RUC() { return 15.01; }
  static get VEND_LIC_NUM() { return 16; }
  static get VEND_LIC_VALID_FROM() { return 17; }
  static get VEND_LIC_VALID_TILL() { return 18; }
  static get TITLE_INVOICE_DETAILS() { return 19; }
	static get INVOICE_NUM() { return 20; }
  static get TITLE_TERMS_OF_SALE() { return 21; }
  static get TAX_INCLUDED() { return 22; }
  static get TAX_NOT_INCLUDED() { return 23; }
  static get CASHREG_NUM() { return 24; }
  static get CASHIER_NAME() { return 25; }
  static get CUST_NAME() { return 26; }
  static get CUST_TAX_ID() { return 27; }
  static get CUST_TAX_ID_PY_RUC() { return 27.01; }
  static get SEP() { return 28; }

  static get ITEM_TOTAL() { return 29; }
  static get ITEM_TAX_CATEGORY() { return 30; }
  static get INV_SUBTOTAL() { return 31; }

  static get PMT_DETAILS() { return 32; }
  static get PMT_CASH() { return 33; }
  static get PMT_TOTAL() { return 34; }
  static get PMT_CHANGE_DUE() { return 35; }

  static get TAX_DETAILS() { return 36; }
  static get TAX_HEAD() { return 4.1; }
  static get TAX_ITEM() { return 5.1; }
  static get TAX_CATEGORY() { return 37; }
  static get CAT_TAXABLE_AMT() { return 38; }
  static get CAT_TAX_AMT() { return 39; }
  static get TAX_TOTAL() { return 40; }
  static get NOTE() { return 41; }

	// An empty array or an array of three elements: [integer, string,
	// integer] representing minimum widths and a separator for a two-column
  // format. If the array is empty, tabular formatting is turned off.
  static get TAB() { return 42; }


	constructor() {
		this.clear();
	}
	clear() {
		this.data = [];
	}
	has(key) {
		if (key === undefined) console.log('undefined key for:', name, value);
		for (var o of this.data) {
			if (Object.keys(o).includes(key.toString())) return true;
		}
	}
	append(key, name, value) {
		if (key === undefined) console.log('undefined key for:', name, value);
		var temp = {}
		temp[key.toString()] = [name.toString(), value.toString()];
		this.data.push(temp);
	}
	appendTabFmt(key, w1, sep, w2) {
		if (key === undefined) console.log('undefined key for tab format.');
		var temp = {}
		if (w1 || sep || w2) {
			temp[key.toString()] = [w1, sep, w2];
		} else {
			temp[key.toString()] = [];
		}
		this.data.push(temp);
	}
	appendListHead(key, values) {
		if (key === undefined) console.log('undefined key for:', values);
		var list = [];
		for (var f of values) {
			var temp = {}
			temp[f[0].toString()] = [f[1].toString(), f[2]];
			list.push(temp);
		}
		var temp = {}
		temp[key.toString()] = list;
		this.data.push(temp);
	}
	appendListItem(key, values) {
		if (key === undefined) console.log('undefined key for:', values);
		var temp = {}
		temp[key.toString()] = values;
		this.data.push(temp);
	}
	addVendorHeaders() {
		this.append(Receipt.VENDOR, "", "**BIO-GRANJA EL DORADO E.I.R.L.    **");
		this.append(Receipt.LOC_ADDRESS, "", "M. Auxiliadora 9002");
		this.append(Receipt.TELEPHONE, "", "+595 986 124 208");
		this.append(Receipt.VEND_TAX_ID_PY_RUC, "R.U.C.", "80064237-6");
		this.append(Receipt.VEND_LIC_NUM, "Timbrado Na", "15856902");
		this.append(Receipt.VEND_LIC_VALID_FROM, "Valido Desde", "1/09/2022");
		this.append(Receipt.VEND_LIC_VALID_TILL, "Valido Hasta", "30/09/2023");
		this.append(Receipt.TITLE_INVOICE_DETAILS, "", "**FACTURA CONTADO**");
		this.append(Receipt.INVOICE_NUM, "Factura Na", "001-003-0022282");
		this.append(Receipt.TITLE_TERMS_OF_SALE, "", "Condición de Venta Contado");
		this.append(Receipt.TAX_INCLUDED, "", "I.V.A. Incluido");
		this.appendTabFmt(Receipt.TAB+0.1, 7, ": ", 0);
		this.append(Receipt.CASHREG_NUM, "Caja Na", "1");
		this.append(Receipt.DATE_AND_TIME, "Fecha", "19/05/2023 11:36:11");
		this.append(Receipt.CASHIER_NAME, "Cajero", "Caja Perla");
		this.append(Receipt.CUST_NAME, "Cliente", "CLIENTE SIN NOMBRE");
		this.append(Receipt.CUST_TAX_ID_PY_RUC, "R.U.C.", "00000000-0");
		this.append(Receipt.SEP+0.1, "", "-");
		this.appendListHead(Receipt.LIST_HEAD, [
			[Receipt.ITEM_NUM,   "Articulo  ",   10],
			[Receipt.ITEM_DESC,  "Descripción", 0],
			[Receipt.ITEM_QTY,   "Cantidad",    0],
			[Receipt.ITEM_PRICE, "Precio",      9],
			[Receipt.ITEM_TOTAL, "Total",      17],
			[Receipt.ITEM_TAX_CATEGORY, " TI",  3],
		]);
		this.append(Receipt.SEP+0.2, "", "-");
		this.appendListItem(Receipt.LIST_ITEM, [
			"8,914", "ALCAPARRAS G&G 90GR", "1,000", "16.200", "16.200", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"8,465", "PURE DE TOMATE LA HUERTA, 210", "1,000", "4.000", "4.000", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"8,465", "PURE DE TOMATE LA HUERTA, 210", "1,000", "4.000", "4.000", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"5,520", "BICARBONATO DE SODIO X KG", "0,190", "22.000", "4.180", "5%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"5,355", "COCO RALLADO COPASLA, X KG", "0,130", "44.300", "5.538", "10%"]);

		this.appendListItem(Receipt.LIST_ITEM, [
			"5,476", "PAN BIMBO SANDWICH BLANCO, 88", "1,000", "15.700", "15.700", "5%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"8,959", "ERDNUSS CREME G+G CROCANTE, 3", "1,000", "28.900", "28.900", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"194", "FIDEOS ANITA SPAGHETTI NIDO,", "1,000", "5.400", "5.400", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"775", "AJI MOLIDO PRIMICIA 25G", "1,000", "3.300", "3.300", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"4,216", "YOGHURT SUPER YO VAINILLA, 35", "1,000", "4.200", "4.200", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"490", "MANTECA TREBOL EN PAN, 200G", "1,000", "13.900", "13.900", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"8,914", "ALCAPARRAS G&G 90GR", "1,000", "16.200", "16.200", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"8,647", "PIMIENTA G+G COLORIDA 40GR co", "1,000", "26.700", "26.700", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"221", "DETERGENTE ZITRON VERDE, 500C", "1,000", "6.200", "6.200", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"6,986", "AVENA ARROLLADA BROTERRA, 350", "1,000", "11.500", "11.500", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"10,483", "HARINA DE TRIGO, PARAVIDA, 1K", "1,000", "17.000", "17.000", "5%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"7,799", "Cubierto Inox mango Agrilico", "1,000", "16.800", "16.800", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"4,777", "TABLA PICA CARNE PLASTICA, 29", "1,000", "29.700", "29.700", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"4,087", "ESPATULA MADERA", "1,000", "59.800", "10.000", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"8,681", "QUESO TCHE MOZZARELLA TIPO IT", "0,850", "50.531", "50.531", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"384", "LEVADURA COPALSA SECA EN SOBR", "1,000", "7.200", "7.200", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"278", "GALLET. MONDELEZ CEREALITAS C", "1,000", "3.700", "3.700", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"1,607", "CARICIA UVA, 25GR", "1,000", "1.500", "1.500", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"8,648", "PURE DE MANZANA SPREEWALDHOF", "1,000", "27.900", "27.900", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"8,916", "MANI SALADO TOSTADO SESAMI, 2", "1,000", "14.900", "14.900", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"8,379", "SALSA FRUTIKA FILETTO, 300GR", "1,000", "6.700", "6.700", "10%"]);
		this.appendListItem(Receipt.LIST_ITEM, [
			"9,992", "BOLSA PARA EMPAQUE X UN", "2,000", "500", "1.000", "10%"]);

		this.append(Receipt.SEP+0.3, "", "-");
		this.appendTabFmt(Receipt.TAB+0.2, 17, "---->", 17);
		this.append(Receipt.INV_SUBTOTAL, "Importe Total", "33.918");
		this.appendTabFmt(Receipt.TAB+0.3);
		this.append(Receipt.SEP+0.4, "", "-");
		this.append(Receipt.SEP+0.5, "", "");

		this.appendTabFmt(Receipt.TAB+0.4, 0, "", 0);
		this.append(Receipt.PMT_DETAILS, "", "Detalle de Pagos:");
		this.append(Receipt.SEP+0.6, "", "-");
		this.appendTabFmt(Receipt.TAB+0.5, 14, "", 22);
		this.append(Receipt.PMT_CASH, "Efectivo:", "50.000");
		this.appendTabFmt(Receipt.TAB+0.6, 14, "---->", 17);
		this.append(Receipt.PMT_TOTAL, "Total Pagos", "50.000");
		this.append(Receipt.PMT_CHANGE_DUE, "Su Vuelto", "16.082");
		this.appendTabFmt(Receipt.TAB+0.7);
		this.append(Receipt.SEP+0.7, "", "");

		this.appendListHead(Receipt.TAX_HEAD, [
			[Receipt.TAX_CATEGORY,    "SUB TOTALES", 14],
			[Receipt.CAT_TAXABLE_AMT, "LIQUIDACION",  0],
			[Receipt.CAT_TAX_AMT,     "IVA",         13],
		]);
		this.append(Receipt.SEP+0.8, "", "-");
		this.appendListItem(Receipt.TAX_ITEM, [
			"Exento", "", ""]);
		this.appendListItem(Receipt.TAX_ITEM, [
			"Gravado 10%", "29.737", "2.703"]);
		this.appendListItem(Receipt.TAX_ITEM, [
			"Gravado  5%", "4.180", "199"]);
		this.appendListItem(Receipt.TAX_ITEM, [
			"Total:", "", "2.902"]);
		//this.append(Receipt.TAX_TOTAL, "Total", "2.902");
		this.append(Receipt.SEP+0.9, "", "");

		this.append(Receipt.NOTE+0.1, "", "******Original: Cliente******");
		this.append(Receipt.NOTE+0.2, "", "******Duplicado: Archivo Tributario******");
		this.append(Receipt.NOTE+0.3, "", "******Gracias Por su Preferencia******");
	}
	toParts() {
		const parts = []; var part = [];
		for (var o of this.data) {
			var resort = JSON.stringify(part);
			part.push(o);
			if (JSON.stringify(part).length > 500 && resort != '[]') {
				parts.push(resort);
				part = [];
				part.push(o);
			}
		}
		parts.push(JSON.stringify(part));
		for (i=1; i<=parts.length; i++) {
			const PAD_TO = 512;
			var temp = '['+i+','+parts.length+','+parts[i-1].substring(1);
			const pads = [' ', '\n', '\t', '\r'];
			var n = PAD_TO - temp.length;
			if (n > 0) {
				var j, k = Math.floor(n / 7);
				temp = '[';
				for (j=0; j<k; j++) { temp += pads[Math.floor(Math.random()*pads.length)]; n-=1; }
				temp += ''+i;
				for (j=0; j<k; j++) { temp += pads[Math.floor(Math.random()*pads.length)]; n-=1; }
				temp += ',';
				for (j=0; j<k; j++) { temp += pads[Math.floor(Math.random()*pads.length)]; n-=1; }
				temp += ''+parts.length;
				for (j=0; j<k; j++) { temp += pads[Math.floor(Math.random()*pads.length)]; n-=1; }
				temp += ',';
				for (j=0; j<k; j++) { temp += pads[Math.floor(Math.random()*pads.length)]; n-=1; }
				temp += parts[i-1].substring(1, parts[i-1].length-1);
				for (j=0; j<k; j++) { temp += pads[Math.floor(Math.random()*pads.length)]; n-=1; }
				temp += ']';
				for (j=0; j<k; j++) { temp += pads[Math.floor(Math.random()*pads.length)]; n-=1; }
				while (n > 0) {
					temp += pads[Math.floor(Math.random()*pads.length)];
					n -= 1;
				}
			}
			parts[i-1] = temp.padEnd(PAD_TO);
		}
		return parts;
	}
	fromParts(parts) {
		var rec = [];
		for (var i=0; i<parts.length; i++) {
			if (!(rec[i] = tryParseJSONObject(parts[i]))) return false;
		}
		var obj = [];
		for (var i=0; i<rec.length; i++) {
			for (var j=2; j<rec[i].length; j++) {
				obj.push(rec[i][j]);
			}
		}
		this.data = obj;
		return obj;
	}
}


	const GENERIC = 0;
	const PARAGUAY = 1;
	var style = PARAGUAY;

	const enabledLangs = ['en-US', 'es-PY', 'de-DE'];
	var lcode;
	const supportedCurrencies = ['₿','₲','$','€'];
	{
		let urlParams = new URLSearchParams(window.location.search);
		let lang = urlParams.get('lang');
//		if (!lang) lang = 'en-US';
		if (!lang) lang = '';
		if (enabledLangs.includes(lang)) lcode = lang;
		//if (lang == 'es-PY') supportedCurrencies.splice(0,4,'₲'/*,'₿'*//*,'$','€'*/);
		//if (lang.startsWith('de')) supportedCurrencies.splice(0,4,'€'/*,'₿'*//*,'₲','$'*/);
		//if (lang == 'en-US') supportedCurrencies.splice(0,4,'$'/*,'₿'*//*,'₲','€'*/);
	}

	const enabledCustomerLangs = ['gn-PY', 'es-PY', 'en-US', 'de-DE'];
	var defaultCustomerLang = 'es-PY';

//	const enabledVendorCurrencies = ['₿','₲','$','€'];
//	var defaultVendorCurrency = '₲';

	const enabledCustomerCurrencies = ['₿','₲','$','€'];
	var defaultCustomerCurrency = '₲';

	const enabledPaymentMethods = ['₿','₲','$','€'];

	const enabledCashbackOptions = {
		'₿': ['₲','$','€'],
		'₲': ['₿','$','€'],
		'$': ['₿','₲','€'],
		'€': ['₿','₲','$'],
	};

	var customerColors = new DefaultLightTheme();

	// Randomly produce a random configuration for testing.
	if (!releasebuild && Math.random() > 0.5) {

		style = Math.round(Math.random() * 1);

		lcode = Math.random() > 0.5?
			(Math.random() > 0.5?'gn-PY':'es-PY'):
			(Math.random() > 0.5?'en-US':'de-DE');

		for (var i=enabledCustomerLangs.length-1; i>=0; i--)
			if (Math.random() > 0.5) enabledCustomerLangs.splice(i,1);
		if (enabledCustomerLangs.length == 0) enabledCustomerLangs.push('es-PY');
		defaultCustomerLang = enabledCustomerLangs[
			Math.floor(enabledCustomerLangs.length * Math.random())];

/*
		for (var i=enabledVendorCurrencies.length-1; i>=0; i--)
			if (Math.random() > 0.5) enabledVendorCurrencies.splice(i,1);
		if (enabledVendorCurrencies.length == 0) enabledVendorCurrencies.push('₲');
		defaultVendorCurrency = enabledVendorCurrencies[
			Math.floor(enabledVendorCurrencies.length * Math.random())];
*/

		for (var i=enabledPaymentMethods.length-1; i>=0; i--)
			if (Math.random() > 0.5) enabledPaymentMethods.splice(i,1);
		if (enabledPaymentMethods.length == 0) enabledPaymentMethods.push('₲');

		for (var i=enabledCustomerCurrencies.length-1; i>=0; i--)
			if (Math.random() > 0.5) enabledCustomerCurrencies.splice(i,1);
		if (enabledCustomerCurrencies.length == 0) enabledCustomerCurrencies.push('₲');
		defaultCustomerCurrency = enabledCustomerCurrencies[
			Math.floor(enabledCustomerCurrencies.length * Math.random())];

		customerColors = Math.random() > 0.5? new DefaultLightTheme() : new DefaultDarkTheme();
	}

	// DEMO MODES
/*
	if (0) { // English demo for Paraguay usage.
		style = PARAGUAY; lcode = 'en-US';
		enabledCustomerLangs.splice(0,4,'en-US','es-PY');
		defaultCustomerLang = 'en-US';
//		enabledVendorCurrencies.splice(0,4,'₿','₲');
		enabledCustomerCurrencies.splice(0,4,'₿','₲');
		enabledPaymentMethods.splice(0,4,'₲','₿');
		enabledCashbackOptions['₲'].splice(0,4);
		enabledCashbackOptions['₿'].splice(0,4,'₲');
//		defaultVendorCurrency = '₲';
		defaultCustomerCurrency = '₲';
		customerColors = new DefaultLightTheme();
	}
	if (0) { // Spanish demo for Paraguay usage.
		style = PARAGUAY; lcode = 'es-PY';
		enabledCustomerLangs.splice(0,4,'en-US','es-PY');
		defaultCustomerLang = 'es-PY';
//		enabledVendorCurrencies.splice(0,4,'₿','₲');
		enabledCustomerCurrencies.splice(0,4,'₿','₲');
		enabledPaymentMethods.splice(0,4,'₲','₿');
		enabledCashbackOptions['₲'].splice(0,4);
		enabledCashbackOptions['₿'].splice(0,4,'₲');
//		defaultVendorCurrency = '₲';
		defaultCustomerCurrency = '₲';
		customerColors = new DefaultLightTheme();
	}
	if (0) { // EUR
		style = GENERIC; lcode = 'en-US';
//		enabledVendorCurrencies.splice(0,4,'₿','€');
		enabledCustomerCurrencies.splice(0,4,'₿','€');
//		defaultVendorCurrency = '€';
		defaultCustomerCurrency = '€';
	}
	if (0) { // USD
		style = GENERIC; lcode = 'en-US';
//		enabledVendorCurrencies.splice(0,4,'$');
		enabledCustomerCurrencies.splice(0,4,'$');
//		defaultVendorCurrency = '$';
		defaultCustomerCurrency = '$';
	}
*/
	const conversionRates = {};
	conversionRates['₿'] = {
		'₿': 1.0, // calculated in sats
		'₲': 2.0, // 1.5 + Math.random(),
		'$': 1/(40 + 10 * Math.random()), // calculated in cents
		'€': 1/(45 + 10 * Math.random()), // calculated in cents
	};
	for (var i=1; i<Object.keys(conversionRates['₿']).length; i++) {
		var cur = Object.keys(conversionRates['₿'])[i];
		conversionRates[cur] = {
			'₿': 1/conversionRates['₿'][cur],
			'₲': 1/conversionRates['₿'][cur] * conversionRates['₿']['₲'],
			'$': 1/conversionRates['₿'][cur] * conversionRates['₿']['$'],
			'€': 1/conversionRates['₿'][cur] * conversionRates['₿']['€'],
		};
	}

	function toFiat(s) {
		return style == PARAGUAY? s * 2: s / 3600;
	}

	const config = new Configuration();
/*

The purpose of this class is to organize the construction and maintenance of
WebGL buffer data. At the lowest level, WebGL needs vertex, color, and texture
coordinates to be stored in buffers with a defined modulus and other
parameters. This class facilitates creation, update, and use of those buffers.

 */
class ShapeBuffer {
	constructor(builder) {
    this.builder = builder // function to build the shapes
    this.clear() // define and initialize code buffers
    this.buf2 = gl.createBuffer(); // graphics buffer for 2-value vertices
    this.buf4 = gl.createBuffer(); // graphics buffer for 4-value vertices
    this.buf5 = gl.createBuffer(); // graphics buffer for 5-value vertices
  }

  clear() {
    this.beg2 = {}; this.len2 = {}; this.typ2 = {}; this.all2 = [];
    this.beg4 = {}; this.len4 = {}; this.typ4 = {}; this.all4 = [];
    this.beg5 = {}; this.len5 = {}; this.typ5 = {}; this.all5 = [];
  }

  populateBuffers() {
    gl.bindBuffer(gl.ARRAY_BUFFER, this.buf2);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.all2), gl.STATIC_DRAW);
  
    gl.bindBuffer(gl.ARRAY_BUFFER, this.buf4);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.all4), gl.STATIC_DRAW);
  
    gl.bindBuffer(gl.ARRAY_BUFFER, this.buf5);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.all5), gl.STATIC_DRAW);
  }

  build(...args) {
    console.group('ShapeBuffer.build(', args, ')')
    this.clear()
    this.builder.call(this, ...args)
    this.populateBuffers()
    console.groupEnd()
  }

  // shape-building functions
  addShape2(name, typ, ...points) {
    this.beg2[name] = this.all2.length/2; this.typ2[name] = typ;
    this.all2.splice (this.all2.length, 0, ...points);
    this.len2[name] = this.all2.length/2 - this.beg2[name];
  }
  addShape4(name, typ, ...points) {
    this.beg4[name] = this.all4.length/4; this.typ4[name] = typ;
    this.all4.splice (this.all4.length, 0, ...points);
    this.len4[name] = this.all4.length/4 - this.beg4[name];
  }
  addShape5(name, typ, ...points) {
    this.beg5[name] = this.all5.length/5; this.typ5[name] = typ;
    this.all5.splice (this.all5.length, 0, ...points);
    this.len5[name] = this.all5.length/5 - this.beg5[name];
  }

  // shape-drawing functions
  drawArrays2(name) { gl.drawArrays(this.typ2[name], this.beg2[name], this.len2[name]) }
  drawArrays4(name) { gl.drawArrays(this.typ4[name], this.beg4[name], this.len4[name]) }
  drawArrays5(name) { gl.drawArrays(this.typ5[name], this.beg5[name], this.len5[name]) }

  useProg2() {
		gl.useProgram(prog2);
		gl.bindBuffer(gl.ARRAY_BUFFER, this.buf2);
		//gl.disableVertexAttribArray(gl.getAttribLocation(prog5, 'aVertexPosition'));
		//gl.disableVertexAttribArray(gl.getAttribLocation(prog5, 'overallColor'));
		var a = gl.getAttribLocation(prog2, 'aVertexPosition')
		gl.vertexAttribPointer(
			a,
			2, // numComponents
			gl.FLOAT, // type
			false, // normalize
			0, // stride
			0); // offset
		gl.enableVertexAttribArray(a);
	}

	useProg4() {
		gl.useProgram(prog4);
		gl.bindBuffer(gl.ARRAY_BUFFER, this.buf4);
		var a = gl.getAttribLocation(prog4, 'aVertexPosition')
		gl.vertexAttribPointer(
			a,
			2, // numComponents
			gl.FLOAT, // type
			false, // normalize
			4 * 4, // stride
			4 * 0); // offset
		gl.enableVertexAttribArray(a);
		a = gl.getAttribLocation(prog4, 'uv')
		gl.vertexAttribPointer(
			a,
			2, // numComponents
			gl.FLOAT, // type
			false, // normalize
			4 * 4, // stride
			4 * 2); // offset
		gl.enableVertexAttribArray(a);
	}

	useProg5() {
		gl.useProgram(prog5);
		gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
			new Float32Array([1,1,1, 1]));
		gl.bindBuffer(gl.ARRAY_BUFFER, this.buf5);
		//gl.disableVertexAttribArray(gl.getAttribLocation(prog2, 'aVertexPosition'));
		var a = gl.getAttribLocation(prog5, 'aVertexPosition')
		gl.vertexAttribPointer(
			a,
			2, // numComponents
			gl.FLOAT, // type
			false, // normalize
			4 * 5, // stride
			4 * 0); // offset
		gl.enableVertexAttribArray(a);
		a = gl.getAttribLocation(prog5, 'vertexColor')
		gl.vertexAttribPointer(
			a,
			3, // numComponents
			gl.FLOAT, // type
			false, // normalize
			4 * 5, // stride
			4 * 2); // offset
		gl.enableVertexAttribArray(a);
	}

}// Helper functions
function rgb(rgba) { return [rgba[0], rgba[1], rgba[2]]; }
function alpha(rgba, a) {
	return [rgba[0], rgba[1], rgba[2], Math.min(1, Math.max(0, a))];
}

const mainShapes = new ShapeBuffer(function() {

	// Shape definitions
	this.addShape2('unitLine', gl.LINE_LOOP, 0,0, 1,1, );
	this.addShape5('unitLine', gl.LINE_LOOP, 0,0,1,1,0, 1,1,0,1,0, );
	this.addShape5('divLine', gl.LINE_STRIP, 0,0,0,0,0, 0.4,0.4,1,1,1, 0.6,0.6,1,1,1, 1,1,0,0,0, );
	this.addShape5('divLineV', gl.TRIANGLE_STRIP,
		1,0.0,...rgb(config.themeColors.uiBackground), 0,0.0,...rgb(config.themeColors.uiBackground),
		1,0.4,...rgb(config.themeColors.uiForeground), 0,0.4,...rgb(config.themeColors.uiForeground),
		1,0.6,...rgb(config.themeColors.uiForeground), 0,0.6,...rgb(config.themeColors.uiForeground),
		1,1.0,...rgb(config.themeColors.uiBackground), 0,1.0,...rgb(config.themeColors.uiBackground), );
	this.addShape5('divLineH', gl.TRIANGLE_STRIP,
		0.0,1,...rgb(config.themeColors.uiBackground), 0.0,0,...rgb(config.themeColors.uiBackground),
		0.4,1,...rgb(config.themeColors.uiForeground), 0.4,0,...rgb(config.themeColors.uiForeground),
		0.6,1,...rgb(config.themeColors.uiForeground), 0.6,0,...rgb(config.themeColors.uiForeground),
		1.0,1,...rgb(config.themeColors.uiBackground), 1.0,0,...rgb(config.themeColors.uiBackground), );
	this.addShape5('divSettings', gl.TRIANGLE_STRIP,
		0.0,1,...rgb(config.themeColors.uiSettingsBubble), 0.0,0,...rgb(config.themeColors.uiSettingsBubble),
		0.4,1,...rgb(config.themeColors.uiSettingsDivider), 0.4,0,...rgb(config.themeColors.uiSettingsDivider),
		0.6,1,...rgb(config.themeColors.uiSettingsDivider), 0.6,0,...rgb(config.themeColors.uiSettingsDivider),
		1.0,1,...rgb(config.themeColors.uiSettingsBubble), 1.0,0,...rgb(config.themeColors.uiSettingsBubble), );
	this.addShape2('rect', gl.TRIANGLE_STRIP,
		0.0,1, 0.0,0, 1.0,1, 1.0,0, );
	this.addShape4('rect', gl.TRIANGLE_STRIP,
		0.0,1,0,1, 0.0,0,0,0, 1.0,1,1,1, 1.0,0,1,0, );
	this.addShape5('rect', gl.TRIANGLE_STRIP,
		0.0,1,1,1,1, 0.0,0,1,1,1, 1.0,1,1,1,1, 1.0,0,1,1,1, );

	{
    const p = []; var n = 20;
    for (var i=0; i<=n; i++) {
      p.push(0.5 + 0.5 * Math.cos(i/n*2*Math.PI));
      p.push(0.5 + 0.5 * Math.sin(i/n*2*Math.PI));
    }
    this.addShape2('circle', gl.TRIANGLE_FAN,
      0.5,0.5, ...p );
	}

	{
    const p = []; var n = 100;
    for (var i=0; i<n; i++) {
      p.push(0.5);
      p.push(0.5);
      p.push(0.5 + 0.5 * Math.sin(i/n*2*Math.PI));
      p.push(0.5 + 0.5 * Math.cos(i/n*2*Math.PI));
      p.push(0.5 + 0.5 * Math.sin((i+1)/n*2*Math.PI));
      p.push(0.5 + 0.5 * Math.cos((i+1)/n*2*Math.PI));
    }
    this.addShape2('pies', gl.TRIANGLES,
      ...p );
	}

	{
    const s = 0.1, t = 0.02;
    this.addShape2('scanbox', gl.TRIANGLES,
      0+0,0+0, 0+s,0+t, 0+t,0+t, 0+0,0+0, 0+s,0+0, 0+s,0+t, // top-
      0+t,0+t, 0+t,0+s, 0+0,0+s, 0+0,0+0, 0+t,0+t, 0+0,0+s, //  left
      1-0,0+0, 1-s,0+t, 1-t,0+t, 1-0,0+0, 1-s,0+0, 1-s,0+t, // top-
      1-t,0+t, 1-t,0+s, 1-0,0+s, 1-0,0+0, 1-t,0+t, 1-0,0+s, //  right
      1-0,1-0, 1-s,1-t, 1-t,1-t, 1-0,1-0, 1-s,1-0, 1-s,1-t, // bottom-
      1-t,1-t, 1-t,1-s, 1-0,1-s, 1-0,1-0, 1-t,1-t, 1-0,1-s, //  right
      0+0,1-0, 0+s,1-t, 0+t,1-t, 0+0,1-0, 0+s,1-0, 0+s,1-t, // bottom-
      0+t,1-t, 0+t,1-s, 0+0,1-s, 0+0,1-0, 0+t,1-t, 0+0,1-s, //  left
    );
	}

	this.addShape5('vendorLedger', gl.TRIANGLE_STRIP,
		0.0,1,...rgb(config.themeColors.uiLedger1), 0.0,0,...rgb(config.themeColors.uiLedger2),
		1.0,1,...rgb(config.themeColors.uiLedger1), 1.0,0,...rgb(config.themeColors.uiLedger2), );
	this.addShape5('customerLedger', gl.TRIANGLE_STRIP,
		0.0,1,...rgb(customerColors.uiLedger1), 0.0,0,...rgb(customerColors.uiLedger2),
		1.0,1,...rgb(customerColors.uiLedger1), 1.0,0,...rgb(customerColors.uiLedger2), );
	this.addShape5('scrollUp', gl.TRIANGLE_FAN,
		0.5,0,0.75,0.75,0.75,
		0.0,1,0.25,0.25,0.25,
		0.4,1,1,1,1, 0.6,1,1,1,1,
		1.0,1,0.25,0.25,0.25, );
	this.addShape5('scrollDn', gl.TRIANGLE_FAN,
		0.5,0,0.75,0.75,0.75,
		0.0,1,0.25,0.25,0.25,
		0.4,1,1,1,1, 0.6,1,1,1,1,
		1.0,1,0.25,0.25,0.25, );
	var r = 0.2, w = 0.8, b = 0.3;
	if (style != PARAGUAY) { r = 1; w = 1; b = 1; }
	this.addShape5('hamburger', gl.TRIANGLES,
		0,0.0,1,r,r, 1,0.0,1,r,r, 0,0.2,1,r,r, 0,0.2,1,r,r, 1,0.0,1,r,r, 1,0.2,1,r,r,
		0,0.4,w,w,w, 1,0.4,w,w,w, 0,0.6,w,w,w, 0,0.6,w,w,w, 1,0.4,w,w,w, 1,0.6,w,w,w,
		0,0.8,b,b,1, 1,0.8,b,b,1, 0,1.0,b,b,1, 0,1.0,b,b,1, 1,0.8,b,b,1, 1,1.0,b,b,1,
	);
	this.addShape2('maximizer', gl.TRIANGLES,
		0,1, 0,0.6, 0.4,1,
		1,0, 1,0.4, 0.6,0,
		1,0.1, 0.1,1, 0,0.9,
		0,0.9, 0.9,0, 1,0.1,
	);

  {
		var sl = rgb(config.themeColors.uiSilverLining);
		var sc = rgb(config.themeColors.uiSpeechCloud);
		var w = 22.5, h = 3, x = w-1, y = h-1;
		this.addShape5('speech1o', gl.TRIANGLE_STRIP,
			0,y,...sl, 1,y,...sc, 0,1,...sl, 1,1,...sc, // left
			0.03,0.8,...sl, 1,1,...sc, 0.1,0.6,...sl, 1,1,...sc, 0.2,0.4,...sl, 1,1,...sc,
			0.4,0.2,...sl, 1,1,...sc, 0.6,0.1,...sl, 1,1,...sc, 0.8,0.03,...sl, 1,1,...sc,
			1,0,...sl, x,1,...sc, x,0,...sl, // top
			x,1,...sc, w-0.8,0.03,...sl, x,1,...sc, w-0.6,0.1,...sl, x,1,...sc, w-0.4,0.2,...sl,
			w-0.2,0.4,...sl, x,1,...sc, w-0.1,0.6,...sl, x,1,...sc, w-0.03,0.8,...sl, x,1,...sc,
			w,1,...sl, x,y,...sc, w,y,...sl, // right
			x,y,...sc, w-0.03,h-0.8,...sl, x,y,...sc, w-0.1,h-0.6,...sl, x,y,...sc, w-0.2,h-0.4,...sl, x,y,...sc,
			w-0.4,h-0.2,...sl, x,y,...sc, w-0.6,h-0.1,...sl, x,y,...sc, w-0.8,h-0.03,...sl, x,y,...sc,
			x,h,...sl, 1,y,...sc, 1,h,...sl, 1,y,...sc, // bottom
			0.8,h-0.03,...sl, 1,y,...sc, 0.6,h-0.1,...sl, 1,y,...sc, 0.4,h-0.2,...sl,
			0.2,h-0.4,...sl, 1,y,...sc, 0.1,h-0.6,...sl, 1,y,...sc, 0.03,h-0.8,...sl, 1,y,...sc,
			0,y,...sl,
		);
		this.addShape5('speech1i', gl.TRIANGLE_STRIP,
			1,1,...sc, x,1,...sc, 1,y,...sc, x,y,...sc,
		);
		this.addShape5('speech1j', gl.TRIANGLE_STRIP,
			w,h-1.75,...sl, w+1,h-1.25,...sl, w,h-1,...sl,
		);
	}

	{
		var sl = rgb(config.themeColors.uiSilverLining);
		var sc = rgb(config.themeColors.uiSilverLining);
		var w = 16, h = 1, x = w-1, y = h-1;
		this.addShape2('settingstop', gl.TRIANGLE_STRIP,
			0,h, 1,h, 0,1, 1,1, // left
			0.03,0.8, 1,1, 0.1,0.6, 1,1, 0.2,0.4, 1,1,
			0.4,0.2, 1,1, 0.6,0.1, 1,1, 0.8,0.03, 1,1,
			1,0, x,1, x,0, // top
			x,1, w-0.8,0.03, x,1, w-0.6,0.1, x,1, w-0.4,0.2,
			w-0.2,0.4, x,1, w-0.1,0.6, x,1, w-0.03,0.8, x,1,
			w,1, x,h, w,h, // right
			x,h, x,h, x,1, 1,h, 1,1, // fill
		);
		this.addShape2('settingsbot', gl.TRIANGLE_STRIP,
			x,0, w,0, x,y, w,y, // right
			x,y, w-0.03,h-0.8, x,y, w-0.1,h-0.6, x,y, w-0.2,h-0.4, x,y,
			w-0.4,h-0.2, x,y, w-0.6,h-0.1, x,y, w-0.8,h-0.03, x,y,
			x,h, 1,y, 1,h, 1,y, // bottom
			0.8,h-0.03, 1,y, 0.6,h-0.1, 1,y, 0.4,h-0.2,
			0.2,h-0.4, 1,y, 0.1,h-0.6, 1,y, 0.03,h-0.8, 1,y,
			0,y, 1,y, 0,0, 1,0, // left
			1,0, x,0, 1,h, x,h, // fill
		);
	}

	{
		function addShape2_roundedRect(obj, name, type, w, h) {
			var x = w-1, y = h-1;
			obj.addShape2(name, type,
				0      /w,y       /h, 1       /w,y      /h, 0      /w,1      /h, 1      /w,1      /h, // left
				0.03   /w,0.8     /h, 1       /w,1      /h, 0.1    /w,0.6    /h, 1      /w,1      /h, 0.2     /w,0.4     /h, 1      /w,1      /h,
				0.4    /w,0.2     /h, 1       /w,1      /h, 0.6    /w,0.1    /h, 1      /w,1      /h, 0.8     /w,0.03    /h, 1      /w,1      /h,
				1      /w,0       /h, x       /w,1      /h, x      /w,0      /h, // top
				x      /w,1       /h, (w-0.8) /w,0.03   /h, x      /w,1      /h, (w-0.6)/w,0.1    /h, x       /w,1       /h, (w-0.4)/w,0.2    /h,
				(w-0.2)/w,0.4     /h, x       /w,1      /h, (w-0.1)/w,0.6    /h, x      /w,1      /h, (w-0.03)/w,0.8     /h, x      /w,1      /h,
				w      /w,1       /h, x       /w,y      /h, w      /w,y      /h, // right
				x      /w,y       /h, (w-0.03)/w,(h-0.8)/h, x      /w,y      /h, (w-0.1)/w,(h-0.6)/h, x       /w,y       /h, (w-0.2)/w,(h-0.4)/h, x/w,y/h,
				(w-0.4)/w,(h-0.2) /h, x       /w,y      /h, (w-0.6)/w,(h-0.1)/h, x      /w,y      /h, (w-0.8) /w,(h-0.03)/h, x      /w,y      /h,
				x      /w,h       /h, 1       /w,y      /h, 1      /w,h      /h, 1      /w,y      /h, // bottom
				0.8    /w,(h-0.03)/h, 1       /w,y      /h, 0.6    /w,(h-0.1)/h, 1      /w,y      /h, 0.4     /w,(h-0.2) /h,
				0.2    /w,(h-0.4 )/h, 1       /w,y      /h, 0.1    /w,(h-0.6)/h, 1      /w,y      /h, 0.03    /w,(h-0.8) /h, 1      /w,y      /h,
				0      /w,y       /h, 1       /w,y      /h, 1      /w,y      /h,
				1      /w,1       /h, x       /w,y      /h, x      /w,1      /h,
			);
		}
		addShape2_roundedRect(this, 'keypad', gl.TRIANGLE_STRIP, 4, 4);
		addShape2_roundedRect(this, 'keypadwide', gl.TRIANGLE_STRIP, 8, 4);
		addShape2_roundedRect(this, 'keypadtall', gl.TRIANGLE_STRIP, 4, 8);
	}

	{
		const n = 50;
		var r = n-1, s = 1/r, t = s/2, h = s*Math.sqrt(3)/2;
		const v = [];
		for (var i=0; i<n; i++) {
			v.push(i/r-t,0, i/r+t,0, i/r,h);
		}
		this.addShape2('tear', gl.TRIANGLES, ...v);
	}

})

const emojiShapes = new ShapeBuffer(function(emojiData, emojisPerRow, emojisPerColumn, emojiPoints) {
 	function addEmojiShape4(obj, name, typ, x, y) {
		const nx = emojisPerRow, ny = emojisPerColumn
		const u = x+1, v = y+1
		obj.beg4[name] = obj.all4.length/4; obj.typ4[name] = typ
		obj.all4.splice (obj.all4.length, 0, 0,1,x/nx,v/ny, 0,0,x/nx,y/ny, 1,1,u/nx,v/ny, 1,0,u/nx,y/ny,)
		obj.len4[name] = obj.all4.length/4 - obj.beg4[name]
	}
	if (emojiData) {
		for (const e of emojiData) {
			addEmojiShape4(this, e.label, gl.TRIANGLE_STRIP, e.x, e.y);
		}
	}
	if (emojiPoints) this.addShape4('emojis', gl.TRIANGLE_STRIP, ...emojiPoints);
})

mainShapes.build()
//emojiShapes.build(emojiData, emojisPerRow, emojisPerColumn)
  // WEBGL INITIALIZATION

  const plainVertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(plainVertexShader, `
      attribute vec4 aVertexPosition;
      attribute vec2 aTex;
      uniform vec4 overallColor;
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;
      varying vec4 vColor;
      varying highp vec2 vTex;

      void main() {
        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
        vColor = overallColor;
        vTex = aTex;
      }
  `);
  gl.compileShader(plainVertexShader);
  if (!gl.getShaderParameter(plainVertexShader, gl.COMPILE_STATUS)) return;

  const plainFragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(plainFragmentShader, `
      varying lowp vec4 vColor;
      uniform sampler2D sampler0;
      varying highp vec2 vTex;

      void main() {
        //gl_FragColor = texture2D(sampler0, vTex);
        gl_FragColor = vColor;
      }
  `);
  gl.compileShader(plainFragmentShader);
  if (!gl.getShaderParameter(plainFragmentShader, gl.COMPILE_STATUS)) return;

  const texVertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(texVertexShader, `
      attribute vec4 aVertexPosition;
      attribute vec2 uv;
      uniform vec4 overallColor;
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;
      varying vec4 vColor;
      varying highp vec2 vTex;

      void main() {
        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
        vColor = overallColor;
        vTex = uv;
      }
  `);
  gl.compileShader(texVertexShader);
  if (!gl.getShaderParameter(texVertexShader, gl.COMPILE_STATUS)) return;

  const texFragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(texFragmentShader, `
      varying lowp vec4 vColor;
      uniform sampler2D sampler0;
      varying highp vec2 vTex;

      void main() {
        gl_FragColor = texture2D(sampler0, vTex);
        //gl_FragColor = vColor;
      }
  `);
  gl.compileShader(texFragmentShader);
  if (!gl.getShaderParameter(texFragmentShader, gl.COMPILE_STATUS)) return;

  const prog2 = gl.createProgram();
  gl.attachShader(prog2, plainVertexShader);
  gl.attachShader(prog2, plainFragmentShader);
  gl.linkProgram(prog2);
  if (!gl.getProgramParameter(prog2, gl.LINK_STATUS)) return;

  const prog4 = gl.createProgram();
  gl.attachShader(prog4, texVertexShader);
  gl.attachShader(prog4, texFragmentShader);
  gl.linkProgram(prog4);
  if (!gl.getProgramParameter(prog4, gl.LINK_STATUS)) return;

//  buf2 = gl.createBuffer(); // buffer for 2-value vertices
//  gl.bindBuffer(gl.ARRAY_BUFFER, buf2);
//  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(all2), gl.STATIC_DRAW);

//  buf4 = gl.createBuffer(); // buffer for 4-value vertices
//  gl.bindBuffer(gl.ARRAY_BUFFER, buf4);
//  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(all4), gl.STATIC_DRAW);

  const prog5VertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(prog5VertexShader, `
      attribute vec4 aVertexPosition;
      attribute vec4 vertexColor;
      attribute vec2 aTex;
      uniform vec4 overallColor;
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;
      varying vec4 vColor;
      varying highp vec2 vTex;

      void main() {
        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
        vColor = vertexColor * overallColor;
        vTex = aTex;
      }
  `);
  gl.compileShader(prog5VertexShader);
  if (!gl.getShaderParameter(prog5VertexShader, gl.COMPILE_STATUS)) return;

  const prog5FragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(prog5FragmentShader, `
      varying lowp vec4 vColor;
      uniform sampler2D sampler0;
      varying highp vec2 vTex;

      void main() {
        //gl_FragColor = texture2D(sampler0, vTex);
        gl_FragColor = vColor;
      }
  `);
  gl.compileShader(prog5FragmentShader);
  if (!gl.getShaderParameter(prog5FragmentShader, gl.COMPILE_STATUS)) return;

  const prog5 = gl.createProgram();
  gl.attachShader(prog5, prog5VertexShader);
  gl.attachShader(prog5, prog5FragmentShader);
  gl.linkProgram(prog5);
  if (!gl.getProgramParameter(prog5, gl.LINK_STATUS)) return;

  gl.useProgram(prog5);
//  buf5 = gl.createBuffer(); // buffer for 5-value vertices
//  gl.bindBuffer(gl.ARRAY_BUFFER, buf5);
//  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(all5), gl.STATIC_DRAW);

function initTexture(gl) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);

  // Because video has to be download over the internet
  // they might take a moment until it's ready so
  // put a single pixel in the texture so we can
  // use it immediately.
  const level = 0;
  const internalFormat = gl.RGBA;
  const width = 1;
  const height = 1;
  const border = 0;
  const srcFormat = gl.RGBA;
  const srcType = gl.UNSIGNED_BYTE;
  const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue
  gl.texImage2D(
    gl.TEXTURE_2D,
    level,
    internalFormat,
    width,
    height,
    border,
    srcFormat,
    srcType,
    pixel
  );

  // Turn off mips and set wrapping to clamp to edge so it
  // will work regardless of the dimensions of the video.
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  return texture;
}
function updateTexture(gl, texture, el) {
  const level = 0;
  const internalFormat = gl.RGBA;
  const srcFormat = gl.RGBA;
  const srcType = gl.UNSIGNED_BYTE;
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(
    gl.TEXTURE_2D,
    level,
    internalFormat,
    srcFormat,
    srcType,
    el,
  );
}

function drawThemeBackdrop(v, th) {
//	var startTime = performance.now();
	function baseline(f,c) { return f.glyphHeights[c]-f.glyphY1[c]; }
	gl.clearColor(...th.uiBackground);
	gl.clear(gl.COLOR_BUFFER_BIT);
	const mat = mat4.create();
	const gr = config.themeGraphics;
	const pixelPM = v.getRawMatrix();
	if (gr && gr.font) {
		var repeatX, repeatY;
		if (canvas.height / gr.height > canvas.width / gr.width) {
			repeatX = 2;
			repeatY = Math.ceil(4/gr.height*gr.width);
		} else {
			repeatY = 2;
			repeatX = Math.ceil(4/gr.width*gr.height);
		}

		if (!drawThemeBackdrop.prototype.buf) {
			drawThemeBackdrop.prototype.buf = gl.createBuffer();
			gr.font.beginObj();
			gr.font.textObj(0, baseline(gr.font,gr.pattern.codePointAt(0)), gr.pattern, th.uiBackgroundPattern);
			const data = gr.font.endObj();

			drawThemeBackdrop.prototype.beg = {}; drawThemeBackdrop.prototype.len = {}; drawThemeBackdrop.prototype.typ = {}; drawThemeBackdrop.prototype.all = [];
			function addShape4(o, name, typ, ...points) {
				o.beg[name] = o.all.length/4; o.typ[name] = typ;
				o.all.splice (o.all.length, 0, ...points);
				o.len[name] = o.all.length/4 - o.beg[name];
			}
			addShape4(drawThemeBackdrop.prototype, 'bgThemeTex', gl.TRIANGLE_FAN, ...data );
			gl.bindBuffer(gl.ARRAY_BUFFER, drawThemeBackdrop.prototype.buf);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(drawThemeBackdrop.prototype.all), gl.STATIC_DRAW);
		}

		const m = mat4.create();
		mat4.identity(m);
    mat4.translate(m, m, [-1, 1, 1]);
    mat4.scale(m, m, [2/v.w, -2/v.h, 1]);
    mat4.translate(m, m, [-v.x, -v.y, 0]);
		const scaleX = 1.1*canvas.width/(gr.width*repeatX);
		const scaleY = 1.1*canvas.height/(gr.height*repeatY);
		const scaleF = scaleX>scaleY? scaleX: scaleY;
    mat4.scale(m, m, [scaleF, scaleF, 1]);
		for (var i=0; i<repeatX; i++) for (var j=0; j<repeatY; j++) {
			mat4.identity(mat);
//			gr.font.draw(i*gr.width-0.05*gr.width, j*gr.height+0.05*gr.height+baseline(gr.font,gr.pattern.codePointAt(0)),
//				gr.pattern, th.uiBackgroundPattern, m, mat);
			mat4.translate(mat, mat, [i*gr.width-0.05*gr.width, j*gr.height+0.05*gr.height, 0]);
			gr.font.drawBuf(drawThemeBackdrop.prototype.buf, drawThemeBackdrop.prototype.beg.bgThemeTex, drawThemeBackdrop.prototype.len.bgThemeTex, th.uiBackgroundPattern, m, mat, 1);
		}
	}
//	var stopTime = performance.now();
//	console.log("bg:",stopTime - startTime);
}
// Helpers
function centerText(x,y,w,h,s,c,m0,m1) {
	var tw = defaultFont.calcWidth(s);
	defaultFont.draw(x+(w-tw)/2,y+14+(h-16)/2,s,c,m0,m1);
}
var fullscreen = (function() {
	var element = document.body;
	element.requestFullscreen =
		element.requestFullscreen ||
		element.requestFullScreen ||
		element.webkitRequestFullScreen ||
		element.mozRequestFullScreen ||
		function() { return false; };
	document.cancelFullScreen =
		document.cancelFullScreen ||
		document.webkitCancelFullScreen ||
		document.mozCancelFullScreen ||
		function() { return false; };
	function active() {
		return document.webkitIsFullScreen || document.mozFullScreen || false;
	}
	function toggle() {
		if (active()) document.cancelFullScreen(); else element.requestFullscreen();
	}
	function enter() {
		if (!active()) element.requestFullscreen();
	}
	function exit() {
		if (active()) document.cancelFullScreen();
	}
	return {
		active: active,
		toggle: toggle,
		enter: enter,
		exit: exit,
	};
})();

function tryParseJSONObject(jsonString) {
                        try {
                                var o = JSON.parse(jsonString);
                                if (o && typeof o === "object") {
                                        return o;
                                }
                        }
                        catch (e) { }
                        return false;
                }

// Scales color value to range delimited by b and c.
// Returns a new color that is to b and c what the input color is to black and white.
// All parameters are color vectors.
// The order of b and c generally does not matter.
function colorize(color,b,c) {
	var d = b, e = c; if (b[0]>c[0] && b[1]>c[1] && b[2]>c[2]) { d = c; e = b; }
	function f(a,b,c) { return a*(c-b)+b; }
	return [
		f(color[0],d[0],e[0]),
		f(color[1],d[1],e[1]),
		f(color[2],d[2],e[2]),
		  color[3],
	];
}

// Blends two colors based on alpha factor.
function blend(color1,color0,alpha) {
	let onema = 1-alpha;
	return [
		color1[0]*alpha+color0[0]*onema,
		color1[1]*alpha+color0[1]*onema,
		color1[2]*alpha+color0[2]*onema,
		color1[3]*alpha+color0[3]*onema,
	];
}

var isNumber = function isNumber(value) 
{
   return typeof value === 'number' && isFinite(value);
}

function cconv(a, f, t) {
	return Math.ceil(a * cconv.prototype.conv[f][t] );
}
function setConversionRates() {
	cconv.prototype.conv = JSON.parse(JSON.stringify(conversionRates));
}
class LNbitsWallet extends Wallet {
	constructor() {
		super();
	}

	getConversionRate(amt, from, to, callback) {
		console.groupCollapsed(this.constructor.name+'.getConversionRate(',amt,from,to,'...)');

		if (from == to) { callback(1); return; }

		const asyncLogic = async () => {
			let json = '';
			let amt_ = amt/(config.hasCents(from)?100:1);
			let from_ = Convert.AppCurrencyToLNbitsCurrency(from);
			let to_ = Convert.AppCurrencyToLNbitsCurrency(to);
			console.log('getting quote for',amt_,from_,'to',to_,'live =',!config.debugBuild);
			if (!config.debugBuild) {
				let body = `{
			"from": "${from_}",
			"amount": ${amt_},
			"to": "${to_}"
		}`;
				console.log('request body', body);
				const response = await fetch(/*config.walletLNbitsURL*/'https://lnbits.satoshibox.io/api/v1'+'/conversion', {
					method: 'POST',
					headers: {
						'Accept': 'application/json',
						'Content-Type': 'application/json',
						'X-API-KEY': config.walletLNbitsKey,
					},
					body: body,
				});
				json = await response.json(); //extract JSON from the http response
			} else {
				console.log('debug build; picking random conversion rate');
				json = {};
				json[(from_=='sat')?'sats':from_] = amt;
				json[(to_=='sat')?'sats':to_] = amt * (Math.random()*1.5 + 0.5);
			}
			console.log(json);

			if (from_ == 'BTC') from_ = 'sats';
			if (to_ == 'BTC') to_ = 'sats';

			let convRate = 0;
			if (json && json[from_] && json[to_]) {
				convRate = (json[to_] * (config.hasCents(to)?100:1)) / (json[from_] * (config.hasCents(from)?100:1));
			}
			console.log('rate', convRate);
			callback(convRate);
		}
		asyncLogic();

		console.groupEnd();
	}

	generateInvoice(sats, invoiceCallback) {
		console.groupCollapsed(this.constructor.name+'.generateInvoice(',sats,'...)');

		var total_sat = sats;
		if (total_sat <= 0 || total_sat != (+total_sat).toString()) {
			console.error('Amount sanity check failed:', total_sat);
			vp.beep('bad');
			return;
		}

/*
		const getAcct = async () => {
			console.group('getAcct()');
			const response = await fetch(config.walletLNbitsURL+'/wallet', {
				method: 'GET',
				headers: {
					'Accept': 'application/json',
					'X-API-KEY': config.walletLNbitsKey,
				},
			});
			const json = await response.json(); //extract JSON from the http response
			// do something with json
			console.log('json', json);
			console.groupEnd();
		}
*/

		const asyncLogic = async () => {
			let json = '';
			console.log('generating invoice for',total_sat,'sats','live =',!config.debugBuild);
			if (!config.debugBuild) {
				const response = await fetch(config.walletLNbitsURL+'/payments', {
					method: 'POST',
					headers: {
						'Accept': 'application/json',
						'Content-Type': 'application/json',
						'X-API-KEY': config.walletLNbitsKey,
					},
					body: `{
			"out": false,
			"amount": `+ total_sat +`,
			"memo": "`+ config.businessName +`",
			"unit": "sat"
		}`,
				});
				json = await response.json(); //extract JSON from the http response
			} else {
				console.log('debug build; generating fake');
				json = { payment_hash: "a37ea5ff05f41891262720e0567e9442f9463c6d12c59ded5cfca8a406c50522", payment_request: "lnbc1230n1pj2kj8esp5z8aqqsaxmghudpe79zgr48squm5x58uneapj8qh3csfynhjjz06qpp55dl2tlc97svfzf38yrs9vl55gtu5v0rdztzemm2ulj52gpk9q53qdqjd4ujqcn4wd5kuetnwvxqzjccqpjrzjqgp7tvtwh6rmpz0j9cv82tcl0fn2r00h0pualrgun6xeztdlhxltgzm59cqq8zcqqyqqqqlgqqqqn3qqvs9qyysgqv0tg90xhcddfk2w2s9pd0c9jrm9znvxujn5w8kunlzcp74yfrqjpnkc9pfqzqjemsrmn4s2lupyfkmhwn3eu58lvl3vfckvyrugv77cqyutv6g", checking_id: "a37ea5ff05f41891262720e0567e9442f9463c6d12c59ded5cfca8a406c50522", lnurl_response: null };
			}

			//console.log('json', json);
			const invoiceString = json["payment_request"];
			const checkingId = json["checking_id"];
			console.log('invoiceString', invoiceString);
			console.log('checkingId', checkingId);
			if (invoiceString && invoiceString.startsWith('lnbc') && checkingId) {
				invoiceCallback(invoiceString, checkingId);
			} else {
				invoiceCallback();
			}
		}
		asyncLogic();

		console.groupEnd();
	}

	checkInvoice(checkingId, callback) {
		console.groupCollapsed(this.constructor.name+'.checkInvoice(',checkingId,'...)');

		const asyncLogic = async () => {
			let json = '';
			if (!config.debugBuild) {
				const response = await fetch(config.walletLNbitsURL+'/payments/'+checkingId, {
					method: 'GET',
					headers: {
						'Accept': 'application/json',
						'X-API-KEY': config.walletLNbitsKey,
					},
				});
				json = await response.json();
			} else {
				console.log('debug build; faking response');
				json = { detail: "Payment does not exist." };
				json = { paid: false, preimage: "0000000000000000000000000000000000000000000000000000000000000000", details: { bolt11: "lnbc110n1pjv99kzsp57pjaz7d4pcyq44mqu39tk47jxw78fz3dp0dfefer76v5na3jnj8qpp5xxvattfa4dtgqdzea35lc8cf82qlgdnx8ps0txvs5wx5s20mhppsdqjd4ujqcn4wd5kuetnwvxqzjccqpjrzjq027t9tsc6jn5ve2k6gnn689unn8h239juuf9s3ce09aty6ed73t5z7nqsqqsygqqyqqqqqqqqqqztqq9q9qxpqysgqq58tj820ddffdc4fk82flnl3gj9sjhdt5gd57lgsl0kc40nqe4an50lq9w6p9ly5pmz0n69d9a40qdsmlae8f4scz2lg79zwrq867tspdd8rjz", checking_id: "3199d5ad3dab56803459ec69fc1f093a81f436663860f59990a38d4829fbb843", expiry: 1690474778, extra: {}, fee: 0, memo: "my business", payment_hash: "3199d5ad3dab56803459ec69fc1f093a81f436663860f59990a38d4829fbb843", pending: true, preimage: "0000000000000000000000000000000000000000000000000000000000000000", time: 1690474178, wallet_id: "0c2a142d0edf428e8a7d3379613fc424", webhook: null, webhook_status: null, } };
				json = { paid: (Math.random()>0.5)?true:false, preimage: "0000000000000000000000000000000000000000000000000000000000000000", details: { bolt11: "lnbc110n1pjv99kzsp57pjaz7d4pcyq44mqu39tk47jxw78fz3dp0dfefer76v5na3jnj8qpp5xxvattfa4dtgqdzea35lc8cf82qlgdnx8ps0txvs5wx5s20mhppsdqjd4ujqcn4wd5kuetnwvxqzjccqpjrzjq027t9tsc6jn5ve2k6gnn689unn8h239juuf9s3ce09aty6ed73t5z7nqsqqsygqqyqqqqqqqqqqztqq9q9qxpqysgqq58tj820ddffdc4fk82flnl3gj9sjhdt5gd57lgsl0kc40nqe4an50lq9w6p9ly5pmz0n69d9a40qdsmlae8f4scz2lg79zwrq867tspdd8rjz", checking_id: "3199d5ad3dab56803459ec69fc1f093a81f436663860f59990a38d4829fbb843", expiry: 1690474778, extra: {}, fee: 0, memo: "my business", payment_hash: "3199d5ad3dab56803459ec69fc1f093a81f436663860f59990a38d4829fbb843", pending: true, preimage: "0000000000000000000000000000000000000000000000000000000000000000", time: 1690474178, wallet_id: "0c2a142d0edf428e8a7d3379613fc424", webhook: null, webhook_status: null, } };
			}

			console.log('json', json);
			callback(json);
		}
		asyncLogic();

		console.groupEnd();
	}

	readInvoice(invoice, callback) {
		console.groupCollapsed(this.constructor.name+'.readInvoice(',invoice.substr(0,20),'..., ...)');
		const asyncLogic = async () => {
			let myJson;
			if (!config.debugBuild) {
				const response = await fetch(config.walletLNbitsURL+'/payments/decode', {
					method: 'POST',
					headers: {
						'Accept': 'application/json',
						'Content-Type': 'application/json',
						'X-API-KEY': config.walletLNbitsKey,
					},
					body: `{"data": "`+ invoice +`"}`,
				});
				myJson = await response.json(); //extract JSON from the http response
			} else {
				console.log('debug build; faking response');
				myJson = { description: "some description", date: "some date", amount_msat: 321000 };
			}

			console.log('myJson', myJson);
			const desc = myJson.description;
			const date = myJson.date;
			const msats = myJson.amount_msat;
			const sats = Math.round(msats/1000);

			var temp = tr('pay {AMNT} sats for {DESC}');
			temp = temp.replace('{AMNT}', isNumber(msats)? Math.round(msats/1000).toString(): tr(msats) );
			temp = temp.replace('{DESC}', tr(desc));
			temp = icap(temp);

			callback(sats, temp);
		}
		asyncLogic();
		console.groupEnd();
	}

	payInvoice(invoice, callback) {
		console.groupCollapsed(this.constructor.name+'.payInvoice(',invoice.substr(0,20),'..., ...)');

		const asyncLogic = async () => {
			let json = '';
			console.log('paying invoice','live =',!config.debugBuild);
			if (!config.debugBuild) {
				const response = await fetch(config.walletLNbitsURL+'/payments', {
					method: 'POST',
					headers: {
						'Accept': 'application/json',
						'Content-Type': 'application/json',
						'X-API-KEY': config.walletLNbitsKey,
					},
					body: `{
			"out": true,
			"bolt11": "`+ invoice +`"
		}`,
				});
				json = await response.json(); //extract JSON from the http response
			} else {
				console.log('debug build; faking payment');
				json = {
  "detail": "Internal invoice already paid."
};
				json = {
  "payment_hash": "b5985cf1c88bef61d4c8d3178beec7a388191a4c9c6175fe17569d6a9865c17a",
  "checking_id": "b5985cf1c88bef61d4c8d3178beec7a388191a4c9c6175fe17569d6a9865c17a"
};
			}

			console.log('json', json);
			const paymentHash = json["payment_hash"];
			const checkingId = json["checking_id"];
//			console.log('invoiceString', invoiceString);
//			console.log('checkingId', checkingId);
			if (paymentHash && checkingId) {
				callback(true);
			} else {
				callback(false);
			}
		}
		asyncLogic();

		console.groupEnd();
	}

}
var invoicepane;

var accounts;
var startpane2 = v = new vp.View(null);
v.name = Object.keys({startpane2}).pop();
v.designFit = [400,300];
v.gadgets.push(v.invoice = g = new vp.Gadget(v));
	g.w = 250; g.h = 50; g.actionFlags = vp.GAF_CLICKABLE;
	g.text = 'orders';
	g.layoutFunc = function() {
		var g = this, v = g.viewport, s = v.getScale();
		g.W = v.w/s; g.x = (g.W - g.w) / 2;
		g.H = v.h/s; g.y = (g.H - g.h) / 2 - 50;
		g.autoHull();
	}
	g.renderFunc = function() {
		var g = this;
		var sel = clickTapActive.includes(g.gestureState);
		const th = config.themeColors;
		const mat = mat4.create();
/*
		mat4.identity(mat);
		mat4.translate(mat, mat, [g.x, g.y, 0]);
		mat4.scale(mat, mat, [g.w, g.h, 1]);
		mainShapes.useProg5();
		gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uModelViewMatrix'), false, mat);
		gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
			new Float32Array(sel?config.themeColors.uiForeground:config.themeColors.uiPillOrange));
		mainShapes.drawArrays5('rect');
*/
		mainShapes.useProg2();
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, g.viewport.mat);
		mat4.identity(mat);
		mat4.translate(mat, mat, [g.x, g.y, 0]);
		mat4.scale(mat,mat, [g.h, g.h, 1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, mat);
		gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
			new Float32Array(config.themeColors.uiDataEntryText));
		mainShapes.drawArrays2('circle');
		mat4.identity(mat);
		mat4.translate(mat, mat, [g.x+g.w, g.y, 0]);
		mat4.scale(mat,mat, [-g.h, g.h, 1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, mat);
		mainShapes.drawArrays2('circle');
		mat4.identity(mat);
		mat4.translate(mat, mat, [g.x+g.h/2, g.y, 0]);
		mat4.scale(mat,mat, [g.w-g.h, g.h, 1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, mat);
		mainShapes.drawArrays2('rect');

		mat4.identity(mat);
		mat4.translate(mat, mat, [g.x, g.y, 0]);
		mat4.scale(mat, mat, [50/32, 50/32, 1]);
		centerText(8,7, 5*32-16,32-14, icap(tr(g.text)), th.uiDataEntryArea, g.viewport.mat, mat);
	}
	g.clickFunc = function() {
		//const pane = layoutsettings.countermode.state? invoicepane: vendorpane;
		billpane.clearData(); // To ensure any new defaults are applied.
		transitionTo(checkoutpane);
	}
/*
v.gadgets.push(v.payment = g = new vp.Gadget(v));
	g.w = 250; g.h = 50; g.actionFlags = vp.GAF_CLICKABLE;
	g.text = 'payment';
	g.layoutFunc = function() {
		var g = this, v = g.viewport, s = v.getScale();
		g.W = v.w/s; g.x = (g.W - g.w) / 2;
		g.H = v.h/s; g.y = (g.H - g.h) / 2 + 50;
		g.autoHull();
	}
	g.renderFunc = v.invoice.renderFunc;
	g.clickFunc = function() {
		transitionTo(paymentpane, 'max');
	}
*/
v.minX = 0; v.maxX = 100;
v.minY = 0; v.maxY = 1000;
v.layoutFunc = function() {
	for (const g of this.gadgets) {
		if (g.layoutFunc) g.layoutFunc.call(g);
	}
}
v.renderFunc = function() {
	const th = config.themeColors;
	drawThemeBackdrop(this, th);
	mainShapes.useProg5();
	gl.enable(gl.BLEND);
	gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
		new Float32Array(th.uiForeground));
	gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uProjectionMatrix'), false, this.mat);
	for (const g of this.gadgets) {
		if (g.renderFunc) g.renderFunc.call(g);
	}

	settingsbuttons.backbutton.endTime = performance.now();
	if (this.timerId) clearTimeout(this.timerId);
	this.timerId = setTimeout(()=>{
//		console.log('stopwatch:',settingsbuttons.backbutton.endTime - settingsbuttons.backbutton.startTime);
	}, 500 );
}

const bottommargin = v = new vp.View(null);
v.name = Object.keys({bottommargin}).pop();
v.renderFunc = function() {
	const th = config.themeColors;
	drawThemeBackdrop(this, th);
}

const startpane = v = new vp.SliceView(null, 'b', 50);
v.name = Object.keys({startpane}).pop();
Object.defineProperty(v, "title", {
  get : function () { return config.businessName; }
});
v.a = bottommargin; bottommargin.parent = v;
v.b = startpane2; startpane2.parent = v;
const emojipane = v = new vp.View();
v.name = Object.keys({emojipane}).pop();
v.designSize = 640*400;
v.minX = 0; v.maxX = 0;
v.minY = 0; v.maxY = 0;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.controlOffset = 2; // number of control icons
v.gadgets.push(v.gridGad = g = new vp.Gadget(v));
	g.actionFlags = vp.GAF_CLICKABLE;
	g.x = 0; g.y = 0;
	g.clickFunc = function(e) {
		const g = this, v = g.viewport
		const i = Math.floor((e.x+v.userX*v.viewScale)/v.w*v.gridX)
		const j = Math.floor((e.y+v.userY*v.viewScale)/v.w*v.gridX)
    const index = i+j*v.gridX - v.controlOffset
    if (index == -2) { // cancel
			vp.popRoot()
			if (this.viewport.callback) this.viewport.callback.call(undefined, undefined, 'cancel')
    } else if (index == -1) { // clear
      vp.popRoot()
      if (this.viewport.callback) this.viewport.callback.call(undefined, undefined, 'clear')
    } else if (index < this.viewport.length) {
			vp.popRoot()
			if (this.viewport.callback) this.viewport.callback.call(undefined, config.priceList.thumbnailData[index].label)
		}
	}
v.layoutFunc = function() {
	const v = this;

	let w = Math.round(Math.sqrt(100 * v.sw / v.sh));
	if (w != v.lastBuilt) {
		v.lastBuilt = w;
		let i=v.controlOffset, j=0, x=w, y=0;
		let data = [];
		const nx = config.priceList.thumbnailsPerRow, ny = config.priceList.thumbnailsPerColumn;
    console.log(config.priceList)
		let category = '';
    const priceList = config.priceList
    const maxLength = priceList.length || priceList.thumbnailData.length
    let n = 0
		for (let e of config.priceList.thumbnailData) {
      n++; if (n > maxLength) break;
			let u = e.x+1, v = e.y+1;
			data.splice(data.length,0, i,j+1,e.x/nx,v/ny, i,j,e.x/nx,e.y/ny, );
			data.splice(data.length,0, i+1,j+1,u/nx,v/ny, i+1,j,u/nx,e.y/ny, );
			y = j+1;
			i++; if (i>=w) {
				i=0; j++;
				data.splice(data.length,0, data[data.length-4],data[data.length-3],data[data.length-2],data[data.length-1], i,j+1,e.x/nx,(e.y+1)/ny, );
			}
			category = e.category;
		}
		this.gridX = x;
		this.gridY = y;
    this.length = priceList.length || config.priceList.thumbnailData.length;
    v.emojiPoints = data
    emojiShapes.build(config.priceList.thumbnailData, config.priceList.thumbnailsPerRow, config.priceList.thumbnailsPerColumn, emojipane.emojiPoints)
	}
	v.maxX = v.sw;
	v.maxY = this.gridY * v.sw/v.gridX;
	if (v.swipeGad) v.swipeGad.layout.call(v.swipeGad);

	let g = v.gridGad;
	g.w = v.sw; g.h = v.maxY;
	g.autoHull();
}
v.renderFunc = function() {
	drawThemeBackdrop(this, config.themeColors);
	const v = this;
	const m = mat4.create();

	mat4.identity(m);
  mat4.translate(m,m, [0, 0, 0]);
  mat4.scale(m,m, [v.sw/v.gridX/24, v.sw/v.gridX/24, 1]);
  iconFont.draw(2,16+4, "\x07", config.themeColors.uiText, v.mat, m);

	mat4.identity(m);
  mat4.translate(m,m, [0, 0, 0]);
  mat4.scale(m,m, [v.sw/v.gridX/24, v.sw/v.gridX/24, 1]);
  iconFont.draw(2+24-2,16+4, "\x03", config.themeColors.uiText, v.mat, m);

  mat4.identity(m);
  mat4.translate(m,m, [0, 0, 0]);
  mat4.scale(m,m, [v.sw/v.gridX, v.sw/v.gridX, 1]);
  emojiShapes.useProg4();
  gl.uniformMatrix4fv(gl.getUniformLocation(prog4, 'uProjectionMatrix'), false, v.mat);
  gl.uniformMatrix4fv(gl.getUniformLocation(prog4, 'uModelViewMatrix'), false, m);
  gl.uniform4fv(gl.getUniformLocation(prog4, 'overallColor'), new Float32Array([1,1,1,1]));
  gl.bindTexture(gl.TEXTURE_2D, config.priceList.thumbnails);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
  emojiShapes.drawArrays4('emojis');
};
var lightningqr = v = new vp.View(null);
v.name = Object.keys({lightningqr}).pop();
v.scaleFactor = 1;
v.busySignal = false;
v.errorSignal = false;
v.walletSignal = false;
v.copiedSignal = false;
v.busyCounter = 0;
v.gadgets.push(v.copyGad = g = new vp.Gadget(v));
	g.x = 0; g.y = 0; g.w = 1; g.h = 1;
	g.actionFlags = vp.GAF_CLICKABLE;
	g.clickFunc = function() {
		console.log('qr-click', lightningqr.qr);
		if (lightningqr.qr.length == 1) {
			navigator.clipboard.writeText(lightningqr.qr[0]).then(
				() => {
					lightningqr.copiedSignal = true;
					lightningqr.setRenderFlag(true);
					setTimeout(() => {
						lightningqr.copiedSignal = false;
						lightningqr.setRenderFlag(true);
					}, 2000);
					console.log('/* clipboard successfully set */');
				},
				() => {
					console.log('/* clipboard write failed */');
				},
			);
		}
	}
v.clear = function() {
	this.busySignal = false;
	this.errorSignal = false;
	this.walletSignal = false;
	this.copiedSignal = false;
	this.qr = [];
	this.qrtex = [];
	this.triggerPad = true;
}
v.layoutFunc = function() {
	const v = this, g = v.copyGad;
	g.w = v.sw; g.h = v.sh;
	g.autoHull();
}
v.renderFunc = function() {
	drawThemeBackdrop(this, config.themeColors);
//	gl.clearColor(...config.themeColors.uiBackground);
//	gl.clear(gl.COLOR_BUFFER_BIT);
//	var pageindex = checkoutpages.index;
	let earlyreturn = 0;
//	if (pageindex < 0 || Math.abs(checkoutpages.getPageOffset(pageindex)) > 0.01 || checkoutpages.idealSize != vendormain.sizeH) {
	if (this.triggerPad || this.qr.length == 0) {
		delete this.triggerPad;
		this.pad = 10;
		this.setRenderFlag(true);
		earlyreturn = 1;
	}
	if (!earlyreturn && this.pad > 0) {
		this.pad -= 1;
		this.setRenderFlag(true);
		earlyreturn = 1;
	}
	if (!earlyreturn && this.pad == 0) {
		this.pad = -1;
		this.qrindex = -1;
		this.reftime = Date.now();
	}
	if (this.qr.length == 0 || this.copiedSignal) {
		earlyreturn = 1;
	}

	// Transitional gray placeholder or white background.
	var w = Math.min(this.sw, this.sh) * (earlyreturn?0.9:1);
	var x = (this.sw - w) / 2;
	var y = (this.sh - w) / 2;
	mainShapes.useProg2();
	const m = mat4.create();
	mat4.identity(m);
	mat4.translate(m,m,[x,y,0]);
	mat4.scale(m,m,[w,w,1]);
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, this.mat);
	gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
		new Float32Array(earlyreturn?[0.7,0.7,0.7,1]:[1,1,1,1]));
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
	mainShapes.drawArrays2('rect');
//console.log(this.busySignal, this.busyCounter);
	if (this.busySignal) {
		this.busyCounter += 0.01; if (this.busyCounter > Math.PI/2) this.busyCounter -= Math.PI/2;

		mat4.identity(m);
		mat4.translate(m,m,[x+w/2,y+w/2,0]);
		//mat4.scale(m,m,[w,w,1]);
		mat4.rotate(m,m, this.busyCounter, [0,0,1]);
		iconFont.draw(-10,7,"\x0A",config.themeColors.uiText,this.mat, m);

	} else if (this.walletSignal) {
		mat4.identity(m);
		mat4.translate(m,m,[x+w/2,y+w/2,0]);
		financeGraphicsFont.draw(-8.5,8.5,"\x08",config.themeColors.uiText,this.mat, m);
	} else if (this.errorSignal) {
		mat4.identity(m);
		mat4.translate(m,m,[x+w/2,y+w/2,0]);
		//mat4.scale(m,m,[w,w,1]);
		//mat4.rotate(m,m, this.busyCounter, [0,0,1]);
		iconFont.draw(-10,7,"\x0F",config.themeColors.uiLightningYellow,this.mat, m);
	} else if (this.copiedSignal) {
		let str = icap(tr("copied"));
		let tw = defaultFont.calcWidth(str);
		mat4.identity(m);
		mat4.translate(m,m,[x+w/2,y+w/2,0]);
		mat4.translate(m,m,[-tw/2,7,0]);
		defaultFont.draw(0,0,str,config.themeColors.uiText,this.mat, m);
	}
	if (this.busySignal) setTimeout(this.timeoutFunc, 100);
	if (earlyreturn) {
		return;
	}
//	if (this.qr.length == 1 && (
//			this.qr[0].startsWith('lnbc')
//	||  this.qr[0].startsWith('lnurl'))) {
//		this.queryStatus = true;
//	}

	var img = document.querySelector('#buf1');
	const rgbToHex = (r, g, b) => {
		return "#"+((1<<24)+(~~(r*255)<<16)+(~~(g*255)<<8)+~~(b*255)).toString(16).slice(1);
	}

	var i = this.qrindex + 1;
	if (i < this.qr.length && this.qrtex.length <= i) {
//console.log('render', this.qr[i].substring(0,10));
		var qrd = this.qr[i];
		if (qrd == qrd.toLowerCase()) qrd = qrd.toUpperCase();
		QrCreator.render({
			text: qrd, // Sadly, this library doesn't optimize uppercase-only codes.
			radius: 0.0, // 0.0 to 0.5
			ecLevel: 'H', // L, M, Q, H
			fill: rgbToHex(0,0,0,1), // foreground color
			background: rgbToHex(1,1,1,1), // color or null for transparent
			size: 1280 // in pixels
		}, img);
		this.qrtex.push(vp.setImage(img));
	}
	if (this.qrindex < 0) this.qrindex = 0;

	w = Math.min(this.sw, this.sh) * 0.9;
	x = (this.sw - w) / 2;
	y = (this.sh - w) / 2;
	mat4.identity(m);
	mat4.translate(m,m,[x,y,0]);
	mat4.scale(m,m,[w,w,1]);
	vp.drawImage(this.qrtex[this.qrindex], this.mat, m);

	var curtime = Date.now();
	var t = curtime - this.reftime;
	const r = 500;
	if (t >= r) {
		t = 0;
		this.reftime = curtime;
		this.qrindex += 1;
		if (this.qrindex >= this.qr.length) this.qrindex = 0;
	}

	const mat = mat4.create();
	if (this.qr[this.qrindex].startsWith('lnbc')
	||  this.qr[this.qrindex].startsWith('lnurl')) {
		const m = mat4.create();
		mat4.identity(mat);
		mat4.translate(mat,mat,[this.sw/2,this.sh/2,0]);
		mat4.scale(mat,mat,[w/160,w/160,1]);
		w = Math.min(this.sw, this.sh);
		for (var i=-1; i<=1; i++) for (var j=-1; j<=1; j++) if (i!=0||j!=0) {
			mat4.copy(m, mat);
			defaultFont.draw(-5+i/2,7+j/2, '🗲', [0,0,0,1], this.mat, m);
		}
		mat4.copy(m, mat);
		defaultFont.draw(-5,7, '🗲', customerColors.uiLightningYellow, this.mat, m);
	}

	if (this.qr.length > 1) {
		mainShapes.useProg2();
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, this.mat);
		gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
			new Float32Array([0,0,0,1]));
		mat4.copy(mat, m);
		mat4.translate(mat,mat,[0.425,0.425,0]);
		mat4.scale(mat,mat,[0.15,0.15,1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, mat);
		mainShapes.drawArrays2('circle');
		gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
			new Float32Array([1,1,1,1]));
		mat4.copy(mat, m);
		mat4.translate(mat,mat,[0.43,0.43,0]);
		mat4.scale(mat,mat,[0.14,0.14,1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, mat);
		mainShapes.drawArrays2('circle');
		gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
			new Float32Array([0,0,0,1]));
		mat4.copy(mat, m);
		mat4.translate(mat,mat,[0.5,0.5,0]);
		mat4.rotate(mat,mat,(t/r+this.qrindex)/this.qr.length*2*Math.PI,[0,0,1]);
		mat4.translate(mat,mat,[-0.003,0,0]);
		mat4.scale(mat,mat,[0.006,-0.06,1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, mat);
		mainShapes.drawArrays2('rect');

		//setTimeout(this.timeoutFunc, 1000);
		this.setRenderFlag(true);
	}
};
v.timeoutFunc = function() {
	lightningqr.setRenderFlag(true);
}

function setInvoice(invoiceString) {
console.log('setInvoice');
	lightningqr.clear();
	if (invoiceString && invoiceString.startsWith('lnbc') && checkingId) {
		lightningqr.qr = [invoiceString];
	} else {
		lightningqr.errorSignal = true;
		console.error('Not a recognized invoice type.');
	}
	lightningqr.setRenderFlag(true);
	lightningqr.busySignal = false;
}


/*
function generateStrikeInvoice() {
	const getAcct = async () => {
		console.log('genInv()');
		const response = await fetch(config.walletStrikeURL+'/accounts/handle/rld1/profile', {
			method: 'GET',
			headers: {
			  'Accept': 'application/json',
			  'Authorization': 'Bearer '+config.walletStrikeKey,
			},
		});
		const myJson = await response.json(); //extract JSON from the http response
		// do something with myJson
		console.log('myJson', myJson);
	}
	const genInv = async () => {
		console.group('genInv()');
		const response = await fetch(config.walletStrikeURL+'/invoices', {
			method: 'POST',
			headers: {
			  'Accept': 'application/json',
			  'Content-Type': 'application/json',
			  'Authorization': 'Bearer '+config.walletStrikeKey,
			},
			body: `{
				"correlationId": "224bff37-021f-43e5-9b9c-390e3d834750",
				"description": "Invoice for order 123",
				"amount": {
					"currency": "BTC",
					"amount": "0.00001"
				},
			}`,
		});
		const myJson = await response.json(); //extract JSON from the http response
		// do something with myJson
		console.log('myJson', myJson);
		console.groupEnd();
	}
	getAcct();
	//genInv();
}
function generateCoinosInvoice() {
	const userAction = async () => {
		console.log('userAction');
		const response = await fetch(config.walletCoinosURL+'/invoice', {
			method: 'POST',
			body: {invoice:{amount:1000,type:'lightning'}},
			headers: {
			  'Content-Type': 'application/json',
			  'Authorization': 'Bearer '+config.walletCoinosKey,
			}
		});
		const myJson = await response.json(); //extract JSON from the http response
		// do something with myJson
		console.log('myJson', myJson);
	}
	userAction();
}
	v.pageFocusFunc = function() {
		console.log('focus');
		switch (config.walletType) {
		case 'manual': break;
		case 'LNbits compatible': generateLNbitsInvoice(); break;
		case 'strike compatible': generateStrikeInvoice(); break;
		case 'coinos compatible': generateCoinosInvoice(); break;
		default:
		}
	}
*/
var keypadpane = v = new vp.View();
v.name = Object.keys({keypadpane}).pop();
v.keypad = [];
v.keyPoint = 10
v.keyEnter = 11
v.keyTimes = 12
v.keyBack = 13
{
	for (var i=0; i<=13; i++) {
		v.gadgets.push(g = v.keypad[i] = new vp.Gadget(v));
			g.actionFlags = vp.GAF_CLICKABLE;
			g.label = i.toString();
			g.clicked = false;
			g.code = i;
			g.clickFunc = function() { this.clicked = true; if (this.target && this.target.keypadFunc) this.target.keypadFunc(this.code); }
	}
	v.gadgets.push(g = v.inputGad = new vp.Gadget(v));
		//g.actionFlags = vp.GAF_CLICKABLE;
		//g.label = i.toString();
		//g.clicked = false;
		//g.code = i;
		//g.clickFunc = function() { this.clicked = true; if (this.target && this.target.keypadFunc) this.target.keypadFunc(this.code); }
		g.pasteFunc = function(e) {
			let v = this.viewport;
			if (v.target && v.target.pasteFunc) v.target.pasteFunc(e);
		}
		g.keydownFunc = function(e) {
			function getGad(e) {
				const v = keypadpane;
				for (let i=0; i<=13; i++) {
					let g = v.keypad[i];
					if (g.code == e.key) return g;
					else switch(g.code) {
					case v.keyPoint: if (e.key == '.') return g; break;
					case v.keyEnter: if (e.key == 'Enter') return g; break;
					case v.keyTimes: if (e.key == '*') return g; break;
					case v.keyBack: if (e.key == 'Backspace') return g; break;
					}
				}
			}
			let g = getGad(e);
			if (g) {
				g.clickFunc();
				g.viewport.setRenderFlag(true);
			} else {
				let v = this.viewport;
				if (v.target && v.target.keypadFunc) v.target.keypadFunc(-1, e.key);
			}
		}
}
v.layoutFunc = function() {
	const v = this;
	const padx = 2*v.sw/100;
	const pady = 2*v.sh/100;
	var g;
	for (var i=0; i<3; i++) for (var j=0; j<3; j++) {
		g = v.keypad[i+j*3+1];
		g.x = padx +   i * (v.sw-padx)/4;
		g.y = pady +(2-j)* (v.sh-pady)/4;
		g.w = (v.sw-padx)/4 - padx;
		g.h = (v.sh-pady)/4 - pady;
		g.shape = 'keypad';
		g.autoHull();
	}
	g = v.keypad[0];
	g.x = padx + 0 * (v.sw-padx)/4;
	g.y = pady + 3 * (v.sh-pady)/4;
	g.w = 2*(v.sw-padx)/4 - padx;
	g.h =   (v.sh-pady)/4 - pady;
	g.shape = 'keypadwide';
	g.autoHull();
	g = v.keypad[v.keyPoint]; g.label = '.';
	g.x = padx + 2 * (v.sw-padx)/4;
	g.y = pady + 3 * (v.sh-pady)/4;
	g.w = (v.sw-padx)/4 - padx;
	g.h = (v.sh-pady)/4 - pady;
	g.shape = 'keypad';
	g.autoHull();
	g = v.keypad[v.keyEnter]; g.label = icap(tr('enter'));
	g.x = padx + 3 * (v.sw-padx)/4;
	g.y = pady + 2 * (v.sh-pady)/4;
	g.w =   (v.sw-padx)/4 - padx;
	g.h = 2*(v.sh-pady)/4 - pady;
	g.shape = 'keypadtall';
	g.autoHull();
	g = v.keypad[v.keyTimes]; g.label = '×';
	g.x = padx + 3 * (v.sw-padx)/4;
	g.y = pady + 1 * (v.sh-pady)/4;
	g.w = (v.sw-padx)/4 - padx;
	g.h = (v.sh-pady)/4 - pady;
	g.shape = 'keypad';
	g.autoHull();
	g = v.keypad[v.keyBack]; g.label = icap(tr('back'));
	g.x = padx + 3 * (v.sw-padx)/4;
	g.y = pady + 0 * (v.sh-pady)/4;
	g.w = (v.sw-padx)/4 - padx;
	g.h = (v.sh-pady)/4 - pady;
	g.shape = 'keypad';
	g.autoHull();
}
v.renderFunc = function() {
//	drawThemeBackdrop(this, config.themeColors);
	gl.clearColor(...config.themeColors.uiBackground);
	gl.clear(gl.COLOR_BUFFER_BIT);
	const v = this;
	mainShapes.useProg2();
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, v.mat);
	const m = mat4.create();
	for (var g of v.keypad) {
		var sel = g.clicked || ['begin-tap','begin-click','recover-click'].includes(g.gestureState);
		mat4.identity(m);
		mat4.translate(m,m, [g.x, g.y, 0]);
		mat4.scale(m,m, [g.w, g.h, 1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
		gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
			new Float32Array(sel?config.themeColors.uiPillOrange:config.themeColors.uiSettingsBubble));
		mainShapes.drawArrays2(g.shape);
	}
	for (var g of v.keypad) {
		var sel = g.clicked || ['begin-tap','begin-click','recover-click'].includes(g.gestureState);
		mat4.identity(m);
		mat4.translate(m,m, [g.x, g.y, 0]);
		mat4.scale(m,m, [50/32, 50/32, 1]);
		mat4.translate(m,m, [8, 7+14, 0]);
		if (g.label.length > 1) mat4.scale(m,m, [0.5, 0.5, 1]);
		defaultFont.draw(0,0, tr(g.label), sel? config.themeColors.uiText: config.themeColors.uiButton, v.mat, m);
	}
	for (var g of v.keypad) {
		if (g.clicked) { g.clicked = false; v.setRenderFlag(true); }
	}
};
var billpane = v = new vp.View();
v.name = Object.keys({billpane}).pop();
v.items = [];
v.orderCurrency = config.mainCurrency;
v.conversions = {};

// Save the data pertaining to this sale.
v.saveData = function() {
	var currentState = 'saved';
	const newItem = {
		store: getCurrentAccount().id,
		status: currentState,
		date: new Date(),
		"dataentry": {
			textbox: billpane.textbox.text,
			options: billpane.textbox.options,
		},
		currency: billpane.orderCurrency,
		items: billpane.items,
		subtotal: billpane.subtotal.calc(),
		//amountTendered: receivepayment.cash.text,
		//amountToReturn: returnchange.change.text,
	};
	if (JSON.stringify(billpane.conversions) != '{}') {
		newItem.conversions = billpane.conversions;
	}
	console.log('Saving', newItem);
	const tx = db.transaction(["sales"], "readwrite");
	tx.onerror = (event) => { console.log("Save transaction failed."); };
	tx.oncomplete = (event) => { };
	const req = tx.objectStore("sales").add(newItem);
	req.onerror = (event) => { console.log("Save request failed."); };
	req.onsuccess = (event) => {
		delete billpane.lastLoadedKey;
		delete billpane.locked;
		billpane.clearData();
	};
}

// Load the data from a previous or saved sale.
v.loadData = function() {
	const tx = db.transaction(["sales"], "readonly");
	const os = tx.objectStore("sales");
	const range = this.lastLoadedKey? IDBKeyRange.upperBound(this.lastLoadedKey, true): undefined;
	const req = os.openCursor(range, 'prev');
	req.onsuccess = (event) => {
		const cursor = event.target.result;
		if (cursor) {
			if (cursor.value.store == getCurrentAccount().id) {
				this.lastLoadedKey = cursor.key;
//				setConversionRates();
				this.clearData();
				billpane.orderCurrency = cursor.value.currency;
				billpane.conversions = {};
				if (cursor.value.conversions) billpane.conversions = cursor.value.conversions;
				billpane.items = cursor.value.items;
				billpane.userY = 0;
				billpane.relayout();
				billpane.setRenderFlag(true);
				billpane.textbox.text = cursor.value.dataentry.textbox;
				billpane.textbox.options = cursor.value.dataentry.options;
				billpane.textbox.resetGads();
				billpane.textbox.setRenderFlag(true)
				billpane.subtotal.enableGads();
				billpane.subtotal.setRenderFlag(true)
			} else cursor.continue();
		} else {
			delete this.lastLoadedKey;
			this.clearData();
		}
	};
	req.onerror = (event) => {
		console.log("Cursor error.");
	};
}

// Query conversion rate.
v.beginConversionRateQuery = function(amt, from, to) {
	if (from == to) {
		billpane.conversionRate = 1;
		billpane.setRenderFlag(true);
		if (billpane.textbox.text == '' && billpane.textbox.currency == '₿' && to == '₿') {
			billpane.textbox.text = Math.round(amt).toString();
			billpane.textbox.resetGads();
			billpane.textbox.queueLayout();
		}
		delete billpane.conversionInProgress;
		return;
	}
	console.log("begin conversion query", amt, from, to);
	let key = new Date();
	billpane.conversionKey = key;
	billpane.conversionRate = 0;
	const convtype = from +'-'+ to;
	const completionLogic = (conversionRate) => {
		billpane.conversions[convtype] = conversionRate;
		if (billpane.conversionKey == key) {
			billpane.conversionRate = conversionRate;
			billpane.setRenderFlag(true);
			if (conversionRate > 0 && billpane.textbox.text == '' && billpane.textbox.currency == '₿') {
				billpane.textbox.text = Math.round(billpane.conversionRate * amt).toString();
				billpane.textbox.resetGads();
				billpane.textbox.queueLayout();
			}
			console.log("end conversion query", amt, from, to, billpane.conversionRate);
		} else {
			console.log("conversion ignored", amt, from, to);
		}
		delete billpane.conversionInProgress;
	};
	if (billpane.conversions[convtype]) {
		let amtConv = amt * billpane.conversions[convtype];
		completionLogic((amtConv * (config.hasCents(to)?100:1)) / (amt * (config.hasCents(from)?100:1)));
	} else {
		config.wallet.getConversionRate(amt, from, to, completionLogic);
	}
}
v.getConversionRate = function(amt, from, to, callback) {
	if (from == to) {
		callback(1);
		return;
	}
	const convtype = from +'-'+ to;
	const completionLogic = (conversionRate) => {
		billpane.conversions[convtype] = conversionRate;
		console.log("end conversion query", amt, from, to, conversionRate);
		callback(conversionRate);
	};
	if (billpane.conversions[convtype]) {
		let amtConv = amt * billpane.conversions[convtype];
		completionLogic((amtConv * (config.hasCents(to)?100:1)) / (amt * (config.hasCents(from)?100:1)));
	} else {
		console.log("begin conversion query", amt, from, to);
		config.wallet.getConversionRate(amt, from, to, completionLogic);
	}
}
v.getOptimalDigits = function(rate, amt) {
	const from = amt.toString();
	const to = Math.round((+from) * (+rate)).toString();
	const rateStr = rate.toString();
	let temp = rateStr;
	let lastGood, result;
	do {
		lastGood = temp;
		let rounded = rate.toFixed(Math.max(1,temp.length-temp.indexOf('.')-2)).toString();
		//console.log(temp, rounded, rounded.substr(0, temp.length-1));
		temp = rounded.substr(0, temp.length-1);
		result = Math.round((+from) * (+temp)).toString();
	} while (temp.length > temp.indexOf('.')+1 && result == to);
	if (!lastGood.includes('.')) {
		if (rateStr.includes('.')) {
			lastGood = lastGood+rateStr.substr(rateStr.indexOf('.'), 2);
		} else {
			lastGood = lastGood+'.0';
		}
	}
	return lastGood;
}

v.minX = 0; v.minY = 0;
v.maxX = v.sw; v.maxY = v.sh;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN; v.swipeGad.z = -2;
v.layoutFunc = function() {
	const v = this;
	v.maxX = Math.max(v.sw, v.maxX);
	v.maxY = Math.max(v.sh, v.maxY);
	v.swipeGad.layout.call(v.swipeGad);
}
v.clearData = function() {
	billpane.orderCurrency = config.mainCurrency;
	billpane.conversions = {};
	billpane.items = [];
	billpane.setRenderFlag(true);
	billpane.textbox.text = '';
	billpane.textbox.lastUserText = '';
	billpane.textbox.options = {};
	billpane.textbox.resetGads();
	billpane.textbox.setRenderFlag(true)
	billpane.subtotal.enableGads();
	billpane.subtotal.setRenderFlag(true)
	billpane.changed = false;
}
v.toSuper = function(str) {
	let i = str.length;
	let t = '';
	while (i--) {
		switch(str[i]) {
		case '0': t = "\u2070" + t; break;
		case '1': t = "\xB9" + t; break;
		case '2': t = "\xB2" + t; break;
		case '3': t = "\xB3" + t; break;
		case '4': t = "\u2074" + t; break;
		case '5': t = "\u2075" + t; break;
		case '6': t = "\u2076" + t; break;
		case '7': t = "\u2077" + t; break;
		case '8': t = "\u2078" + t; break;
		case '9': t = "\u2079" + t; break;
		default: t = str[i] + t;
		}
	}
	return t;
}
v.formatMoney = function(s, currency = billpane.orderCurrency) {
	let negate = false; if (s.startsWith('-')) { negate = true; s = s.substr(1); }
	const c = tr(',');
	let t = '';

	// If this currency has cents, set it aside.
	let currencyHasCents = config.hasCents(currency);
	let cents = '00';
	if (currencyHasCents) {
		while (s.length < 3) s = '0'+s;
		cents = s.substr(s.length-2, s.length);
		s = s.substr(0, s.length-2);
	}

	// Add thousands separator.
	for (let i=0; i<s.length; i++) {
		t = s.substring(s.length-1-i,s.length-i) + t;
		if ((i+1)%3==0) t = c + t;
	}
	if (t.startsWith(c)) t = t.substr(1);

	// If this currency has cents, put it back.
	if (currencyHasCents) {
		t = t+this.toSuper(cents);
	}

	return (negate? '-': '') + t;
}
v.formatQty = function(s) {
	return s.replace('.', tr('.'));
}
v.formatConvRate = function(s) {
	return s.replace('.', tr('.'));
}
v.renderFunc = function() {
	drawThemeBackdrop(this, config.themeColors);
	const v = this;
	const m = mat4.create();

	const sideMargin = 8;
	const bubbleRadius = 16, bubbleSize = bubbleRadius * 2;
	const emojiWidth = 18;
	const emojiSpace = 12;
	const coziness = 4;
	const halfPad = 2;
	const textSize = 14; // instead of bubbleSize when there is no bubble background

	let y = v.sh - 8;

  function outputSubtotal(desc, value) {
		y -= halfPad + textSize;
		let str2 = icap(tr(desc)+': ');
		let str = v.formatMoney(''+value);
		let w = defaultFont.calcWidth(str) + defaultFont.calcWidth(str2);
		mat4.identity(m);
		mat4.translate(m,m, [v.sw-sideMargin-bubbleRadius+coziness-w, y+14, 0]);
		if (str2) {
			defaultFont.draw(0,0, str2, config.themeColors.uiBillChargeTextLight, v.mat, m);
		}
		defaultFont.draw(0,0, str, value < 0? colorize(config.themeColors.uiBillCredit, config.themeColors.uiBackground, config.themeColors.uiBillChargeText): config.themeColors.uiBillChargeText, v.mat, m);
		y -= halfPad;
	}

	function outputConversionRate(label, rate, amount) {
		y -= halfPad + bubbleSize;
		let str2 = icap(tr(label))+': ';
		let str = v.getOptimalDigits(rate, amount);//effectiverate.toFixed(Math.max(0, precision - Math.round(effectiverate).toString().length));
		let w = defaultFont.calcWidth(str) + defaultFont.calcWidth(str2);
		mat4.identity(m);
		mat4.translate(m,m, [v.sw-sideMargin-bubbleRadius+coziness-w, y+8+14, 0]);
		if (str2) {
			defaultFont.draw(0,0, str2, config.themeColors.uiBillChargeTextLight, v.mat, m);
		}
		defaultFont.draw(0,0, str, config.themeColors.uiBillChargeText, v.mat, m);
		y -= halfPad;
	}

	function outputConversion(desc, value, convTo, fixedTarget) {
		y -= halfPad + textSize;
		const convtype = billpane.orderCurrency +'-'+ convTo;
		const a = (new Date()).getMilliseconds()/500*Math.PI/12;
		let temp, w, gear;
		let original_times = icap(tr(desc))+': '+ v.formatMoney(''+value) + ' × ';
		let conv = '', equals = ' = ', result = '';
		if (fixedTarget) {
			conv = v.formatConvRate(v.getOptimalDigits(fixedTarget / value, value));
			result = v.formatMoney(''+fixedTarget);
			w = defaultFont.calcWidth(original_times) + defaultFont.calcWidth(conv) + defaultFont.calcWidth(equals) + defaultFont.calcWidth(result);
		} else {
			// Kick off the conversion rate calculation if needed.
			if (!Object.keys(billpane.conversions).includes(convtype)) {
				if (!billpane.conversionInProgress) {
					billpane.conversionInProgress = true;
					billpane.beginConversionRateQuery(billpane.subtotal.calc('limitToBill'), billpane.orderCurrency, convTo);
				}
			}

			if (Object.keys(billpane.conversions).includes(convtype)) {
				const convrate = billpane.conversions[convtype];
				const convtot = Math.round(value * convrate);
				const precision = Math.max(value.toString().length, convtot.toString().length);
				//conv = v.formatConvRate(convrate.toFixed(Math.max(0, precision - Math.round(convrate).toString().length)));
				conv = v.formatConvRate(v.getOptimalDigits(convrate, value));
				result = v.formatMoney(''+convtot, convTo);
				if (convrate < 0) { conv = '____'; result = '____'; }
				w = defaultFont.calcWidth(original_times) + defaultFont.calcWidth(conv) + defaultFont.calcWidth(equals) + defaultFont.calcWidth(result);
			} else {
				gear = "\x1D";
				w = defaultFont.calcWidth(original_times) + iconFont.calcWidth(gear) + defaultFont.calcWidth(equals) + iconFont.calcWidth(gear);
				temp = mat4.create();
			}
		}
		mat4.identity(m);
		mat4.translate(m,m, [v.sw-sideMargin-bubbleRadius+coziness-w, y+14, 0]);
		defaultFont.draw(0,0, original_times, config.themeColors.uiBillChargeTextLight, v.mat, m);
		if (gear) {
			mat4.copy(temp, m);
			mat4.translate(m,m, [10, -7, 0]);
			mat4.rotate(m,m, a, [0,0,1]);
			iconFont.draw(-10,7, gear, config.themeColors.uiBillChargeTextLight, v.mat, m);
			mat4.copy(m, temp);
			mat4.translate(m,m, [20,0,0]);
		} else {
			defaultFont.draw(0,0, conv, config.themeColors.uiBillChargeTextLight, v.mat, m);
		}
		defaultFont.draw(0,0, equals, config.themeColors.uiBillChargeTextLight, v.mat, m);
		if (gear) {
			mat4.translate(m,m, [10, -7, 0]);
			mat4.rotate(m,m, a, [0,0,1]);
			iconFont.draw(-10,7, gear, config.themeColors.uiBillChargeText, v.mat, m);
			if (!billpane.timerId) billpane.timerId = setTimeout(() => { delete billpane.timerId; billpane.setRenderFlag(true); }, 100);
		} else {
			defaultFont.draw(0,0, result, config.themeColors.uiBillChargeText, v.mat, m);
		}
		y -= halfPad;
	}

	let subtotalTrigger = false;
	let convTo = billpane.orderCurrency;

	if (billpane.textbox.options.cash || billpane.textbox.options.lightning) {
		subtotalTrigger = true;
		convTo = billpane.textbox.currency;
	}
	for (let index = v.items.length-1; index >= 0; index--) {
		const item = v.items[index];
		if ((item.options.cash || item.options.lightning) && item.currency) {
			subtotalTrigger = true;
			convTo = item.currency;
			break;
		}
	}

	if (billpane.textbox.options.change) {

		let todo = 0;
		let failed_subtotal = 0;
		for (const item of billpane.items) if (item.options.emoji == 'lightning invoice') {
			if (item.options.success === undefined) todo++;
			if (item.options.success === false) failed_subtotal += Math.round(item.qty * item.unitprice);
		}
		if (todo > 0) {

			y -= halfPad + bubbleSize;
			let str2 = icap(tr(todo == 1?'paying # invoice...':'paying # invoices...'));
			str2 = str2.replace('#', todo.toString());
			let str = ''
			let w = defaultFont.calcWidth(str) + defaultFont.calcWidth(str2);
			mat4.identity(m);
			mat4.translate(m,m, [v.sw-sideMargin-bubbleRadius+coziness-w, y+8+14, 0]);
			if (str2) {
				defaultFont.draw(0,0, str2, config.themeColors.uiBillChargeTextLight, v.mat, m);
			}
			//defaultFont.draw(0,0, str, config.themeColors.uiBillChargeText, v.mat, m);
			y -= halfPad;

		} else {

			const due = -(billpane.subtotal.calc() - failed_subtotal);
			const breakdown = [];
			const denoms = config.getDenoms(billpane.orderCurrency);
			if (config.showChangeBreakdown && denoms.length > 0) {
				const lastdenom = denoms[denoms.length-1];
				const leeway = lastdenom.value / 2;
				let amt = due;
				if (amt > 0) {
					let index = 0;
					for (let denom of denoms) {
						let n = 0;
						while (amt > denom.value - leeway) {
							n++;
							amt -= denom.value;
						}
						if (n > 0) breakdown.splice(0,0, index + ':'+ n +' × '+ v.formatMoney(''+denom.value));
						index++;
					}
		//			if (amt >= leeway) {
		//				amt -= lastdenom.value;
		//				breakdown.splice(0,0, 1 +' × '+ v.formatMoney(''+lastdenom.value));
		//			}
				}
			}
			for (let str of breakdown) {
				y -= halfPad + 22;
				let t = str.substr(0, str.indexOf('×')-1);
				let i = +t.substr(0, t.indexOf(':'));
				let n = +t.substr(t.indexOf(':')+1);
				//let icons = ('\x16'+denoms[i].icon).repeat(n);
				if (denoms[i].label) str = denoms[i].label;
				else str = str.substr(str.indexOf('×')+1).trim().replace('.','').replace(',','');
				let w = iconFont.calcWidth('\x16'+denoms[i].icon);
				while (n > 0) {
					mat4.identity(m);
					mat4.translate(m,m, [v.sw-sideMargin-bubbleRadius+coziness-w*n, y+8+14, 0]);
					iconFont.draw(0,0, '\x16'+denoms[i].icon, denoms[i].color, v.mat, m);
					let mw = iconFont.calcWidth(denoms[i].icon);
					mat4.translate(m,m, [-mw, 0, 0]);
					mat4.scale(m,m, [0.5, 0.5, 1]);
					defaultFont.draw((mw*2-defaultFont.calcWidth(str))/2,-7, str, config.themeColors.uiBackground, v.mat, m);
					n--;
				}
				y -= halfPad;
			}

			const lntot = billpane.subtotal.calc('lightningPaid');
			const cashtot = billpane.subtotal.calc('cashTendered');
			if (lntot > 0) {
				if (billpane.orderCurrency != '₿') {
					outputConversion('actual conversion', billpane.subtotal.calc('limitToBill') - failed_subtotal, convTo, lntot);
				}
			} else if (cashtot) {
				if (billpane.orderCurrency == '₿') {
					outputConversion('actual conversion', billpane.subtotal.calc('limitToBill') - failed_subtotal, convTo, cashtot);
				} else {
					outputSubtotal('change due', due);
					outputSubtotal('cash tendered', billpane.subtotal.calc('cashTendered'));
				}
			}

			if (failed_subtotal > 0) {
				if (billpane.textbox.options.lightning && billpane.orderCurrency != '₿'
				||  billpane.textbox.options.cash && billpane.orderCurrency == '₿') {
					outputConversion('conversion', billpane.subtotal.calc('limitToBill') - failed_subtotal, convTo);
				}
				outputSubtotal('revised subtotal', billpane.subtotal.calc('limitToBill') - failed_subtotal);
				outputSubtotal('unpaid invoice subtotal', failed_subtotal);
			}

		}
	}

	for (let index = v.items.length-1; index >= 0; index--) {
		const item = v.items[index];
		const left = item.options.cash || item.options.lightning? true: false;
		const icon = item.options.emoji || item.options.cash || item.options.lightning;

		let desc = '';
		if (item.options.emoji) desc = icap((desc+' '+tr(item.options.emoji)).trim());
		if ((item.options.cash || item.options.lightning) && item.currency) desc = icap(tr(item.currency));
		if (item.options.desc) desc = icap(item.options.desc.trim());

		if (item.options.cash || item.options.lightning) {
			subtotalTrigger = true;
			if (item.currency) convTo = item.currency;
		} else if (subtotalTrigger) {
			subtotalTrigger = false;

			if (convTo != billpane.orderCurrency) {
				outputConversion('suggested conversion', billpane.subtotal.calc('limitToBill'), convTo);
			}

			outputSubtotal('subtotal', billpane.subtotal.calc('limitToBill'));
		}

		y -= halfPad + bubbleSize;

		let str = v.formatMoney(Math.round(item.unitprice * item.qty).toString(), item.currency);
		let str2 = item.qty == 1? '': v.formatQty(item.qty.toString()) + ' × ' + v.formatMoney(item.unitprice.toString(), item.currency) + ' = ';
		if (item.options.negate) {
			str = '-' + str;
			if (str2) str2 = '-' + str2;
		}
		let nmw = defaultFont.calcWidth(str) + defaultFont.calcWidth(str2);
		let emw = nmw; if (icon) emw += emojiWidth + emojiSpace;

		const descscale = 0.5;
		let exh = desc? 4+descscale*16: 0;
		let exw = defaultFont.calcWidth(desc) * descscale;

		let w = (exw > emw)? exw: emw;

		mainShapes.useProg2();
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, v.mat);
		gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
			new Float32Array((item.options.negate && !item.options.cash)? config.themeColors.uiBillCredit: config.themeColors.uiBillCharge));
		mat4.identity(m);
		mat4.translate(m,m, [Math.max(sideMargin, left?0:v.sw-sideMargin-w-bubbleRadius*2+coziness*2), y, 0]);
		mat4.scale(m,m, [bubbleRadius*2, bubbleRadius*2, 1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
		mainShapes.drawArrays2('circle');
		mat4.identity(m);
		mat4.translate(m,m, [Math.max(sideMargin, left?0:v.sw-sideMargin-w-bubbleRadius*2+coziness*2), y-exh, 0]);
		mat4.scale(m,m, [bubbleRadius*2, bubbleRadius*2, 1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
		mainShapes.drawArrays2('circle');
		mat4.identity(m);
		mat4.translate(m,m, [Math.min(v.sw-sideMargin, left?sideMargin+w+bubbleRadius*2-coziness*2:v.sw), y, 0]);
		mat4.scale(m,m, [-bubbleRadius*2, bubbleRadius*2, 1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
		mainShapes.drawArrays2('circle');
		mat4.identity(m);
		mat4.translate(m,m, [Math.min(v.sw-sideMargin, left?sideMargin+w+bubbleRadius*2-coziness*2:v.sw), y-exh, 0]);
		mat4.scale(m,m, [-bubbleRadius*2, bubbleRadius*2, 1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
		mainShapes.drawArrays2('circle');
		mat4.identity(m);
		mat4.translate(m,m, [Math.max(sideMargin+bubbleRadius, left?0:v.sw-sideMargin-bubbleRadius+coziness*2-w) * 1, y-exh, 0]);
		mat4.scale(m,m, [v.sw-sideMargin-bubbleRadius-Math.max(sideMargin+bubbleRadius, v.sw-sideMargin-bubbleRadius+coziness*2-w) * 1, 32 * 1 + exh, 1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
		mainShapes.drawArrays2('rect');
		mat4.identity(m);
		mat4.translate(m,m, [Math.max(sideMargin, left?0:v.sw-sideMargin-w-bubbleRadius*2+coziness*2) * 1, y-exh+bubbleRadius, 0]);
		mat4.scale(m,m, [v.sw-sideMargin-Math.max(sideMargin, v.sw-sideMargin-w-bubbleRadius*2+coziness*2) * 1, 32 * 1 + exh - bubbleRadius*2, 1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
		mainShapes.drawArrays2('rect');

		if (icon) {
			let emoji = item.options.emoji;
			mat4.identity(m);
			mat4.translate(m,m, [v.sw-sideMargin-bubbleRadius+coziness-w, y+8-4, 0]);
			mat4.scale(m,m, [24, 24, 1]);
			if (emoji) {
				emojiShapes.useProg4();
				gl.uniformMatrix4fv(gl.getUniformLocation(prog4, 'uProjectionMatrix'), false, v.mat);
				gl.uniformMatrix4fv(gl.getUniformLocation(prog4, 'uModelViewMatrix'), false, m);
				gl.bindTexture(gl.TEXTURE_2D, config.priceList.thumbnails);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
				emojiShapes.drawArrays4(emoji);
				if (emoji == 'lightning invoice' && item.options.success === true) {
					mat4.identity(m);
					mat4.translate(m,m, [v.sw-sideMargin-bubbleRadius+coziness-w, y+8-4, 0]);
					mat4.scale(m,m, [24/18, 24/18, 1]);
					iconFont.draw(-20,16, "\x10", config.themeColors.uiSuccessGreen, v.mat, m);
				}
				if (emoji == 'lightning invoice' && item.options.success === false) {
					mat4.identity(m);
					mat4.translate(m,m, [v.sw-sideMargin-bubbleRadius+coziness-w, y+8-4, 0]);
					mat4.scale(m,m, [24/18, 24/18, 1]);
					iconFont.draw(-20,16, "\x1C", config.themeColors.uiErrorRed, v.mat, m);
				}
			}
			if (item.options.cash) {
				mat4.identity(m);
				mat4.translate(m,m, [sideMargin+bubbleRadius-coziness, y+8-4, 0]);
				mat4.scale(m,m, [24/40, 24/40, 1]);
				iconFont.draw(-1,30, "\x1E", config.themeColors.uiFiatGreen, v.mat, m);
			}
			if (item.options.lightning) {
				mat4.identity(m);
				mat4.translate(m,m, [sideMargin+bubbleRadius-coziness, y+8-4, 0]);
				mat4.scale(m,m, [24/12, 24/12, 1]);
				iconFont.draw(-18/3/2, 16-18/3/2, "\x14", config.themeColors.uiLightningPurple, v.mat, m);
				iconFont.draw(-20,0, "\x13", config.themeColors.uiLightningYellow, v.mat, m);
			}
			w -= emojiWidth+emojiSpace;
		}

		w = nmw;

		mat4.identity(m);
		mat4.translate(m,m, [left?sideMargin+bubbleRadius-coziness+emojiWidth+emojiSpace:v.sw-sideMargin-bubbleRadius+coziness-w, y+8+14, 0]);
		if (str2) {
			defaultFont.draw(0,0, str2, (item.options.negate && !item.options.cash)? config.themeColors.uiBillCreditTextLight: config.themeColors.uiBillChargeTextLight, v.mat, m);
		}
		defaultFont.draw(0,0, str, (item.options.negate && !item.options.cash)? config.themeColors.uiBillCreditText: config.themeColors.uiBillChargeText, v.mat, m);

		y -= exh;
		w = (exw > emw)? exw: emw;

		mat4.identity(m);
		mat4.translate(m,m, [left?sideMargin+bubbleRadius-coziness:v.sw-sideMargin-bubbleRadius+coziness-w, y+8+14*descscale, 0]);
		mat4.scale(m,m, [descscale,descscale, 1]);
		defaultFont.draw(0,0, desc, (item.options.negate && !item.options.cash)? config.themeColors.uiBillCreditText: config.themeColors.uiBillChargeText, v.mat, m);

		y -= halfPad;
	}

	v.minY = Math.min(0, y);
	v.maxY = v.sh;
};

billpane.subtotal = v = new vp.View();
v.name = Object.keys({'billpane_subtotal':0}).pop();
v.height = 1 * (16 + 8+8 + 4 + 2 + 4);
v.gadgets.push(v.trashGad = g = new vp.Gadget(v));
	g.actionFlags = vp.GAF_CLICKABLE;
	g.todo = false;
	g.layoutFunc = function() {
		var g = this, v = g.viewport, s = v.getScale();
		g.w = v.sh*3/5; g.h = v.sh*3/5;
		g.x = (v.sh - g.w)/2; g.y = (v.sh - g.h)/2; g.z = 1;
		g.autoHull();
	}
	g.renderFunc = function() {
		const g = this;
		const mat = mat4.create();
		mat4.identity(mat);
		mat4.translate(mat,mat, [g.x,g.y,0]);
		mat4.scale(mat,mat, [g.h/18,g.h/18,1]);
		iconFont.draw(0,16, g.todo? "\x03": "\x07", config.themeColors.uiBillSubtotalLabel, g.viewport.mat, mat);
	}
	g.clickFunc = function() {
		const g = this;
		if (g.todo) {
			billpane.clearData();
			delete billpane.lastLoadedKey;
		} else {
			transitionTo(home, 'min');
		}
	}
v.gadgets.push(v.saveGad = g = new vp.Gadget(v));
	g.actionFlags = vp.GAF_CLICKABLE;
	g.changed = false;
	g.layoutFunc = function() {
		var g = this, v = g.viewport, s = v.getScale();
		g.w = v.sh*3/5; g.h = v.sh*3/5;
		g.x = v.sw - v.sh + (v.sh - g.w)/2; g.y = (v.sh - g.h)/2; g.z = 1;
		g.autoHull();
	}
	g.renderFunc = function() {
		const g = this;
		const mat = mat4.create();
		mat4.identity(mat);
		mat4.translate(mat,mat, [g.x,g.y,0]);
		mat4.scale(mat,mat, [g.h/18,g.h/18,1]);
		iconFont.draw(0,16, g.changed? "\x10": "\x11", config.themeColors.uiBillSubtotalLabel, g.viewport.mat, mat);
	}
	g.clickFunc = function() {
		const g = this;
		if (g.changed) {
			billpane.saveData();
			billpane.locked = true;
		} else {
			billpane.loadData();
			billpane.locked = true;
		}
	}
v.calc = function(mode) {
	let subtotal = 0;
	switch (mode) {
	case 'cashTendered':
		for (const item of billpane.items) if (item.options.cash || item.options.lightning) {
			subtotal -= Math.round((item.options.negate? -1:1) * Math.round((item.options.cash? -1:1) * item.unitprice * item.qty));
		}
		break;
	case 'lightningPaid':
		for (const item of billpane.items) {
			if (item.options.lightning) subtotal += Math.round((item.options.negate? -1:1) * item.unitprice * item.qty);
		}
		break;
	case 'limitToBill':
		for (const item of billpane.items) {
			if (item.options.cash || item.options.lightning) break;
			subtotal += Math.round((item.options.negate? -1:1) * Math.round((item.options.cash? -1:1) * item.unitprice * item.qty));
		}
		break;
	default:
		for (const item of billpane.items) {
			if (mode == 'excludeFailed' && item.options.emoji == 'lightning invoice' && item.options.success === false) {} else {
				subtotal += Math.round((item.options.negate? -1:1) * Math.round((item.options.cash? -1:1) * item.unitprice * item.qty));
			}
			if (item.currency && item.currency != billpane.orderCurrency) subtotal = 0;
		}
	}
	return Math.round(subtotal);
}
v.includesCash = function() {
	for (const item of billpane.items) {
		if (item.options.cash) return true;
	}
	return false;
}
v.enableGads = function() {
	{
		if (billpane.items.length == 0 && billpane.textbox.text == '' && JSON.stringify(billpane.textbox.options) == '{}')
			billpane.changed = false;

		let enableState = billpane.changed;
		if (enableState !== billpane.subtotal.saveGad.changed) {
			billpane.subtotal.saveGad.changed = enableState;
			billpane.subtotal.setRenderFlag(true);
		}
	}

	{
		let enableState = billpane.items.length > 0 || billpane.textbox.text != '' || JSON.stringify(billpane.textbox.options) != '{}';
		if (enableState !== billpane.subtotal.trashGad.todo) {
			billpane.subtotal.trashGad.todo = enableState;
			billpane.subtotal.setRenderFlag(true);
		}
	}
}
v.layoutFunc = function() {
	for (const g of this.gadgets) {
		if (g.layoutFunc) g.layoutFunc.call(g);
	}
}
v.renderFunc = function() {
	//drawThemeBackdrop(this, config.themeColors);
	gl.clearColor(...config.themeColors.uiBillSubtotalArea);
	gl.clear(gl.COLOR_BUFFER_BIT);
	const v = this;
	const m = mat4.create();

	let subtotal = v.calc('excludeFailed');

	{
		let y = 4;

		let str = icap(subtotal < 0? tr('change due')+': ': v.includesCash()? tr('remaining: '): tr('subtotal: '));
		let str2 = billpane.formatMoney(Math.round(Math.sign(subtotal)*subtotal).toString());
		let w = defaultFont.calcWidth(str + str2);

		mainShapes.useProg2();
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, v.mat);
		mat4.identity(m);
		//mat4.scale(m,m, [50/32, 50/32, 1]);
		mat4.translate(m,m, [(v.sw-w)/2 - 16, y, 0]);
		mat4.scale(m,m, [32, 32, 1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
		gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
			new Float32Array(subtotal < 0 && !v.includesCash()? config.themeColors.uiBillCredit: config.themeColors.uiBillCharge));
		mainShapes.drawArrays2('circle');
		mat4.identity(m);
		mat4.translate(m,m, [(v.sw+w)/2 - 16, y, 0]);
		//mat4.scale(m,m, [50/32, 50/32, 1]);
//		mat4.translate(m,m, [-8/2, y, 0]);
		mat4.scale(m,m, [32, 32, 1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
		mainShapes.drawArrays2('circle');
		mat4.identity(m);
		mat4.translate(m,m, [(v.sw-w)/2, y, 0]);
		mat4.scale(m,m, [w * 1, 32 * 1, 1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
		mainShapes.drawArrays2('rect');

		mat4.identity(m);
		//mat4.translate(m,m, [v.sw/2, y, 0]);
		//mat4.scale(m,m, [50/32, 50/32, 1]);
		mat4.translate(m,m, [(v.sw-w)/2, y + 8+14, 0]);
		defaultFont.draw(0,0, str, subtotal < 0 && !v.includesCash()? config.themeColors.uiBillCreditText: config.themeColors.uiBillSubtotalLabel, v.mat, m);
		defaultFont.draw(0,0, str2, subtotal < 0 && !v.includesCash()? config.themeColors.uiBillCreditText: config.themeColors.uiBillChargeText, v.mat, m);
	}

	mainShapes.useProg5();
	gl.enable(gl.BLEND);
	gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
		new Float32Array([1,1,1,1]));
	gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uProjectionMatrix'), false, this.mat);
	for (const g of this.gadgets) {
		if (g.renderFunc) g.renderFunc.call(g);
	}
};
billpane.textbox = v = new vp.View();
v.name = Object.keys({'billpane_textbox':0}).pop();
v.height = 50/32 * (16 + 8+8 + 4 + 2);
v.cursorState = true;
v.beam = true;
v.text = '';
v.lastUserText = '';
v.state = 'start';
v.options = {};
Object.defineProperty(v, "currency", {
	get : function () {
		if (this.options.lightning) return '₿';
		if (this.options.cash) return config.cashCurrency;
		try { return config.mainCurrency; } catch (e) {}
	}
});
v.gadgets.push(v.contextGad = g = new vp.Gadget(v));
	g.actionFlags = vp.GAF_CONTEXTMENU; g.z = -1;
	g.contextMenuFunc = function() {
		const v = billpane.textbox;
		if (v.text != '' || JSON.stringify(v.options) != '{}' || !config.lightningScanningEnabled) return;
		if (navigator.clipboard.readText) navigator.clipboard.readText().then((clipText) => {
			if (clipText.toLowerCase().startsWith('lnbc')) {
				v.pasteInvoice(clipText);
			}
		});
	}
v.gadgets.push(v.itemGad = g = new vp.Gadget(v));
	g.actionFlags = vp.GAF_CLICKABLE;
	g.x = 8+10; g.y = 4+10; g.enabledY = g.y;
	g.w = 30; g.h = 30;
	g.autoHull();
	g.clickFunc = function() {
		emojipane.callback = function(label, command) {
      if (label) {
        billpane.textbox.options.emoji = label;
        delete billpane.textbox.options.barcode;
        billpane.textbox.queryPrice(label);
        billpane.textbox.resetGads();
        billpane.changed = true;
        billpane.subtotal.enableGads();
      }
      if (command == 'clear') {
        delete billpane.textbox.options.emoji;
        delete billpane.textbox.options.barcode;
        //billpane.textbox.queryPrice(label);
        billpane.textbox.resetGads();
        billpane.changed = true;
        billpane.subtotal.enableGads();
      }
		}
		vp.pushRoot(emojipane);
	}
v.gadgets.push(v.scanGad = g = new vp.Gadget(v));
	g.actionFlags = vp.GAF_CLICKABLE;
	g.x = 8+10+50; g.normalX = g.x; g.y = -1000;
	g.w = 30; g.h = 30;
	g.autoHull();
	g.clickFunc = function() {
		const g = this, v = g.viewport;
		if (v.scanMode) {
			g.stopScanner();
			delete v.scanMode;
		} else {
			v.scanMode = true;
			g.startScanner();
		}
		v.resetGads();
		v.queueLayout();
	}
	g.scanFunc = function(barcode) {
		const g = billpane.textbox.scanGad, v = billpane.textbox;
		if (v.scanMode) {
			g.stopScanner();
			delete v.scanMode;
			vp.beep('qr-part');
			console.log(barcode);

			if (barcode.rawValue.toLowerCase().startsWith('lnbc') && config.lightningScanningEnabled) {
				billpane.textbox.pasteInvoice(barcode.rawValue);
			} else {
				let number = barcode.rawValue;
				billpane.textbox.options.emoji = 'barcode';
				billpane.textbox.options.barcode = number;
				billpane.textbox.queryPrice('barcode-'+number);
				billpane.textbox.resetGads();
				billpane.changed = true;
				billpane.subtotal.enableGads();
			}
		}
	}
	g.startScanner = function(clear = true) {
		var g = this, v = g.viewport;
		g.scanSession = BarcodeScanner.beginSession(g.scanFunc);
		//if (clear) { g.linkedBarcode = ''; }
	}
	g.stopScanner = function() {
		var g = this;
		BarcodeScanner.endSession(g.scanSession);
		delete g.scanSession;
	}
v.gadgets.push(v.cashGad = g = new vp.Gadget(v));
	g.actionFlags = vp.GAF_CLICKABLE;
	g.x = 8+10+50+50; g.normalX = g.x; g.y = -1000;
	g.w = 30; g.h = 30;
	g.autoHull();
	g.clickFunc = function() {
		const v = this.viewport;
		if (!v.options.cash) {
			billpane.changed = true;
			billpane.subtotal.enableGads();
			delete billpane.textbox.options.negate;
			billpane.textbox.options.cash = true;
//			billpane.beginConversionRateQuery(billpane.subtotal.calc(true), billpane.orderCurrency, billpane.textbox.currency);
			billpane.textbox.resetGads();
			billpane.textbox.queueLayout();
			billpane.setRenderFlag(true);
		} else if (!billpane.subtotal.includesCash()) {
			billpane.changed = true;
			billpane.subtotal.enableGads();
			delete billpane.textbox.options.negate;
			delete billpane.textbox.options.cash;
			billpane.textbox.resetGads();
			billpane.textbox.queueLayout();
			billpane.setRenderFlag(true);
		} else if (!v.options.change) {
			v.finishCash();
		}
	}
v.pasteInvoice = function(invoice) {
	billpane.textbox.options.emoji = 'lightning invoice';
	billpane.textbox.options.barcode = invoice;
	config.wallet.readInvoice(invoice, (sats, desc) => {
		billpane.textbox.options.desc = desc;
		if (billpane.textbox.text == '' && isNumber(sats)) {
			billpane.textbox.text = sats.toString()+'×';
			billpane.textbox.setRenderFlag(true);
		}
		billpane.getConversionRate(sats, '₿', billpane.orderCurrency, (rate) => {
			if (billpane.textbox.text.endsWith('×')) {
				billpane.textbox.text = billpane.textbox.text.substr(0,billpane.textbox.text.length-1) +'×'+ billpane.getOptimalDigits(rate, sats);
				billpane.textbox.setRenderFlag(true);
			}
		});
		vp.beep('qr-part');
	});
	billpane.textbox.resetGads();
	billpane.changed = true;
	billpane.subtotal.enableGads();
}
v.payInvoices = function(cb) {
	for (const item of billpane.items) if (item.options.emoji == 'lightning invoice' /*&& item.options.barcode != ''*/ && item.options.success === undefined) {
		if (config.debugBuild) {
			setTimeout(() => {
				item.options.success = (Math.random() > 0.5)? true: false;
				cb(true);
			}, 1000);
		} else {
			config.wallet.payInvoice(item.options.barcode, (success) => {
				item.options.success = (success? true: false);
				cb(true);
			});
		}
		return;
	}
	cb(false);
}
v.finishCash = function() {
	const v = this;
	if (billpane.subtotal.calc() > config.getLeeway(v.currency)) {
		vp.beep('bad');
	} else {
		const payloop = (todo) => {
			billpane.setRenderFlag(true);
			billpane.subtotal.setRenderFlag(true);
			if (todo) billpane.textbox.payInvoices(payloop);
			else {
				vp.beep('qr-part');
			}
		};
		billpane.textbox.payInvoices(payloop);
		billpane.changed = true;
		billpane.subtotal.enableGads();
		delete billpane.textbox.options.negate;
		billpane.textbox.options.change = true;
		billpane.textbox.resetGads();
		billpane.textbox.queueLayout();
		billpane.setRenderFlag(true);
	}
}
v.gadgets.push(v.lnGad = g = new vp.Gadget(v));
	g.actionFlags = vp.GAF_CLICKABLE;
	g.x = 8+10+50; g.normalX = g.x; g.y = -1000;
	g.w = 30; g.h = 30;
	g.autoHull();
	g.clickFunc = function() {
		const v = this.viewport;
		if (v.options.cash || billpane.subtotal.includesCash()) return; // sanity check
		if (!v.options.lightning) {
			billpane.changed = true;
			billpane.subtotal.enableGads();
			billpane.textbox.options.lightning = true;
			if (billpane.textbox.text == '' && billpane.textbox.currency == billpane.orderCurrency) {
				billpane.textbox.text = billpane.subtotal.calc().toString();
			}
			billpane.textbox.resetGads();
			billpane.textbox.queueLayout();
			checkoutpane.relayout();
			checkoutpane.setRenderFlag(true);
			billpane.setRenderFlag(true);
		} else if (!billpane.textbox.options.lightningpaid) {
			billpane.changed = true;
			billpane.subtotal.enableGads();
			delete billpane.textbox.options.lightning;
			billpane.textbox.resetGads();
			billpane.textbox.queueLayout();
			checkoutpane.relayout();
			checkoutpane.setRenderFlag(true);
			billpane.setRenderFlag(true);
		} else {
		}
	}
v.gadgets.push(v.signGad = g = new vp.Gadget(v));
	g.actionFlags = vp.GAF_CLICKABLE;
	g.x = -1000;
	g.y = 0;
	g.w = 0;
	g.h = 14;
	g.autoHull();
	g.clickFunc = function() {
		if (billpane.textbox.options.change) {
			//vp.beep('bad');
			return;
		}
		if (billpane.textbox.options.negate) delete billpane.textbox.options.negate;
		else billpane.textbox.options.negate = true;
		billpane.changed = true;
		billpane.subtotal.enableGads();
		billpane.textbox.resetGads();
		billpane.textbox.queueLayout();
	}
v.resetGads = function() {
	const v = this;
	if (v.options.change) {
		v.itemGad.y = -1000;
		v.scanGad.y = -1000;
		v.cashGad.y = -1000;
		v.lnGad.y = -1000;
	} else if (v.options.cash) {
		v.itemGad.y = -1000;
		v.scanGad.y = -1000;
		v.cashGad.x = v.itemGad.x;
		v.cashGad.y = v.itemGad.enabledY;
		v.lnGad.y = -1000;
	} else if (v.options.lightning) {
		v.itemGad.y = -1000;
		v.scanGad.y = -1000;
		v.cashGad.y = -1000;
		v.lnGad.x = v.itemGad.x;
		v.lnGad.y = v.itemGad.enabledY;
	} else if (v.scanMode) {
		v.itemGad.y = -1000;
		v.scanGad.x = v.itemGad.x;
		v.scanGad.y = v.itemGad.enabledY;
		v.cashGad.y = -1000;
		v.lnGad.y = -1000;
	} else if (billpane.items.length == 0 || v.options.emoji) {
		v.itemGad.y = v.itemGad.enabledY;
		if (v.text != '' || JSON.stringify(v.options) != '{}' || !config.barcodeScanningEnabled) {
			v.scanGad.y = -1000;
		} else {
			v.scanGad.x = v.scanGad.normalX;
			v.scanGad.y = v.itemGad.enabledY;
		}
		v.cashGad.y = -1000;
		v.lnGad.y = -1000;
	} else {
		v.itemGad.y = v.itemGad.enabledY;
		if (v.text != '' || JSON.stringify(v.options) != '{}' || !config.barcodeScanningEnabled) {
			v.scanGad.y = -1000;
			v.cashGad.x = v.scanGad.normalX;
		} else {
			v.scanGad.x = v.scanGad.normalX;
			v.scanGad.y = v.itemGad.enabledY;
			v.cashGad.x = v.cashGad.normalX;
		}
		if (config.cashCurrency != 'none') {
			v.cashGad.y = v.itemGad.enabledY;
		} else {
			v.cashGad.x -= 50;
			v.cashGad.y = -1000;
		}
		if (config.lightningEnabled) {
			v.lnGad.x = v.cashGad.x + 50;
			v.lnGad.y = v.itemGad.enabledY;
		} else {
			v.lnGad.y = -1000;
		}
	}
	v.itemGad.autoHull();
	v.scanGad.autoHull();
	v.cashGad.autoHull();
	v.lnGad.autoHull();
	v.queueLayout();
	if (!v.options.lightning && checkoutpane.subtotalshim.b != billpane) {
		v.resetBillPane();
	}
}
v.resetBillPane = function() {
	checkoutpane.subtotalshim.b = billpane;
	billpane.parent = checkoutpane.subtotalshim;
	checkoutpane.relayout();
	checkoutpane.setRenderFlag(true);
}
v.updatePrice = function(item, unitprice, fractionalQty, negate) {
	const newItem = {
		'item': ''+item,
		'unitprice': ''+unitprice,
		'fractionalQty': ''+fractionalQty,
		'negate': ''+negate,
	};
	console.log('Saving', newItem);
	const tx = db.transaction(["prices"], "readwrite");
	tx.onerror = (event) => { console.log("Save transaction failed."); };
	tx.oncomplete = (event) => { };
	const req = tx.objectStore("prices").put(newItem, `${getCurrentAccount().id}-${newItem.item}`);
	req.onerror = (event) => { console.log("Save request failed."); };
	req.onsuccess = (event) => { };
}
v.queryPrice = function(item) {
  var data = config.priceList.getPriceData(item)
  if (data?.price && data?.currency === billpane.orderCurrency) {
    billpane.textbox.splicePrice({ unitprice: data.price, fractionalQty: false, negate: false })
    return
  }
	var req = db.transaction(["prices"], "readonly")
		.objectStore("prices")
		.get(`${getCurrentAccount().id}-${item}`);
	req.onsuccess = (event) => {
		console.log(event.target.result);
		if (event.target.result)
			billpane.textbox.splicePrice(event.target.result);
	};
}
v.splicePrice = function(obj) {
	const v = this;
	if (obj.negate == "true") v.options.negate = true;
	else delete v.options.negate;
	const fractionalQty = obj.fractionalQty == "true";
	let str = v.lastUserText;
	if (str == '') {
		v.text = obj.unitprice + (fractionalQty?'×':'');
	} else if (str.endsWith('×')) {
		if (str.includes('.')) {
			if (fractionalQty) {
				v.text = str + obj.unitprice;
			} else {
				v.text = obj.unitprice +'×'+ str.substr(0,str.length-1);
				vp.beep('bad');
			}
		} else {
			if (fractionalQty) {
				v.text = obj.unitprice +'×'+ str.substr(0,str.length-1)+'.0';
				vp.beep('bad');
			} else {
				v.text = str + obj.unitprice;
			}
		}
	} else if (str.endsWith('.') && !str.includes('×')) {
		if (+(str+'0') == 0) {
			v.text = obj.unitprice + (fractionalQty == "true"?'×':'');
		} else {
			if (fractionalQty) {
				v.text = obj.unitprice +'×'+ str;
			} else {
				v.text = obj.unitprice +'×'+ str.substr(0, str.length-1);
				vp.beep('bad');
			}
		}
	} else if (!str.includes('×')) {
		if (str.includes('.')) {
			if (fractionalQty) {
				v.text = str +'×'+ obj.unitprice;
			} else {
				v.text = obj.unitprice +'×'+ str;
				vp.beep('bad');
			}
		} else {
			if (fractionalQty) {
				v.text = obj.unitprice +'×'+ str+'.0';
				vp.beep('bad');
			} else {
				v.text = str +'×'+ obj.unitprice;
			}
		}
	} else if (str.includes('×')) {
		let stack = str.substr(0, str.indexOf('×'));
		str = str.substr(str.indexOf('×')+1);
		if (+str == 0) {
			if (stack.includes('.')) {
				if (fractionalQty) {
					v.text = stack +'×'+ obj.unitprice;
				} else {
					v.text = obj.unitprice +'×'+ stack;
					vp.beep('bad');
				}
			} else {
				if (fractionalQty) {
					v.text = obj.unitprice +'×'+ stack+'.0';
					vp.beep('bad');
				} else {
					v.text = stack +'×'+ obj.unitprice;
				}
			}
		} else {
			if (fractionalQty) {
				if (stack.includes('.')) {
					v.text = stack +'×'+ obj.unitprice;
					vp.beep('bad');
				} else if (str.includes('.')) {
					v.text = str +'×'+ obj.unitprice;
					vp.beep('bad');
				} else if (+stack > +str) {
					v.text = obj.unitprice +'×'+ str+'.0';
					vp.beep('bad');
				} else {
					v.text = obj.unitprice +'×'+ stack+'.0';
					vp.beep('bad');
				}
			} else {
				if (stack.includes('.')) {
					v.text = obj.unitprice +'×'+ stack;
					vp.beep('bad');
				} else if (str.includes('.')) {
					v.text = obj.unitprice +'×'+ str;
					vp.beep('bad');
				} else if (+stack > +str) {
					v.text = str +'×'+ obj.unitprice;
					vp.beep('bad');
				} else {
					v.text = stack +'×'+ obj.unitprice;
					vp.beep('bad');
				}
			}
		}
	}
	billpane.changed = true;
	billpane.setRenderFlag(true);
	billpane.subtotal.setRenderFlag(true)
	v.setRenderFlag(true);
}
v.pasteFunc = function(e) {
	let clipText = e.clipboardData.getData('text/plain');
	if (clipText.toLowerCase().startsWith('lnbc') && config.lightningScanningEnabled) {
		billpane.textbox.pasteInvoice(clipText);
	}
}
v.keypadFunc = function(code, key) {
	const v = this;
	const isNum = (code >= 0 && code <= 9);
	const maxLen = 15;
	if (v.options.change
	|| (checkoutpane.subtotalshim.b != billpane && code != keypadpane.keyBack && code != keypadpane.keyEnter)) {
		if (code >= 0 || (code == -1 && key == '-')) vp.beep('bad');
		return;
	}
	switch (v.state) {
	case 'start':
		if (isNum) {
			let str = v.text + code.toString();
			let stack = '';
			if (str.includes('×')) {
				stack = str.substr(0, str.indexOf('×'));
				str = str.substr(str.indexOf('×')+1);
			}
			if (str.startsWith('0') && str.length > 1 && str.substr(1,1) != '.') str = str.substr(1);
			if (str.startsWith('00')) {
				vp.beep('bad');
			} else {
				if (stack) {
					str = stack + '×' + str;
				}
				if (str.length > maxLen) {
					vp.beep('bad');
				} else {
					v.text = str;
					billpane.changed = true;
					//vp.beep('click');
				}
			}
		}
		if (code == keypadpane.keyPoint) {
			let str = v.text;
			if (str == '') str = '0';
			if (str.endsWith('×')) str += '0';
			if (str.includes('.') || str.length >= maxLen) {
				vp.beep('bad');
			} else {
				v.text = str + '.';
				billpane.changed = true;
				//vp.beep('click');
			}
		}
		if (code == keypadpane.keyTimes) {
			let str = v.text;
			if (str == '' || str.includes('×') || str.endsWith('.') || (+str == 0) || str.length >= maxLen) {
				vp.beep('bad');
			} else {
				v.text = str + '×';
				billpane.changed = true;
				//vp.beep('click');
			}
		}
		if (code == keypadpane.keyBack) {
			if (checkoutpane.subtotalshim.b != billpane) {
				v.resetBillPane();
			} else if (v.text != '') {
				v.text = v.text.substr(0, v.text.length-1);
				billpane.changed = true;
				//vp.beep('click');
			} else if (v.options.negate) {
				delete v.options.negate;
				billpane.changed = true;
				//vp.beep('click');
			} else if (v.options.emoji) {
				delete v.options.emoji;
				delete v.options.barcode;
				delete v.options.cash;
				delete v.options.lightning;
				delete v.options.desc;
				billpane.changed = true;
				//vp.beep('click');
			} else if (v.options.cash && !billpane.subtotal.includesCash()) {
				v.cashGad.clickFunc();
				//vp.beep('click');
			} else if (v.options.lightning && !billpane.textbox.options.lightningpaid) {
				v.lnGad.clickFunc();
				//vp.beep('click');
			} else if (v.scanMode) {
				billpane.textbox.scanGad.stopScanner();
				delete v.scanMode;
				v.resetGads();
				v.queueLayout();
			}
		}
		if (code == keypadpane.keyEnter) {
			let str = v.text;
			if (str == '' || str.endsWith('×') || str.endsWith('.') || (str.includes('.') && !str.includes('×'))) {
				if (str == '') {
					if (v.options.cash && !v.options.change)
						v.finishCash();
				} else vp.beep('bad');
			} else {
				let stack = '';
				if (str.includes('×')) {
					stack = str.substr(0, str.indexOf('×'));
					str = str.substr(str.indexOf('×')+1);
				} else {
					stack = '1';
				}
				if ((+str) * (+stack) == 0) {
					vp.beep('bad');
				} else {
					let money = '', qty = '';
					if (stack.includes('.')) {
						money = str;
						qty = stack;
					} else if (str.includes('.')) {
						money = stack;
						qty = str;
					} else if (+stack > +str) {
						money = stack;
						qty = str;
					} else {
						money = str;
						qty = stack;
					}
					if (v.options.emoji) {
						let item = v.options.emoji;
						if (v.options.barcode) item = item + '-' + v.options.barcode;
						if (qty.includes('.')) {
							v.updatePrice(item, +money, true, v.options.negate == true);
						} else {
							v.updatePrice(item, +money, false, v.options.negate == true);
						}
					}
					const cashphase = v.options.cash;
					const lnphase = v.options.lightning;
					const completionlogic = () => {
						if (v.currency != billpane.orderCurrency)
							billpane.items.push({qty:+qty, unitprice:+money, currency:v.currency, options:v.options});
						else
							billpane.items.push({qty:+qty, unitprice:+money, options:v.options});
						billpane.changed = true;
						billpane.userY = 0;
						//billpane.swipeGad.doSwipe(true);
						billpane.queueLayout();
						billpane.subtotal.setRenderFlag(true)
						v.text = '';
						v.options = {};
						if (cashphase) {
							v.options.cash = true;
							delete v.options.negate;
						}
						if (lnphase) {
							v.options.change = true;
							delete v.options.negate;
						}
						v.resetGads();
						v.queueLayout();
						vp.beep('qr-scan');
					}

					if (v.options.lightning) {
						if (checkoutpane.subtotalshim.b == billpane && !lightningqr.netBusy) {
							lightningqr.clear();
							checkoutpane.subtotalshim.b = lightningqr; lightningqr.parent = checkoutpane.subtotalshim;
							checkoutpane.relayout();
							checkoutpane.setRenderFlag(true);
							switch (config.walletType) {
							case 'manual':
								lightningqr.walletSignal = true;
								billpane.textbox.options.hashes = [];
								billpane.changed = true;
								break;
							case 'LNbits compatible':
								if (!lightningqr.netBusy) {
									lightningqr.netBusy = true;
									lightningqr.clear();
									lightningqr.busySignal = true;
									config.wallet.generateInvoice((+qty) * (+money), (invoice, id) => {
										if (invoice && invoice.startsWith('lnbc') && id) {
											lightningqr.qr = [invoice];
											if (!billpane.textbox.options.hashes)
												billpane.textbox.options.hashes = [];
											billpane.textbox.options.hashes.push(id);
											billpane.changed = true;
										} else {
											lightningqr.errorSignal = true;
											console.error('Wallet did not generate a recognized invoice type.');
										}
										lightningqr.setRenderFlag(true);
										lightningqr.busySignal = false;
										lightningqr.netBusy = false;
									});
								}
								break;
							default:
							}
						} else if (billpane.textbox.options.hashes && !lightningqr.netBusy) {
							switch (config.walletType) {
							case 'manual':
								completionlogic();
								break;
							case 'LNbits compatible':
								if (!lightningqr.netBusy) {
									lightningqr.netBusy = true;
									config.wallet.checkInvoice(billpane.textbox.options.hashes[billpane.textbox.options.hashes.length-1], (result) => {
										lightningqr.netBusy = false;
										if (result && result.paid) completionlogic();
										else vp.beep('bad');
									});
								}
								break;
							default:
							}
						} else {
							vp.beep('bad');
						}
					} else {
						completionlogic();
					}
				}
			}
		}
		if (code == -1 && key == '-') {
			billpane.textbox.signGad.clickFunc();
		}
		v.lastUserText = v.text;
		v.resetGads();
		v.queueLayout();
		v.setRenderFlag(true);
		billpane.subtotal.enableGads()
		break;
	}
}
{
	for (let g of keypadpane.keypad) {
		g.target = billpane.textbox;
	}
	keypadpane.target = billpane.textbox;
}
v.layoutFunc = function() {
	let g = billpane.textbox.contextGad;
	g.x = 4; g.y = 2;
	g.w = v.sw-8; g.h = 32;
	g.autoHull();
}
v.renderFunc = function() {
	drawThemeBackdrop(this, config.themeColors);
	const v = this;
	const m = mat4.create();

	vp.beginInput(keypadpane.inputGad); // TODO: This gets reset by clicks/taps. Need to fix.

	mainShapes.useProg2();
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, v.mat);

	mat4.identity(m);
	mat4.scale(m,m, [50/32, 50/32, 1]);
	mat4.translate(m,m, [4, 2, 0]);
	mat4.scale(m,m, [32, 32, 1]);
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
	gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
		new Float32Array(config.themeColors.uiDataEntryArea));
	mainShapes.drawArrays2('circle');
	mat4.identity(m);
	mat4.translate(m,m, [v.sw, 0, 0]);
	mat4.scale(m,m, [50/32, 50/32, 1]);
	mat4.translate(m,m, [-4, 2, 0]);
	mat4.scale(m,m, [-32, 32, 1]);
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
	mainShapes.drawArrays2('circle');
	mat4.identity(m);
	mat4.translate(m,m, [(4+16) * 50/32, 2 * 50/32, 0]);
	mat4.scale(m,m, [v.sw-(8+32) * 50/32, 32 * 50/32, 1]);
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
	mainShapes.drawArrays2('rect');

	if (!billpane.textbox.options.change) {
		if (v.cursorState) {
			mat4.identity(m);
			mat4.translate(m,m, [v.sw, 0, 0]);
			mat4.scale(m,m, [50/32, 50/32, 1]);
			mat4.translate(m,m, [-4-16-1, 2+8, 0]);
			mat4.scale(m,m, [2, 16, 1]);
			gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
			gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
				new Float32Array(config.themeColors.uiDataEntryCursor));
			mainShapes.drawArrays2('rect');
		}
	}

	// item emoji gadget
	{
		let g = v.itemGad;

		if (!v.options.emoji) {
			mat4.identity(m);
			mat4.translate(m,m, [g.x, g.y, 0]);
			mat4.scale(m,m, [g.w/18, g.h/18, 1]);
			iconFont.draw(0,16, "\x15", config.themeColors.uiDataEntryGhostText, v.mat, m);
		} else {
			let emoji = billpane.textbox.options.emoji;
			mat4.identity(m);
			mat4.translate(m,m, [g.x, g.y, 0]);
			mat4.scale(m,m, [g.w, g.h, 1]);
			emojiShapes.useProg4();
			gl.uniformMatrix4fv(gl.getUniformLocation(prog4, 'uProjectionMatrix'), false, v.mat);
			gl.uniformMatrix4fv(gl.getUniformLocation(prog4, 'uModelViewMatrix'), false, m);
			gl.uniform4fv(gl.getUniformLocation(prog4, 'overallColor'),
				new Float32Array([1,1,1,1]));
			gl.bindTexture(gl.TEXTURE_2D, config.priceList.thumbnails);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
			emojiShapes.drawArrays4(emoji);
		}
	}

	// scan barcode gadget
	{
		let g = v.scanGad;

		mat4.identity(m);
		mat4.translate(m,m, [g.x, g.y+g.h/20*1, 0]);
		mat4.scale(m,m, [g.w/20, g.h/20, 1]);
		iconFont.draw(0,16, "\x04", v.scanMode? alpha(config.themeColors.uiDataEntryText, 0.5): config.themeColors.uiDataEntryGhostText, v.mat, m);
		if (v.scanMode) {
			if (v.beam) {
				mainShapes.useProg2();
				gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, v.mat);
				gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
					new Float32Array(config.themeColors.uiBarcodeScannerBeam));
				mat4.identity(m);
				mat4.translate(m,m, [g.x-4, g.y+g.h/2-0.5, 0]);
				mat4.scale(m,m, [g.w+8, 1, 1]);
				gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
				mainShapes.drawArrays2('rect');
			}
			if (v.beam != v.beamPrev) {
				v.beamPrev = v.beam;
				billpane.textbox.beamtimerId = setTimeout(() => { billpane.textbox.beam = !billpane.textbox.beam; billpane.textbox.setRenderFlag(true); }, 50);
			}
		}
	}

	// cash payment gadget
	{
		let g = v.cashGad;

		mat4.identity(m);
		mat4.translate(m,m, [g.x, g.y, 0]);
		mat4.scale(m,m, [g.w/38, g.w/38, 1]);
		iconFont.draw(-1,32, "\x1E", (v.options.cash && !v.options.change)? config.themeColors.uiFiatGreen: config.themeColors.uiDataEntryGhostText, v.mat, m);
	}

	// lightning payment gadget
	{
		let g = v.lnGad;

		mat4.identity(m);
		mat4.translate(m,m, [g.x, g.y, 0]);
		mat4.scale(m,m, [g.w/12, g.h/12, 1]);
		iconFont.draw(-18/3/2, 16-18/3/2, "\x14", billpane.textbox.options.lightning? config.themeColors.uiLightningPurple: config.themeColors.uiDataEntryGhostText, v.mat, m);
		iconFont.draw(-20,0, "\x13", billpane.textbox.options.lightning? config.themeColors.uiLightningYellow: config.themeColors.uiDataEntryGhostText, v.mat, m);
	}

	// change gadget
/*
	{
		let g = v.changeGad;

		mat4.identity(m);
		mat4.translate(m,m, [g.x, g.y, 0]);
		mat4.scale(m,m, [g.w/23, g.h/23, 1]);
		financeGraphicsFont.draw(0,24, "\x44", v.options.change? config.themeColors.uiFiatGreen: config.themeColors.uiDataEntryGhostText, v.mat, m);
	}
*/

	mat4.identity(m);
	mat4.translate(m,m, [v.sw, 0, 0]);
	mat4.scale(m,m, [50/32, 50/32, 1]);
	mat4.translate(m,m, [-4-16, 2+8+14, 0]);
	if (v.text) {
		let str = v.text, stack = '';
		if (str.includes('×')) {
			stack = str.substr(0, str.indexOf('×'));
			str = str.substr(str.indexOf('×')+1);
		}
//		if (stack && ((+stack < 10 * (+str) && +stack > 0) || (+str < 10 * (+stack) && +str > 0))) {
			if (stack) {
				if (stack.includes('.')) {
					str = billpane.formatMoney(str, v.currency);
					stack = billpane.formatQty(stack);
				} else if (str.includes('.')) {
					stack = billpane.formatMoney(stack, v.currency);
					str = billpane.formatQty(str);
				} else if (+stack > +str) {
					stack = billpane.formatMoney(stack, v.currency);
					str = billpane.formatQty(str);
				} else {
					str = billpane.formatMoney(str, v.currency);
					stack = billpane.formatQty(stack);
				}
			} else {
				if (str.includes('.')) {
					str = billpane.formatQty(str);
				} else {
					str = billpane.formatMoney(str, v.currency);
				}
			}
//		}
		if (stack) {
			str = stack + ' × ' + str;
		}
		let w = defaultFont.calcWidth(str);
		mat4.translate(m,m, [-w, 0, 0]);
		defaultFont.draw(0,0, str, config.themeColors.uiDataEntryText, v.mat, m);
		mat4.translate(m,m, [-w, 0, 0]);
	}
	if (true) { // show sign hint
		let str = v.options.negate? '- ': '+ ';
		let w = defaultFont.calcWidth(str);
		mat4.translate(m,m, [-w, 0, 0]);
		let pos0 = vec3.create(); mat4.getTranslation(pos0, m);
		defaultFont.draw(0,0, str, v.options.negate? config.themeColors.uiDataEntryText: config.themeColors.uiDataEntryGhostText, v.mat, m);
		let pos1 = vec3.create(); mat4.getTranslation(pos1, m);
		
		// Update sign gadget geometry in real time.
		let g = billpane.textbox.signGad;
		g.x = pos0[0];
		g.y = pos0[1] - 14;
		g.w = pos1[0] - pos0[0];
		g.h = 16;
		g.autoHull();
	}

	if (v.cursorState != v.cursorPrev) {
		v.cursorPrev = v.cursorState;
		billpane.textbox.timerId = setTimeout(() => { billpane.textbox.cursorState = !billpane.textbox.cursorState; billpane.textbox.setRenderFlag(true); }, 500);
	}
};


var checkoutpane = v = new vp.DividerView(null, 'a', 0.5, 0);
v.name = Object.keys({checkoutpane}).pop();
v.designSize = 640*400;
{
	let v = checkoutpane.textboxshim = new vp.SliceView(null, 'b', billpane.textbox.height);
	v.name = Object.keys({'checkoutpane_textboxshim':0}).pop();
	{
		let v = checkoutpane.subtotalshim = new vp.SliceView(null, 't', billpane.subtotal.height);
		v.name = Object.keys({'checkoutpane_subtotalshim':0}).pop();
		v.a = billpane.subtotal; billpane.subtotal.parent = v;
		v.b = billpane; billpane.parent = v;
	}
	v.a = billpane.textbox; billpane.textbox.parent = v;
	v.b = checkoutpane.subtotalshim; checkoutpane.subtotalshim.parent = v;
}
v.a = v.textboxshim; v.textboxshim.parent = v;
v.b = keypadpane; keypadpane.parent = v;
v.layoutBeginFunc = function() {
	const v = this;
	function setRatio(v,r) { // doesn't help
		if (r != v.ratio) {
			v.ratio = r;
			v.queueLayout();
		}
	}
	if (v.state != 'v' && v.sh > 2 * v.sw) {
		setRatio(v, 1 - v.sw/v.sh);
	} else {
		setRatio(v, 0.5);
	}
}
var pmtbuttonbar = v = new vp.View(null);
v.name = Object.keys({pmtbuttonbar}).pop();
v.designFit = [400,50];
/*
v.gadgets.push(v.homeGad = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x00";
	g.renderFunc = function() {
		var g = this;
		var sel = clickTapActive.includes(g.gestureState);
		const mat = mat4.create();
		mat4.identity(mat);
		mat4.translate(mat, mat, [g.x, g.y, 0]);
		mat4.scale(mat, mat, [g.w/18, g.h/18, 0]);
		mat4.translate(mat, mat, [-1, 16, 0]);
		iconFont.draw(0,0, g.icon,
			g.enabled?(sel?config.themeColors.uiButtonSel:config.themeColors.uiButton):config.themeColors.uiButtonGhost,
			g.viewport.mat, mat);
	}
	g.clickFunc = function() {
		if (paymentpane.scanner) {
			paymentpane.scanner.destroy();
			paymentpane.scanner = undefined;
		}
		paymentpane.playing = false;
		paymentpane.timeupdate = false;
		paymentpane.updateFlag = false;
		delete paymentmain.designFit;
		transitionTo(home, 'min');
	}
v.gadgets.push(v.pushGad = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = 50 + (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x01";
	g.enabled = false;
	g.renderFunc = v.homeGad.renderFunc;
	g.clickFunc = function() {
		console.log('pushGad');
	}
v.gadgets.push(v.popGad = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = 100 + (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x02";
	g.enabled = false;
	g.renderFunc = v.homeGad.renderFunc;
	g.clickFunc = function() {
		console.log('popGad');
	}
v.gadgets.push(v.trashGad = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = 150 + (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x03";
	g.enabled = false;
	g.renderFunc = v.homeGad.renderFunc;
	g.clickFunc = function() {
		if (window.confirm(tr("Discard this invoice?"))) {
			dataentry.clearDataEntry();
			invoicepane.invoiceitems = [];
			invoicepane.setRenderFlag(true);
			checkoutpages.toPage(0);
		}
	}
v.layoutFunc = function() {
	var totalW = 0; for (const g of this.gadgets) totalW += g.w;
	var space = (this.w / this.getScale() - totalW) / (this.gadgets.length * 2);
	var x = 0;
	for (const g of this.gadgets) {
		g.x = x + space;
		x += space + g.w + space;
	}
}
v.renderFunc = function() {
	const th = config.themeColors;
	gl.clearColor(...th.uiBackground);
	gl.clear(gl.COLOR_BUFFER_BIT);
	for (const g of this.gadgets) {
		if (g.renderFunc) g.renderFunc.call(g);
	}
}
*/

var paymentmain = v = new vp.View(null);
v.name = Object.keys({paymentmain}).pop();
v.gadgets.push(v.homeGad = g = new vp.Gadget(v));
	g.refw = 30; g.refh = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.w = g.refw; g.h = g.refh; g.x = (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x00";
	g.renderFunc = function() {
		const th = config.themeColors, g = this;
		var sel = clickTapActive.includes(g.gestureState);
		var color = g.enabled? th.uiButton: th.uiButtonGhost;
		if (g.viewport.overlaymode)
			color = g.enabled? th.uiVideoOverlayButton: th.uiVideoOverlayButtonGhost;
		if (sel) color = th.uiButtonSel;
		const mat = mat4.create();
		mat4.identity(mat);
		mat4.translate(mat, mat, [g.x, g.y, 0]);
		mat4.scale(mat, mat, [g.w/18, g.h/18, 0]);
		mat4.translate(mat, mat, [-1, 16, 0]);
		iconFont.draw(0,0, g.icon, color, g.viewport.mat, mat);
	}
	g.clickFunc = function() {
		if (paymentpane.scanner) {
			paymentpane.scanner.destroy();
			paymentpane.scanner = undefined;
		}
		paymentpane.playing = false;
		paymentpane.timeupdate = false;
		paymentpane.updateFlag = false;
		delete paymentmain.designFit;
		transitionTo(home, 'min');
	}
v.gadgets.push(v.pushGad = g = new vp.Gadget(v));
	g.refw = 30; g.refh = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.w = g.refw; g.h = g.refh; g.x = 50 + (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x01";
	g.enabled = false;
	g.renderFunc = v.homeGad.renderFunc;
	g.clickFunc = function() {
		console.log('pushGad');
	}
v.gadgets.push(v.popGad = g = new vp.Gadget(v));
	g.refw = 30; g.refh = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.w = g.refw; g.h = g.refh; g.x = 100 + (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x02";
	g.enabled = false;
	g.renderFunc = v.homeGad.renderFunc;
	g.clickFunc = function() {
		console.log('popGad');
	}
v.gadgets.push(v.trashGad = g = new vp.Gadget(v));
	g.refw = 30; g.refh = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.w = g.refw; g.h = g.refh; g.x = 150 + (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x03";
	g.enabled = false;
	g.renderFunc = v.homeGad.renderFunc;
	g.clickFunc = function() {
		if (window.confirm(tr("Discard this invoice?"))) {
			dataentry.clearDataEntry();
			invoicepane.invoiceitems = [];
			invoicepane.setRenderFlag(true);
			checkoutpages.toPage(0);
		}
	}
/*
function initTexture(gl) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);

  // Because video has to be download over the internet
  // they might take a moment until it's ready so
  // put a single pixel in the texture so we can
  // use it immediately.
  const level = 0;
  const internalFormat = gl.RGBA;
  const width = 1;
  const height = 1;
  const border = 0;
  const srcFormat = gl.RGBA;
  const srcType = gl.UNSIGNED_BYTE;
  const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue
  gl.texImage2D(
    gl.TEXTURE_2D,
    level,
    internalFormat,
    width,
    height,
    border,
    srcFormat,
    srcType,
    pixel
  );

  // Turn off mips and set wrapping to clamp to edge so it
  // will work regardless of the dimensions of the video.
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  return texture;
}
function updateTexture(gl, texture, video) {
  const level = 0;
  const internalFormat = gl.RGBA;
  const srcFormat = gl.RGBA;
  const srcType = gl.UNSIGNED_BYTE;
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(
    gl.TEXTURE_2D,
    level,
    internalFormat,
    srcFormat,
    srcType,
    video,
  );
}
*/
v.layoutFunc = function() {
	const v = this;
	if (!paymentpane.videoEl) return;
	if (!v.designFit) return;
	if (paymentpane.videoEl.videoWidth  != v.designFit[0]
	||  paymentpane.videoEl.videoHeight != v.designFit[1]) {
		paymentmain.designFit =
			[paymentpane.videoEl.videoWidth, paymentpane.videoEl.videoHeight];
		paymentmain.queueLayout();
		if (paymentpane.scanner) {
			paymentpane.scanner.stop();
			paymentpane.scanner.start();
		}
	}

	// Strategy: since the video might not be proportioned to fill the entire viewport,
  // adapt the layout for each scenario, placing the button bar in the position that
  // results in the most pleasing aesthetic.

	v.vidPos = [(v.sw-v.designFit[0])/2, (v.sh-v.designFit[1])/2];
	const view_aspect = v.w/v.h;
	const vid_aspect = v.designFit[0]/v.designFit[1];
	const s = v.w > v.h? v.h / 400 : v.w / 400; /* button scale determined by view size */
	var decidedlayout = '';
	v.overlaymode = false;
	var sidemax = v.sh, bottommax = v.sw;
	if (view_aspect > vid_aspect) { // wee have blank spaces on left and right
		const amt = v.w - v.h * vid_aspect;
		if (Math.ceil(amt/s) >= 50) { // it's enough empty space for the buttons, so use it
			decidedlayout = 'sidebar';
			// if necessary, shift video slightly to ensure enough space for the buttons
			if (Math.floor(amt/s) < 100) {
				v.vidPos[0] = Math.ceil(50*s/v.getScale());
			}
		} else { // it's not enough space, so overlay and decide what looks best
			v.overlaymode = true;
			if (view_aspect < 1) { // portrait, overlay the buttons within video frame
				decidedlayout = 'bottombar';
				bottommax = v.designFit[0];
			} else { // overlay, but also shift the video fully under, not to cross the edge
				decidedlayout = 'sidebar';
				v.vidPos[0] = 0;
			}
		}
	} else { // we have blank spaces on top and bottom
		const amt = v.h - v.w / vid_aspect;
		if (Math.ceil(amt/s) >= 50) { // it's enough empty space for the buttons, so use it
			decidedlayout = 'bottombar';
			// if necessary, shift video slightly to ensure enough space for the buttons
			if (Math.floor(amt/s) < 100) {
				v.vidPos[1] = v.sh - v.designFit[1] - Math.ceil(50*s/v.getScale());
			}
		} else { // it's not enough space, so overlay and decide what looks best
			v.overlaymode = true;
			if (view_aspect > 1) { // landscape, overlay the buttons within video frame
				decidedlayout = 'sidebar';
				sidemax = v.designFit[1];
			} else { // overlay, but also shift the video fully under, not to cross the edge
				decidedlayout = 'bottombar';
				v.vidPos[1] = v.sh - v.designFit[1];
			}
		}
	}
	for (const g of v.gadgets) if (g.refw && g.refh) {
		g.w = g.refw / v.getScale() * s;
		g.h = g.refh / v.getScale() * s;
	}
	const bw = 50 / v.getScale() * s;
	switch (decidedlayout) {
	case 'sidebar':
		var gadtotal = 0; for (const g of v.gadgets) if (g.refw && g.refh) gadtotal += g.h;
		var space = (sidemax - gadtotal) / (v.gadgets.length * 2);
		var y = (v.sh - sidemax)/2;
		for (const g of v.gadgets) {
			g.x = (bw - g.w)/2;
			g.y = y + space;
			y += space + g.h + space;
		}
		break;
	case 'bottombar':
		var gadtotal = 0; for (const g of v.gadgets) if (g.refw && g.refh) gadtotal += g.w;
		var space = (bottommax - gadtotal) / (v.gadgets.length * 2);
		var x = (v.sw - bottommax)/2;
		for (const g of v.gadgets) {
			g.y = v.sh - bw + (bw - g.h)/2;
			g.x = x + space;
			x += space + g.w + space;
		}
		break;
	}
	for (const g of v.gadgets) if (g.refw && g.refh) {
		g.autoHull();
	}
}
v.renderFunc = function() {

function adj(m) { // Compute the adjugate of m
  return [
    m[4]*m[8]-m[5]*m[7], m[2]*m[7]-m[1]*m[8], m[1]*m[5]-m[2]*m[4],
    m[5]*m[6]-m[3]*m[8], m[0]*m[8]-m[2]*m[6], m[2]*m[3]-m[0]*m[5],
    m[3]*m[7]-m[4]*m[6], m[1]*m[6]-m[0]*m[7], m[0]*m[4]-m[1]*m[3]
  ];
}
function multmm(a, b) { // multiply two matrices
  var c = Array(9);
  for (var i = 0; i != 3; ++i) {
    for (var j = 0; j != 3; ++j) {
      var cij = 0;
      for (var k = 0; k != 3; ++k) {
        cij += a[3*i + k]*b[3*k + j];
      }
      c[3*i + j] = cij;
    }
  }
  return c;
}
function multmv(m, v) { // multiply matrix and vector
  return [
    m[0]*v[0] + m[1]*v[1] + m[2]*v[2],
    m[3]*v[0] + m[4]*v[1] + m[5]*v[2],
    m[6]*v[0] + m[7]*v[1] + m[8]*v[2]
  ];
}
function pdbg(m, v) {
  var r = multmv(m, v);
  return r + " (" + r[0]/r[2] + ", " + r[1]/r[2] + ")";
}
function basisToPoints(x1, y1, x2, y2, x3, y3, x4, y4) {
  var m = [
    x1, x2, x3,
    y1, y2, y3,
     1,  1,  1
  ];
  var v = multmv(adj(m), [x4, y4, 1]);
  return multmm(m, [
    v[0], 0, 0,
    0, v[1], 0,
    0, 0, v[2]
  ]);
}
function general2DProjection(
  x1s, y1s, x1d, y1d,
  x2s, y2s, x2d, y2d,
  x3s, y3s, x3d, y3d,
  x4s, y4s, x4d, y4d
) {
  var s = basisToPoints(x1s, y1s, x2s, y2s, x3s, y3s, x4s, y4s);
  var d = basisToPoints(x1d, y1d, x2d, y2d, x3d, y3d, x4d, y4d);
  return multmm(d, adj(s));
}
function project(m, x, y) {
  var v = multmv(m, [x, y, 1]);
  return [v[0]/v[2], v[1]/v[2]];
}
function transform2d(elt, x1, y1, x2, y2, x3, y3, x4, y4) {
  //var w = elt.offsetWidth, h = elt.offsetHeight;
  var w = 1, h = 1;
  var t = general2DProjection
    (0, 0, x1, y1, w, 0, x2, y2, 0, h, x3, y3, w, h, x4, y4);
  for(i = 0; i != 9; ++i) t[i] = t[i]/t[8];
  t = [t[0], t[3], 0, t[6],
       t[1], t[4], 0, t[7],
       0   , 0   , 1, 0   ,
       t[2], t[5], 0, t[8]];
	return t;
/*
  t = "matrix3d(" + t.join(", ") + ")";
  elt.style["-webkit-transform"] = t;
  elt.style["-moz-transform"] = t;
  elt.style["-o-transform"] = t;
  elt.style.transform = t;
*/
}

	const th = config.themeColors, v = this;
	gl.clearColor(...th.uiBackground);
	gl.clear(gl.COLOR_BUFFER_BIT);
	this.setRenderFlag(true);
	if (!v.designFit || !v.vidPos) return;
	if (!paymentpane.updateFlag) return;
//	paymentpane.updateFlag = false;
//	console.log('renderFunc');
	if (!this.texture) this.texture = initTexture(gl);
  updateTexture(gl, this.texture, this.videoEl);
	const mat = mat4.create();
	var w = v.designFit[0], h = v.designFit[1];
	var x = v.vidPos[0], y = v.vidPos[1];
	mat4.identity(mat);
	mat4.translate(mat, mat, [x, y, 0]);
	mat4.scale(mat, mat, [w, h, 1]);
	mainShapes.useProg4();
	gl.uniformMatrix4fv(gl.getUniformLocation(prog4, 'uProjectionMatrix'), false, this.mat);
	gl.uniformMatrix4fv(gl.getUniformLocation(prog4, 'uModelViewMatrix'), false, mat);
	gl.uniform4fv(gl.getUniformLocation(prog4, 'overallColor'), new Float32Array([1,1,1,1]));
	mainShapes.drawArrays4('rect');

	if (paymentpane.scanner
	&& paymentpane.scanner.lastresult.data != ''
	&& paymentpane.scanner.results.length > 1) {
	  mainShapes.useProg2();
		var p = paymentpane.scanner.lastresult.cornerPoints;
		var t = transform2d(undefined,
			p[0].x+x, p[0].y+y, p[1].x+x, p[1].y+y, p[3].x+x, p[3].y+y, p[2].x+x, p[2].y+y);
		var m = mat4.fromValues(
			t[ 0],t[ 1],t[ 2],t[ 3],
			t[ 4],t[ 5],t[ 6],t[ 7],
			t[ 8],t[ 9],t[10],t[11],
			t[12],t[13],t[14],t[15],
		);
		gl.disable(gl.DEPTH_TEST);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, this.mat);
		gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
			new Float32Array([0,1,0,paymentpane.scanner.intensity]));
		mat4.translate(m, m, [0.43, 0.43 + 0.14, 0]);
		mat4.scale(m, m, [0.14, -0.14, 1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
		var tris = len2.pies/3;
		var parts = paymentpane.scanner.results.length;
		for (var i=0; i<parts; i++) if (paymentpane.scanner.results[i] != '') {
			var beg = Math.round(tris * i / parts);
			var end = Math.round(tris * (i + 1) / parts);
			gl.drawArrays(mainShapes.typ2.pies,
				mainShapes.beg2.pies + beg * 3,
				(end - beg) * 3);
		}
		paymentpane.scanner.intensity *= 0.95;
	}

  mainShapes.useProg2();
	var s = v.designFit[0] < v.designFit[1]? v.designFit[0]: v.designFit[1];
	w = s * 0.9; h = s * 0.9;
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, this.mat);
/*
	gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
		new Float32Array([0,0,0,0.5]));
	for (var i=0; i<4; i++) {
		mat4.identity(mat);
		switch(i) {
		case 0:	mat4.translate(mat, mat, [0, 0, 0]);
						mat4.scale(mat, mat, [v.sw, (v.sh-h)/2, 1]); break;
		case 1:	mat4.translate(mat, mat, [0, (v.sh-h)/2, 0]);
						mat4.scale(mat, mat, [(v.sw-w)/2, h, 1]); break;
		case 2:	mat4.translate(mat, mat, [v.sw - (v.sw-w)/2, (v.sh-h)/2, 0]);
						mat4.scale(mat, mat, [(v.sw-w)/2, h, 1]); break;
		case 3:	mat4.translate(mat, mat, [0, v.sh - (v.sh-h)/2, 0]);
						mat4.scale(mat, mat, [v.sw, (v.sh-h)/2, 1]); break;
		}
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, mat);
		mainShapes.drawArrays2('rect');
	}
*/
	gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'), new Float32Array([1,1,1,1]));
	mat4.identity(mat);
	mat4.translate(mat, mat, [x + (v.designFit[0] - w)/2, y + (v.designFit[1] - h)/2, 0]);
	mat4.scale(mat, mat, [w, h, 1]);
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, mat);
	mainShapes.drawArrays2('scanbox');

	for (const g of this.gadgets) {
		if (g.renderFunc) g.renderFunc.call(g);
	}
}

var paymentpane = v = new vp.SliceView(null, 'b', 0);
v.name = Object.keys({paymentpane}).pop();
v.prop = true;
//v.a = pmtbuttonbar; pmtbuttonbar.parent = v;
v.b = paymentmain; paymentmain.parent = v;
v.updateFlag = false;
v.checkReady = function() {
	if (this.playing && this.timeupdate) {
		this.setRenderFlag(true);
		this.updateFlag = true;
	}
}
v.switchedToFunc = function() {
	if (!this.videoEl) {
		this.videoEl = document.getElementById('scan1');
		this.videoEl.addEventListener("loadedmetadata", function (e) {
			paymentmain.designFit = [this.videoWidth, this.videoHeight];
			paymentmain.queueLayout();
		}, false);
		this.videoEl.addEventListener("playing", () => {
			paymentpane.playing = true;
			paymentpane.checkReady();
		}, true);
		this.videoEl.addEventListener("timeupdate", () => {
			paymentpane.timeupdate = true;
			paymentpane.checkReady();
		}, true);
	}
	var s = this.videoEl.videoWidth; if (s>this.videoEl.videoHeight) s = this.videoEl.videoHeight;
	var vidEl = this.videoEl;
	var cam;
	if (camerasettings.cameralist.index >= 0)
		cam = cameras[camerasettings.cameralist.index].deviceId;
	if (!cam) cam = 'environment';
	this.scanner = new QrScanner(
		this.videoEl,
		function(result) {
			this.intensity = 0.5;
			var repeat = (result.data == this.lastresult.data);
			this.lastresult = result;
			if (repeat) return;

			var beeptype = 'click', ob = false;
			if (result.data.toLowerCase().startsWith('lnbc')
			||  result.data.toLowerCase().startsWith('lnurl')) {
				this.results = [];
				vp.beep('qr-scan');
				paymentpane.scanner.stop();
				paymentpane.scanner.destroy();
				paymentpane.scanner = undefined;
				paymentpane.playing = false;
				paymentpane.timeupdate = false;
				paymentpane.updateFlag = false;
				delete paymentmain.designFit;
				payinvconf.data = result.data.toLowerCase();
				var root = menudiv, v = payinvconf;
				root.b = v; v.parent = root;
				root.relayout();
			} else if ((ob = tryParseJSONObject(result.data)) !== false
			&& typeof(ob) == 'object'
			&& typeof(ob[0]) == 'number' && ob[0] > 0
			&& typeof(ob[1]) == 'number' && ob[0] <= ob[1]) {
				if (this.results.length == 0) {
					this.results = Array(ob[1]).join(".").split(".");
				}
				if (this.results[ob[0]-1] != result.data) {
					this.results[ob[0]-1] = result.data;
					beeptype = 'qr-scan';
					for (var i=0; i<ob[1]; i++) if (this.results[i] == '') {
						beeptype = 'qr-part';
						break;
					}
					if (beeptype == 'qr-scan' && ob[1] == this.results.length) {
						var receipt = new Receipt();
						var data = receipt.fromParts(this.results);
						if (data) {
							paymentpane.scanner.stop();
							paymentpane.scanner.destroy();
							paymentpane.scanner = undefined;
							paymentpane.playing = false;
							paymentpane.timeupdate = false;
							paymentpane.updateFlag = false;
							delete paymentmain.designFit;
							displayreceipt.setData(data);
							pmtrcptmain.userY = 0;
							var root = menudiv, v = displayreceipt;
							root.b = v; v.parent = root;
							root.relayout();
						} else {
							beeptype = 'error';
						}
					}
				}
				vp.beep(beeptype);
			} else {
				console.log('Unrecognized QR code:', result);
			}
		},
		{
			preferredCamera: cam,
			calculateScanRegion: function(video) {
        const smallestDimension = Math.min(video.videoWidth, video.videoHeight);
        const scanRegionSize = smallestDimension;
        return {
            x: Math.round((video.videoWidth - scanRegionSize) / 2),
            y: Math.round((video.videoHeight - scanRegionSize) / 2),
            width: scanRegionSize,
            height: scanRegionSize,
        };
    	}, returnDetailedScanResult: true
		},
//calculateScanRegion: {x:0, y:0, width:100, height:100, downScaledWidth:400, downScaledHeight:400}, 
	);
	this.scanner.results = [];
	this.scanner.lastresult = {data: ''};
	this.scanner.start();
}

var payinvconfbuttonbar = v = new vp.View(null);
v.name = Object.keys({payinvconfbuttonbar}).pop();
v.designFit = [400,50];
v.gadgets.push(v.homeGad = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x00";
	g.renderFunc = function() {
		var g = this;
		var sel = clickTapActive.includes(g.gestureState);
		const mat = mat4.create();
		mat4.identity(mat);
		mat4.translate(mat, mat, [g.x, g.y, 0]);
		mat4.scale(mat, mat, [g.w/18, g.h/18, 0]);
		mat4.translate(mat, mat, [-1, 16, 0]);
		iconFont.draw(0,0, g.icon,
			g.enabled?(sel?config.themeColors.uiButtonSel:config.themeColors.uiButton):config.themeColors.uiButtonGhost,
			g.viewport.mat, mat);
	}
	g.clickFunc = function() {
		transitionTo(home, 'min');
	}
v.gadgets.push(v.pushGad = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = 50 + (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x01";
	g.enabled = false;
	g.renderFunc = v.homeGad.renderFunc;
	g.clickFunc = function() {
		console.log('pushGad');
	}
v.gadgets.push(v.popGad = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = 100 + (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x02";
	g.enabled = false;
	g.renderFunc = v.homeGad.renderFunc;
	g.clickFunc = function() {
		console.log('popGad');
	}
v.gadgets.push(v.trashGad = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = 150 + (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x03";
	g.enabled = false;
	g.renderFunc = v.homeGad.renderFunc;
	g.clickFunc = function() {
		if (window.confirm(tr("Discard this invoice?"))) {
			dataentry.clearDataEntry();
			invoicepane.invoiceitems = [];
			invoicepane.setRenderFlag(true);
			checkoutpages.toPage(0);
		}
	}
v.layoutFunc = function() {
	var totalW = 0; for (const g of this.gadgets) totalW += g.w;
	var space = (this.w / this.getScale() - totalW) / (this.gadgets.length * 2);
	var x = 0;
	for (const g of this.gadgets) {
		g.x = x + space;
		x += space + g.w + space;
	}
}
v.renderFunc = function() {
	const th = config.themeColors;
	gl.clearColor(...th.uiBackground);
	gl.clear(gl.COLOR_BUFFER_BIT);
	for (const g of this.gadgets) {
		if (g.renderFunc) g.renderFunc.call(g);
	}
}

var payinvconfmain = v = new vp.View(null);
v.name = Object.keys({payinvconfmain}).pop();
v.designFit = [400, 300];
v.gadgets.push(v.pay = g = new vp.Gadget(v));
	g.w = 250; g.h = 50; g.actionFlags = vp.GAF_CLICKABLE;
	g.text = tr('confirm');
	g.layoutFunc = function() {
		var g = this, v = g.viewport, s = v.getScale();
		g.W = v.w/s; g.x = (g.W - g.w) / 2;
		g.H = v.h/s; g.y = (g.H - g.h) / 2 + 50;
		g.autoHull();
	}
	g.renderFunc = function() {
		var g = this;
		var sel = clickTapActive.includes(g.gestureState);
		const th = config.themeColors;
		const mat = mat4.create();
		mat4.identity(mat);
		mat4.translate(mat, mat, [g.x, g.y, 0]);
		mat4.scale(mat, mat, [g.w, g.h, 1]);
		mainShapes.useProg5();
		gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uModelViewMatrix'), false, mat);
		gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
			new Float32Array(sel?th.uiForeground:th.uiPillOrange));
		mainShapes.drawArrays5('rect');
		mat4.identity(mat);
		mat4.translate(mat, mat, [g.x, g.y, 0]);
		mat4.scale(mat, mat, [50/32, 50/32, 1]);
		centerText(8,7, 5*32-16,32-14, g.text, th.uiBackground, g.viewport.mat, mat);
	}
	g.clickFunc = function() {
		//transitionTo(paymentpane, 'max');
		var root = menudiv, v = paymentpane;
		root.b = v; v.parent = root;
		root.relayout();
		paymentpane.switchedToFunc();
	}
v.layoutFunc = function() {
	for (const g of this.gadgets) {
		if (g.layoutFunc) g.layoutFunc.call(g);
	}
};
v.renderFunc = function() {
	const th = config.themeColors, th2 = customerColors, v = this;
	gl.clearColor(...th.uiBackground);
	gl.clear(gl.COLOR_BUFFER_BIT);
	mainShapes.useProg5();
	gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uProjectionMatrix'), false, this.mat);
	for (const g of this.gadgets) {
		if (g.renderFunc) g.renderFunc.call(g);
	}

	var inv = payinvconf.data;

	const re = /^lnbc([0-9]+[munp]).*$/;
	var temp = re.exec(inv);
	if (temp) {
		var amt = temp[1].slice(0, -1);
		switch (temp[1].slice(-1)) {
		case 'm': amt *= 100000; break;
		case 'u': amt *= 100; break;
		case 'n': amt *= 0.1; break;
		case 'p': amt *= 0.0001; break;
		}

    const m = mat4.create();

		var bal = amt; //Math.round(Math.random() * (10 ** (Math.random() * 10)));
		var balstr = lcode != 'en-US' || bal > 9999? bal.toLocaleString(lcode) : bal.toString();
		var balw = defaultFont.calcWidth(balstr) + defaultFont.calcWidth(' sats')/2;
		var tmpw = Math.max(128, balw + 10);

		mat4.identity(m);
		mat4.scale(m, m, [400/tmpw, 400/tmpw, 1]);
		mat4.translate(m, m, [(tmpw/400*this.sw-balw)*0.51, (tmpw/400*this.sh-20)*0.49, 0]);
		defaultFont.draw(0,0, balstr, config.themeColors.uiPillOrange, this.mat, m);
		mat4.scale(m, m, [0.5, 0.5, 1]);
		defaultFont.draw(0,0, ' sats', config.themeColors.uiPillOrange, this.mat, m);

		bal = toFiat(bal);
		if (style == PARAGUAY) {
			balstr = bal.toLocaleString(lcode);
			balstr = tr('about @').replace('@', 'Gs ' + balstr);
		} else {
			if (bal > 9999)
				balstr = bal.toLocaleString(lcode, {
					minimumFractionDigits: 2,
					maximumFractionDigits: 2,
				});
			else
				balstr = bal.toFixed(2);
			balstr = tr('about @').replace('@', '$' + balstr);
		}
		balw = defaultFont.calcWidth(balstr)/2;
		tmpw = Math.max(128, balw + 10);

		mat4.identity(m);
		mat4.scale(m, m, [400/tmpw, 400/tmpw, 1]);
		mat4.translate(m, m, [(tmpw/400*this.sw-balw)*0.51, (tmpw/400*this.sh-20)*0.49+10, 0]);
		mat4.scale(m, m, [0.5, 0.5, 1]);
		defaultFont.draw(0,0, balstr, config.themeColors.uiFiatGreen, this.mat, m);
	}
}

var payinvconf = v = new vp.SliceView(null, 'b', 0.125);
v.name = Object.keys({payinvconf}).pop();
v.prop = true;
v.a = payinvconfbuttonbar; payinvconfbuttonbar.parent = v;
v.b = payinvconfmain; payinvconfmain.parent = v;
v.switchedToFunc = function() {
}

var pmtrcptbuttonbar = v = new vp.View(null);
v.name = Object.keys({pmtrcptbuttonbar}).pop();
v.designFit = [400,50];
v.gadgets.push(v.homeGad = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x00";
	g.renderFunc = function() {
		var g = this;
		var sel = clickTapActive.includes(g.gestureState);
		const mat = mat4.create();
		mat4.identity(mat);
		mat4.translate(mat, mat, [g.x, g.y, 0]);
		mat4.scale(mat, mat, [g.w/18, g.h/18, 0]);
		mat4.translate(mat, mat, [-1, 16, 0]);
		iconFont.draw(0,0, g.icon,
			g.enabled?(sel?config.themeColors.uiButtonSel:config.themeColors.uiButton):config.themeColors.uiButtonGhost,
			g.viewport.mat, mat);
	}
	g.clickFunc = function() {
console.log('home');
		transitionTo(home, 'min');
	}
v.gadgets.push(v.pushGad = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = 50 + (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x01";
	g.enabled = false;
	g.renderFunc = v.homeGad.renderFunc;
	g.clickFunc = function() {
		console.log('pushGad');
	}
v.gadgets.push(v.popGad = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = 100 + (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x02";
	g.enabled = false;
	g.renderFunc = v.homeGad.renderFunc;
	g.clickFunc = function() {
		console.log('popGad');
	}
v.gadgets.push(v.trashGad = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = 150 + (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.icon = "\x03";
	g.enabled = false;
	g.renderFunc = v.homeGad.renderFunc;
	g.clickFunc = function() {
		if (window.confirm(tr("Discard this invoice?"))) {
			dataentry.clearDataEntry();
			invoicepane.invoiceitems = [];
			invoicepane.setRenderFlag(true);
			checkoutpages.toPage(0);
		}
	}
v.layoutFunc = function() {
	var totalW = 0; for (const g of this.gadgets) totalW += g.w;
	var space = (this.w / this.getScale() - totalW) / (this.gadgets.length * 2);
	var x = 0;
	for (const g of this.gadgets) {
		g.x = x + space;
		x += space + g.w + space;
	}
}
v.renderFunc = function() {
	const th = config.themeColors;
	gl.clearColor(...th.uiBackground);
	gl.clear(gl.COLOR_BUFFER_BIT);
	for (const g of this.gadgets) {
		if (g.renderFunc) g.renderFunc.call(g);
	}
}

var pmtrcptmain = v = new vp.View(null);
v.name = Object.keys({pmtrcptmain}).pop();
v.designWidth = 460;
v.backgroundDisabled = false;
v.lastH = 0;
v.minX = 0; v.maxX = v.designWidth;
v.minY = 0; v.maxY = 1000;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.layoutFunc = function() {
	this.swipeGad.layout.call(this.swipeGad);
	if (this.sh != this.lastH) {
		this.lastH = this.sh;
		this.backgroundDisabled = false;
	}
};
v.renderFunc = function() {
	const th = config.themeColors, th2 = customerColors, v = this;
	if (this.backgroundDisabled) {
		gl.clearColor(...th.uiBackground);
		gl.clear(gl.COLOR_BUFFER_BIT);
	} else {
		drawThemeBackdrop(this, th);
	}

	const linespacing = 23;
	const charspacing = 10;
	const margintop = 4*linespacing;
	const marginbottom = 4*linespacing;
	const marginleft = 3*charspacing;
	const marginright = 3*charspacing;

	var widths = [];
	var nums = [];
	var sep = ' ';
	function isNumeric(s) {
		for (var c of s) if (!"0123456789.,%".includes(s[0])) return false;
		return true;
	}
	function getColumnAttribs(start) {
		widths = [];
		nums = [];
		for (var i=start; i<displayreceipt.data.length; i++) {
			var o = displayreceipt.data[i];
			var key = Object.keys(o)[0];
			var fieldcode = Math.floor(+key);
			if (i != start && fieldcode == Receipt.LIST_HEAD) break;
			var so = Object.values(o)[0];
			if (fieldcode == Receipt.LIST_HEAD) {
				for (var f=0; f<so.length; f++) {
					if (widths.length <= f) widths.push(0);
					widths[f] = Math.max(widths[f],
						dotMatrixFont.calcWidth(Object.values(so[f])[0][0]));
					widths[f] = Math.max(widths[f],
						charspacing * Object.values(so[f])[0][1]);
					if (nums.length <= f) nums.push(true);
				}
			} else if (fieldcode == Receipt.LIST_ITEM) {
				for (var f=0; f<so.length; f++) {
					widths[f] = Math.max(widths[f],
						dotMatrixFont.calcWidth(so[f]));
					nums[f] = !!(nums[f] &&
						isNumeric(so[f]));
				}
			}
		}
	}
	function getTabAttribs(start) {
		widths = [];
		nums = [];
		for (var i=start; i<displayreceipt.data.length; i++) {
			var o = displayreceipt.data[i];
			var key = Object.keys(o)[0];
			var fieldcode = Math.floor(+key);
			if (i != start && (
				fieldcode == Receipt.LIST_HEAD ||
				fieldcode == Receipt.TAB)) break;
			var so = Object.values(o)[0];
			if (fieldcode == Receipt.TAB) {
				for (var f=0; f<2; f++) {
					if (widths.length <= f) widths.push(0);
					if (nums.length <= f) nums.push(true);
				}
				if (so.length >= 3) {
					widths[0] = Math.max(widths[0],
						charspacing * so[0]);
					widths[1] = Math.max(widths[1],
						charspacing * so[2]);
					sep = so[1];
				} else {
					sep = ' ';
				}
			} else {
				widths[0] = Math.max(widths[0],
					dotMatrixFont.calcWidth(so[0]));
				widths[1] = Math.max(widths[1],
					dotMatrixFont.calcWidth(so[1]));
				nums[1] = !!(nums[1] &&
					isNumeric(so[1]));
			}
		}
	}

	var y = 0;

	// Start the receipt "paper" with the top and bottom margin sizes.
	mainShapes.useProg2();
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, this.mat);
	gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
		new Float32Array(th2.uiReceiptBg));
	const m = mat4.create();
	mat4.identity(m);
	mat4.translate(m,m,[0,y,0]);
	mat4.scale(m,m,[v.sw,margintop+marginbottom,1]);
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
	mainShapes.drawArrays2('rect');

	// Draw the serrated leading edge of the receipt.
	mainShapes.useProg2();
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, this.mat);
	gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
		new Float32Array([0,0,0,1]));
	mat4.identity(m);
	mat4.scale(m,m,[v.sw,v.sw,1]);
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
	mainShapes.drawArrays2('tear');

	y += margintop;
	var inlist = false;
	for (var i=0; i<displayreceipt.data.length; i++) {
		var o = displayreceipt.data[i];
		var key = Object.keys(o)[0];
		var so = Object.values(o)[0];
		var name = '', value = '';
		var fieldcode = Math.floor(+key);
		if (y - this.userY < -3 * linespacing) {
			if (fieldcode == Receipt.TAB) {
			} else if (fieldcode == Receipt.LIST_HEAD) {
				getColumnAttribs(i);
				var x = marginleft;
				for (var f=0; f<so.length; f++) {
					x += widths[f] + charspacing;
					if (x > this.designWidth
					|| (f+1 < widths.length && x + widths[f+1] > this.designWidth)) {
						x = marginleft;
						y += linespacing;
					}
				}
				y += linespacing;
			} else if (fieldcode == Receipt.LIST_ITEM) {
				var x = marginleft;
				for (var f=0; f<so.length; f++) {
					x += widths[f] + charspacing;
					if (x > this.designWidth
					|| (f+1 < widths.length && x + widths[f+1] > this.designWidth)) {
						x = marginleft;
						y += linespacing;
					}
				}
				y += linespacing;
			} else {
				y += linespacing;
			}
			continue;
		} else if (y - this.userY > this.sh) {
			break;
		}
		if (fieldcode == Receipt.TAB) {
			inlist = false;
			getTabAttribs(i);
		} else if (fieldcode == Receipt.LIST_HEAD) {
			inlist = true;
			getColumnAttribs(i);
			var x = marginleft;
			for (var f=0; f<so.length; f++) {
				value = Object.values(so[f])[0][0];
				mat4.identity(m);
				mat4.translate(m,m,[0,y,0]);
				var o = nums[f]?widths[f]-dotMatrixFont.calcWidth(value):0;
				dotMatrixFont.draw(o+x,14, value, th2.uiReceiptText, this.mat, m);
				x += widths[f] + charspacing;
				if (x > this.designWidth
				|| (f+1 < widths.length && x + widths[f+1] > this.designWidth)) {
					x = marginleft;
					y += linespacing;
				}
			}
			y += linespacing;
		} else if (fieldcode == Receipt.LIST_ITEM) {
			inlist = true;
			var x = marginleft;
			for (var f=0; f<so.length; f++) {
				value = so[f];
				mat4.identity(m);
				mat4.translate(m,m,[0,y,0]);
				var o = nums[f]?widths[f]-(value?dotMatrixFont.calcWidth(value):0):0;
				dotMatrixFont.draw(o+x,14,
					value, th2.uiReceiptText, this.mat, m);
				x += widths[f] + charspacing;
				if (x > this.designWidth
				|| (f+1 < widths.length && x + widths[f+1] > this.designWidth)) {
					x = marginleft;
					y += linespacing;
				}
			}
			y += linespacing;
		} else if (fieldcode == Receipt.SEP) {
			name = so[0];
			value = so[1];
			if ((name+value).length == 1) {
				value = (name+value).repeat(40);
				name = '';
			} else if (name != '') {
				value = name + sep + value;
				name = '';
			}
			mat4.identity(m);
			mat4.translate(m,m,[marginleft,y+14,0]);
			dotMatrixFont.draw(0,0, value, th2.uiReceiptText, this.mat, m);
			y += linespacing;
		} else if (fieldcode <= 42) {
			if (inlist) {
				inlist = false;
				widths = [];
				nums = [];
			}
			name = so[0];
			value = so[1];
			//var s = (name!=''?name+sep:'')+value;
			if (name != '') {
				mat4.identity(m);
				mat4.translate(m,m,[marginleft,y+14,0]);
				dotMatrixFont.draw(0,0, name, th2.uiReceiptText, this.mat, m);
				mat4.identity(m);
				mat4.translate(m,m,[marginleft,y+14,0]);
				var w = Math.max(dotMatrixFont.calcWidth(name), widths.length>0?widths[0]:0);
				dotMatrixFont.draw(w,0, sep, th2.uiReceiptText, this.mat, m);
			} else {
				mat4.identity(m);
				mat4.translate(m,m,[marginleft,y+14,0]);
			}
			var w = dotMatrixFont.calcWidth(value);
			var p = 0;
			if (nums[1]) p = Math.max(w, widths.length>1?widths[1]:0) - w;
			dotMatrixFont.draw(p,0, value, th2.uiReceiptText, this.mat, m);
			y += linespacing;
		} else {
			name = '';
			value = JSON.stringify(so);
			mat4.identity(m);
			mat4.translate(m,m,[marginleft,y,0]);
			var s = (name!=''?name+': ':'')+value;
			dotMatrixFont.draw(0,14, s, th2.uiReceiptText, this.mat, m);
			y += linespacing;
		}

		// Extend the receipt "paper" by the bottom margin size.
		mainShapes.useProg2();
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, this.mat);
		gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
			new Float32Array(th2.uiReceiptBg));
		mat4.identity(m);
		mat4.translate(m,m,[0,y,0]);
		mat4.scale(m,m,[v.sw,marginbottom,1]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
		mainShapes.drawArrays2('rect');
	}
	y += marginbottom;

	// Draw the serrated trailing edge of the receipt.
	mainShapes.useProg2();
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, this.mat);
	gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
		new Float32Array(th2.uiReceiptBg));
	mat4.identity(m);
	mat4.translate(m,m,[0,y,0]);
	mat4.scale(m,m,[v.sw,v.sw,1]);
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
	mainShapes.drawArrays2('tear');
	y += (v.sw/49)*Math.sqrt(3)/2;

/*
	mat4.identity(m);
	mat4.translate(m,m,[0,y,0]);
	mat4.scale(m,m,[v.sw,v.sh,1]);
	gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, m);
	mainShapes.drawArrays2('rect');
*/
	if (y > v.sh) {
		this.backgroundDisabled = true;
	}

	this.maxY = y;
	this.swipeGad.layout.call(this.swipeGad);
}

var displayreceipt = v = new vp.SliceView(null, 'b', 0.125);
v.name = Object.keys({displayreceipt}).pop();
v.prop = true;
v.a = pmtrcptbuttonbar; pmtrcptbuttonbar.parent = v;
v.b = pmtrcptmain; pmtrcptmain.parent = v;
v.setData = function(data) {
	this.data = data;
	pmtrcptmain.backgroundDisabled = false;
}
v.switchedToFunc = function() {
}

var accounts = [];
function getCurrentAccount() { return accounts[accountsettings.accountlist.index]; }

//var curAcct = {};
accounts.current = getCurrentAccount;

function dateToID(d) {
	return 'A'
		+ d.getFullYear().toString().padStart(4,'0')
		+ (d.getMonth()+1).toString().padStart(2,'0')
		+ d.getDate().toString().padStart(2,'0')
		+ d.getHours().toString().padStart(2,'0')
		+ d.getMinutes().toString().padStart(2,'0')
		+ d.getSeconds().toString().padStart(2,'0')
		+ d.getMilliseconds().toString().padStart(3,'0')
		;
}

{
	const debuglog = false;
	dbNotifier = (event) => {
		if (debuglog) console.log("Database opened for account settings");
		var selectedAccount = '';
		function finishAccountInit() {
			var index = -1;
			for (var i=0; i<accounts.length; i++) {
				if (accounts[i].id == selectedAccount) {
					index = i;
					break;
				}
			}
			if (index < 0) index = 0;
			{ // For the GUI.
				accountsettings.accountlist.index = index;
				accountsettings.queueLayout();
			} { // For the app function.
				loadAccount();
			} { // For persistence.
			}
			if (debuglog) console.log("account ready", accountsettings.accountlist.index);
		}
		function accountInit2() {
			if (debuglog) console.log("requesting selectedAccount");
			var req = db.transaction(["settings"], "readonly")
				.objectStore("settings")
				.get("selectedAccount");
			req.onsuccess = (event) => {
				selectedAccount = event.target.result;
				if (debuglog) console.log("selectedAccount restored", selectedAccount);
				finishAccountInit();
			};
			req.onerror = (event) => {
				console.log("error getting selectedAccount", event);
				finishAccountInit();
			};
		}
		accounts.splice(0, accounts.length);
		const transaction = db.transaction(["accounts"], "readonly");
		const objectStore = transaction.objectStore("accounts");
		objectStore.openCursor().onsuccess = (event) => {
			const cursor = event.target.result;
			if (cursor) {
				accounts.push({
					id:			cursor.value.id,
					title:	cursor.value.title,
				});
				if (debuglog) console.log("restored account", cursor.value.id, cursor.value.title);
				cursor.continue();
			} else {
				if (accounts.length == 0) {
					if (debuglog) console.log("creating default account");
					accounts.push({
						id:			dateToID(new Date()),
						title:	'my business',
					});
					if (debuglog) console.log("saving default account");
					var tx = db.transaction(["accounts", "settings"], "readwrite");
					tx.objectStore("accounts").put(accounts[0], accounts[0].id);
					tx.objectStore("settings").put(accounts[0].id, 'selectedAccount');
					tx.oncomplete = (event) => {
						if (debuglog) console.log("default account saved");
						accountInit2();
					};
					tx.onerror = (event) => {
						console.log("error saving default account", event);
					};
				} else {
					if (debuglog) console.log("no more accounts");
					accountInit2();
				}
			}
		};
	};
}

let showConfigOnlyOnce = true;
function loadAccount() {
	const panes = [
		accountsettings,
		languagesettings,
		maincurrency,
		cashcurrency,
		currencysettings,
		walletsettings,
		nostrmarketstall,
		pricelistsettings,
		camerasettings,
		layoutsettings,
		colorsettings,
	];

	function cb() {
		let allComplete = true;
		let n = 0;
		for (const pane of panes) {
			if (pane.loadComplete) {
				n++;
			} else {
				allComplete = false;
				break;
			}
		}
		if (allComplete && showConfigOnlyOnce) {
			showConfigOnlyOnce = false;
			config.log();
			startpane2.invoice.clickFunc();
		} else {
//			console.log(n);
		}
	}

	for (const pane of panes) {
		pane.load(cb);
	//walletsettings.load(); // TODO
	//camerasettings.load(); // TODO
	}
//	buttonbar.popGad.enabled = true;
}

const accountsettings = v = new vp.View(null);
v.name = Object.keys({accountsettings}).pop();
v.title = 'account';
v.minX = 0; v.maxX = 0;
v.minY = 0; v.maxY = 0;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.swipeGad.hide = true;
v.gadgets.push(v.accountlist = g = new vp.Gadget(v));
	g.list = accounts;
	g.canAdd = true;
  g.index = -1;
	g.listAddClick = function() {
		console.log("adding new account");
		var a = {
			id:			dateToID(new Date()),
			title:	'new account',
		};
		accounts.push(a);
		accountsettings.queueLayout();
		console.log("saving new account");
		var tx = db.transaction(["accounts", "settings"], "readwrite");
		tx.objectStore("accounts").put(a, a.id);
		tx.objectStore("settings").put(a.id, 'selectedAccount');
		tx.objectStore("settings").put(
			languages[enabledLangs.indexOf(lcode)].title, a.id+'-mainLanguage');
		tx.objectStore("settings").put(
			themes[colorsettings.themelist.index].title, a.id+'-selectedTheme');
		tx.oncomplete = (event) => {
			console.log("new account saved");
			dbNotifier(event);
		};
		tx.onerror = (event) => {
			console.log("error saving new account", event);
		};
	}
	g.listItemClick = function(index) {
		const g = this;
		{ // For the GUI.
			accountsettings.accountlist.index = index;
			accountsettings.queueLayout();
		} { // For the app function.
			loadAccount();
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(accounts[index].id, 'selectedAccount');
			req.onsuccess = (event) => {
				console.log("successfully selected new account", event);
			};
			req.onerror = (event) => {
				console.log("error selecting new account", event);
			};
		}
	}
v.gadgets.push(v.deleteaccount = g = new vp.Gadget(v));
	g.listToOverlay = v.accountlist;
  g.icon = "\x03";
	g.clickFunc = function() {
		if (confirm(tr(`delete '@'?`).replace('@',tr(getCurrentAccount().title)))) {
			console.log(`delete '${getCurrentAccount().title}'?`);
			var a = getCurrentAccount();
			var tx = db.transaction(["accounts"], "readwrite");
			tx.objectStore("accounts").delete(a.id);
			tx.oncomplete = (event) => {
				console.log("account deleted");
				dbNotifier(event);
			};
			tx.onerror = (event) => {
				console.log("error deleting account", event);
				dbNotifier(event);
			};
		}
	}
v.gadgets.push(v.editaccount = g = new vp.Gadget(v));
	g.listToOverlay = v.accountlist;
  g.icon = "\x0C";
	g.clickFunc = function() {
		var a = accounts.current();
		var str = prompt(tr('Account name:'), tr(a.title));
		if (str && str.trim() != a.title) {
			str = str.trim();
			console.log('edit account', str);
			a.title = str;
			var tx = db.transaction(["accounts"], "readwrite");
			tx.objectStore("accounts").put(a, a.id);
			tx.oncomplete = (event) => {
				console.log("account updated");
			};
			tx.onerror = (event) => {
				console.log("error updating account", event);
			};
			settingsbuttons2.setRenderFlag(true);
		}
	}
v.gadgets.push(v.locaddress = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'locAddress';
	g.title = 'business address';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value != '') {
				if (this.value.length < 50) return this.value;
				else return this.value.substr(0,50)+'...';
			}	else return icap(tr('not set'));
		}
	});
	g.value = '';
	g.defaultValue = '';
	g.daisychain = true;
	g.clickFunc = function() {
		const g = this;
		var val = prompt(icap(tr(g.title))+':');
		if (!val) return;
		{ // For the GUI.
			g.viewport.queueLayout();
		} { // For the app function.
			g.value = val.trim();
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.value,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.gadgets.push(v.loccity = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'locCity';
	g.title = 'city';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value != '') {
				if (this.value.length < 50) return this.value;
				else return this.value.substr(0,50)+'...';
			}	else return icap(tr('not set'));
		}
	});
	g.value = '';
	g.defaultValue = '';
	g.daisychain = true;
	g.clickFunc = v.locaddress.clickFunc;
v.gadgets.push(v.locstate = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'locState';
	g.title = 'state';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value != '') {
				if (this.value.length < 50) return this.value;
				else return this.value.substr(0,50)+'...';
			}	else return icap(tr('not set'));
		}
	});
	g.value = '';
	g.defaultValue = '';
	g.daisychain = true;
	g.clickFunc = v.locaddress.clickFunc;
v.gadgets.push(v.locpostalcode = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'locPostalCode';
	g.title = 'postal code';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value != '') {
				if (this.value.length < 50) return this.value;
				else return this.value.substr(0,50)+'...';
			}	else return icap(tr('not set'));
		}
	});
	g.value = '';
	g.defaultValue = '';
	g.daisychain = true;
	g.clickFunc = v.locaddress.clickFunc;
v.gadgets.push(v.telephone = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'busTel';
	g.title = 'business telephone';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value != '') {
				if (this.value.length < 50) return this.value;
				else return this.value.substr(0,50)+'...';
			}	else return icap(tr('not set'));
		}
	});
	g.value = '';
	g.defaultValue = '';
	g.daisychain = false;
	g.clickFunc = v.locaddress.clickFunc;
v.gadgets.push(v.taxid = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'businessTaxId';
	g.title = 'tax id';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value != '') {
				if (this.value.length < 50) return this.value;
				else return this.value.substr(0,50)+'...';
			}	else return icap(tr('not set'));
		}
	});
	g.value = '';
	g.defaultValue = '';
	g.daisychain = true;
	g.clickFunc = v.locaddress.clickFunc;
v.gadgets.push(v.license = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'businessLicenseNumber';
	g.title = 'license number';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value != '') {
				if (this.value.length < 50) return this.value;
				else return this.value.substr(0,50)+'...';
			}	else return icap(tr('not set'));
		}
	});
	g.value = '';
	g.defaultValue = '';
	g.daisychain = true;
	g.clickFunc = v.locaddress.clickFunc;
v.gadgets.push(v.licensevalidfrom = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'businessLicenseValidFrom';
	g.title = 'valid from';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value != '') {
				if (this.value.length < 50) return this.value;
				else return this.value.substr(0,50)+'...';
			}	else return icap(tr('not set'));
		}
	});
	g.value = '';
	g.defaultValue = '';
	g.daisychain = true;
	g.clickFunc = v.locaddress.clickFunc;
v.gadgets.push(v.licensevalidtill = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'businessLicenseValidTill';
	g.title = 'valid till';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value != '') {
				if (this.value.length < 50) return this.value;
				else return this.value.substr(0,50)+'...';
			}	else return icap(tr('not set'));
		}
	});
	g.value = '';
	g.defaultValue = '';
	g.daisychain = false;
	g.clickFunc = v.locaddress.clickFunc;
v.gadgets.push(v.cashreg = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'cashReg';
	g.title = 'cash register number';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value != '') {
				if (this.value.length < 50) return this.value;
				else return this.value.substr(0,50)+'...';
			}	else return icap(tr('not set'));
		}
	});
	g.value = '';
	g.defaultValue = '';
	g.daisychain = true;
	g.clickFunc = v.locaddress.clickFunc;
v.gadgets.push(v.cashier = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'cashier';
	g.title = 'cashier';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value != '') {
				if (this.value.length < 50) return this.value;
				else return this.value.substr(0,50)+'...';
			}	else return icap(tr('not set'));
		}
	});
	g.value = '';
	g.defaultValue = '';
	g.daisychain = false;
	g.clickFunc = v.locaddress.clickFunc;
v.load = function(cb) {
	const debuglog = false;
	const gads = [
		'locaddress', 'loccity', 'locstate', 'locpostalcode', 'telephone',
		'taxid', 'license', 'licensevalidfrom', 'licensevalidtill',
		'cashreg', 'cashier',
	];
	function icb(cb, v) {
		let allComplete = true;
		for (let gad of gads) {
			if (v[gad].loadComplete) {
			} else {
				allComplete = false;
				break;
			}
			if (allComplete) {
				v.loadComplete = true; cb();
			}
		}
	}
	for (const gad of gads) {
		const g = this[gad];
		g.tempValue = g.defaultValue;
		function finishInit(cb, v, g) {
			{ // For the GUI.
				g.viewport.queueLayout();
			} { // For the app function.
				g.value = g.tempValue;
			} { // For persistence.
			}
			delete g.tempValue;
			if (debuglog) console.log(`${g.key} ready`, g.value);
			g.loadComplete = true; icb(cb, v);
		}
		if (debuglog) console.log("requesting", `${getCurrentAccount().id}-${g.key}`);
		var req = db.transaction(["settings"], "readonly")
			.objectStore("settings")
			.get(`${getCurrentAccount().id}-${g.key}`);
		req.onsuccess = (event) => {
			if (event.target.result !== undefined)
				g.tempValue = event.target.result;
			if (debuglog) console.log(`${g.key} restored`, g.tempValue);
			finishInit(cb, this, g);
		};
		req.onerror = (event) => {
			console.log(`error getting ${g.key}`, event);
			finishInit(cb, this, g);
		};
	}
}

const languages = [];
{
	for (var lang of enabledLangs) {
		languages.push({ title: tr(lang,lang) });
	}
}

const languagesettings = v = new vp.View(null);
v.name = Object.keys({languagesettings}).pop();
v.title = 'language';
v.minX = 0; v.maxX = 0;
v.minY = 0; v.maxY = 0;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.swipeGad.hide = true;
v.gadgets.push(v.langlist = g = new vp.Gadget(v));
	g.list = languages;
  g.index = -1;
	g.listItemClick = function(index) {
		const g = this;
		{ // For the GUI.
			g.index = index; v.setRenderFlag(true);
		} { // For the app function.
			lcode = enabledLangs[index];
			settingspane.setRenderFlag(true);
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(languages[languagesettings.langlist.index].title,
					`${getCurrentAccount().id}-mainLanguage`);
			req.onsuccess = (event) => {
				console.log("successfully selected language", event);
			};
			req.onerror = (event) => {
				console.log("error selecting language", event);
			};
		}
	}
v.load = function(cb) {
	const debuglog = false;
	var selectedValue = '';
	function finishInit(cb, v) {
		let index = -1;
		for (let i=0; i<languages.length; i++) {
			if (languages[i].title == selectedValue) {
				index = i;
				break;
			}
		}
		if (index < 0) {
			let urlParams = new URLSearchParams(window.location.search);
			let lang = urlParams.get('lang');
			if (!lang) lang = 'es-PY';
			for (let i=0; i<languages.length; i++) {
				if (languages[i].title == tr(lang,lang)) {
					index = i;
					break;
				}
				for (let l of enabledLangs) {
					if (l.startsWith(lang) && languages[i].title == tr(l,l)) {
						index = i;
						break;
					}
				}
			}
		}
		if (index < 0) index = 0;
		{ // For the GUI.
			languagesettings.langlist.index = index;
			settingspane.setRenderFlag(true);
		} { // For the app function.
			lcode = enabledLangs[index];
			settingspane.setRenderFlag(true);
		} { // For persistence.
		}
		if (debuglog) console.log("lang ready", languagesettings.langlist.index);
		v.loadComplete = true; cb();
	}
	if (debuglog) console.log("requesting", `${getCurrentAccount().id}-mainLanguage`);
	var req = db.transaction(["settings"], "readonly")
		.objectStore("settings")
		.get(`${getCurrentAccount().id}-mainLanguage`);
	req.onsuccess = (event) => {
		selectedValue = event.target.result
		if (debuglog) console.log("mainLanguage restored", selectedValue);
		finishInit(cb, this);
	};
	req.onerror = (event) => {
		console.log("error getting mainLanguage", event);
		finishInit(cb, this);
	};
}
const maincurrency = v = new vp.View(null);
v.name = Object.keys({maincurrency}).pop();
v.title = 'main currency';
v.minX = 0; v.maxX = 0;
v.minY = 0; v.maxY = 0;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.swipeGad.hide = true;
v.gadgets.push(v.list = g = new vp.Gadget(v));
	g.key = 'mainCurrency';
	Object.defineProperty(g, "list", {
		get : function () {
			return supportedCurrencies;
		}
	});
  g.index = -1;
	Object.defineProperty(g, "value", {
		get : function () {
			if (this.index >= 0 && this.index < this.list.length)
				return this.list[this.index];
			return '';
		}
	});
	g.appFunction = function() {
		currencysettings.enablelightning.hide = (this.value == '₿');
		currencysettings.enablelightning.enabled = !currencysettings.enablelightning.hide;
		currencysettings.enablelightning.appFunction();
		currencysettings.cashcurrency.hide = (this.value != '₿');
		currencysettings.cashcurrency.enabled = !currencysettings.cashcurrency.hide;
		cashcurrency.list.appFunction();
		currencysettings.queueLayout();
	}
	g.listItemClick = function(index) {
		const g = this;
		{ // For the GUI.
			g.index = index; v.setRenderFlag(true);
		} { // For the app function.
			g.appFunction();
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.value,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.load = function(cb) {
	const debuglog = false;
	const g = this.list;
	g.tempValue = g.defaultValue;
	function finishInit(cb, v, g) {
		var index = -1;
		for (var i=0; i<g.list.length; i++) {
			if (g.list[i] == g.tempValue) {
				index = i;
				break;
			}
		}
		if (index < 0) index = 0;
		{ // For the GUI.
			maincurrency.list.index = index;
			maincurrency.setRenderFlag(true);
		} { // For the app function.
			g.appFunction();
		} { // For persistence.
		}
		delete g.tempValue;
		if (debuglog) console.log(`${g.key} ready`, g.value);
		v.loadComplete = true; cb();
	}
	if (debuglog) console.log("requesting", `${getCurrentAccount().id}-${g.key}`);
	var req = db.transaction(["settings"], "readonly")
		.objectStore("settings")
		.get(`${getCurrentAccount().id}-${g.key}`);
	req.onsuccess = (event) => {
		if (event.target.result !== undefined)
			g.tempValue = event.target.result;
		if (debuglog) console.log(`${g.key} restored`, g.tempValue);
		finishInit(cb, this, g);
	};
	req.onerror = (event) => {
		console.log(`error getting ${g.key}`, event);
		finishInit(cb, this, g);
	};
}
const cashcurrency = v = new vp.View(null);
v.name = Object.keys({cashcurrency}).pop();
v.title = 'cash currency';
v.minX = 0; v.maxX = 0;
v.minY = 0; v.maxY = 0;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.swipeGad.hide = true;
v.gadgets.push(v.list = g = new vp.Gadget(v));
	g.key = 'cashCurrency';
	Object.defineProperty(g, "list", {
		get : function () {
			var a = supportedCurrencies.filter(e => e !== '₿');
			a.splice(0,0, 'none');
			return a;
		}
	});
  g.index = -1;
	Object.defineProperty(g, "value", {
		get : function () {
			if (maincurrency.list.value != '₿') {
				if (currencysettings.enablelightning.state && currencysettings.disablecash.state) {
					return 'none';
				} else {
					return maincurrency.list.value;
				}
			}
			if (this.index >= 0 && this.index < this.list.length)
				return this.list[this.index];
			return this.list[0];
		}
	});
	g.appFunction = function() {
		currencysettings.showchange.hide = (this.value == 'none');
		currencysettings.showchange.enabled = !currencysettings.showchange.hide;
		currencysettings.queueLayout();
	}
	g.listItemClick = function(index) {
		const g = this;
		{ // For the GUI.
			g.index = index; v.setRenderFlag(true);
		} { // For the app function.
			g.appFunction();
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.value,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.load = function(cb) {
	const debuglog = false;
	const g = this.list;
	g.tempValue = g.defaultValue;
	function finishInit(cb, v, g) {
		var index = -1;
		for (var i=0; i<g.list.length; i++) {
			if (g.list[i] == g.tempValue) {
				index = i;
				break;
			}
		}
		if (index < 0) index = 0;
		{ // For the GUI.
			cashcurrency.list.index = index;
			cashcurrency.setRenderFlag(true);
		} { // For the app function.
			g.appFunction();
		} { // For persistence.
		}
		delete g.tempValue;
		if (debuglog) console.log(`${g.key} ready`, g.value);
		v.loadComplete = true; cb();
	}
	if (debuglog) console.log("requesting", `${getCurrentAccount().id}-${g.key}`);
	var req = db.transaction(["settings"], "readonly")
		.objectStore("settings")
		.get(`${getCurrentAccount().id}-${g.key}`);
	req.onsuccess = (event) => {
		if (event.target.result !== undefined)
			g.tempValue = event.target.result;
		if (debuglog) console.log(`${g.key} restored`, g.tempValue);
		finishInit(cb, this, g);
	};
	req.onerror = (event) => {
		console.log(`error getting ${g.key}`, event);
		finishInit(cb, this, g);
	};
}
const currencysettings = v = new vp.View(null);
v.name = Object.keys({currencysettings}).pop();
v.title = 'currencies';
v.minX = 0; v.maxX = 0;
v.minY = 0; v.maxY = 0;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.swipeGad.hide = true;
v.gadgets.push(v.maincurrency = g = new vp.Gadget(v));
	g.title = 'main currency';
	Object.defineProperty(g, "subtitle", {
		get : function () { try { return maincurrency.list.value; } catch (e) {} }
	});
	g.pane = maincurrency;
v.gadgets.push(v.cashcurrency = g = new vp.Gadget(v));
	g.title = 'cash currency';
	Object.defineProperty(g, "subtitle", {
		get : function () { try { return cashcurrency.list.value; } catch (e) {} }
	});
	g.pane = cashcurrency;
v.gadgets.push(v.enablelightning = g = new vp.Gadget(v));
	g.key = 'enableLightning';
	g.type = 'enable';
	g.title = 'lightning payments';
	g.subtitle = 'accept lightning as a payment method';
  g.state = false;
	g.defaultValue = false;
	Object.defineProperty(g, "icon", {
		get : function () { return this.state? "\x0E":"\x0D"; }
	});
	g.appFunction = function() {
		currencysettings.disablecash.hide = (maincurrency.list.value == '₿' || !currencysettings.enablelightning.state);
		currencysettings.disablecash.enabled = !currencysettings.disablecash.hide;
		cashcurrency.list.appFunction();
		currencysettings.queueLayout();
	}
	g.clickFunc = function(index) {
		const g = this;
		{ // For the GUI.
			g.state = !g.state; v.setRenderFlag(true);
		} { // For the app function.
			g.appFunction();
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.state,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.gadgets.push(v.disablecash = g = new vp.Gadget(v));
	g.key = 'disableCash';
	g.type = 'enable';
	g.title = 'disable cash payments';
	g.subtitle = 'only allow lightning payments';
  g.state = false;
	g.defaultValue = false;
	Object.defineProperty(g, "icon", {
		get : function () { return this.state? "\x0E":"\x0D"; }
	});
	g.appFunction = function() {
		cashcurrency.list.appFunction();
	}
	g.clickFunc = function(index) {
		const g = this;
		{ // For the GUI.
			g.state = !g.state; v.setRenderFlag(true);
		} { // For the app function.
			g.appFunction();
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.state,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.gadgets.push(v.showchange = g = new vp.Gadget(v));
	g.key = 'showChangeBreakdown';
	g.type = 'enable';
	g.title = 'enumerate change due';
	g.subtitle = 'shows how many of each denomination to return';
  g.state = false;
	g.defaultValue = false;
	Object.defineProperty(g, "icon", {
		get : function () { return this.state? "\x0E":"\x0D"; }
	});
	g.clickFunc = function(index) {
		const g = this;
		{ // For the GUI.
			g.state = !g.state; v.setRenderFlag(true);
		} { // For the app function.
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.state,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.load = function(cb) {
	const debuglog = false, g = this.showchange;
	const gads = [
		'enablelightning', 'disablecash', 'showchange',
	];
	function icb(cb, v) {
		let allComplete = true;
		for (let gad of gads) {
			if (v[gad].loadComplete) {
			} else {
				allComplete = false;
				break;
			}
			if (allComplete) {
				v.loadComplete = true; cb();
			}
		}
	}
	for (const gad of gads) {
		const g = this[gad];
		g.tempValue = g.defaultValue;
		function finishInit(cb, v, g) {
			{ // For the GUI.
				g.viewport.queueLayout();
			} { // For the app function.
				g.state = g.tempValue;
				if (g.appFunction) g.appFunction();
			} { // For persistence.
			}
			delete g.tempValue;
			if (debuglog) console.log(`${g.key} ready`, g.state);
			v.loadComplete = true; icb(cb, v);
		}
		if (debuglog) console.log("requesting", `${getCurrentAccount().id}-${g.key}`);
		var req = db.transaction(["settings"], "readonly")
			.objectStore("settings")
			.get(`${getCurrentAccount().id}-${g.key}`);
		req.onsuccess = (event) => {
			if (event.target.result !== undefined) {
				g.tempValue = event.target.result
				if (debuglog) console.log(`${g.key} restored`, g.tempValue);
			} else {
				if (debuglog) console.log(`${g.key} not used`, event.target.result);
			}
			finishInit(cb, this, g);
		};
		req.onerror = (event) => {
			console.log(`error getting ${g.key}`, event);
			finishInit(cb, this, g);
		};
	}
}
var wallettypes = ['manual', 'LNbits compatible']; //, 'strike compatible', 'coinos compatible'];

const walletsettings = v = new vp.View(null);
v.name = Object.keys({walletsettings}).pop();
v.title = 'wallet';
v.minX = 0; v.maxX = 0;
v.minY = 0; v.maxY = 0;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.swipeGad.hide = true;
Object.defineProperty(v, "wallet", {
	get : function () {
		const i = walletsettings.typelist.index;
		if (i >= 0 && i < wallettypes.length) switch (wallettypes[i]) {
		case 'LNbits compatible': return new LNbitsWallet(); break;
		}
		return new Wallet();
	}
});
v.gadgets.push(v.typelist = g = new vp.Gadget(v));
	g.key = 'walletType';
	g.list = wallettypes;
  g.index = -1;
	g.listItemClick = function(index) {
		const g = this, v = g.viewport;

		{ // For the GUI.
			v.typelist.index = index;
			v.setRenderFlag(true);
		} { // For the app function.

			if (wallettypes[index] == 'LNbits compatible') {
				delete v.lnbitsurl.hide;
				delete v.lnbitskey.hide;
			} else {
				v.lnbitsurl.hide = true;
				v.lnbitskey.hide = true;
			}

			if (wallettypes[index] == 'strike compatible') {
				delete v.strikeurl.hide;
				delete v.strikekey.hide;
			} else {
				v.strikeurl.hide = true;
				v.strikekey.hide = true;
			}

			if (wallettypes[index] == 'coinos compatible') {
				delete v.coinosurl.hide;
				delete v.coinoskey.hide;
			} else {
				v.coinosurl.hide = true;
				v.coinoskey.hide = true;
			}

			v.queueLayout();
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.list[index],
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.gadgets.push(v.lnbitsurl = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'LNbitsURL';
	g.title = 'base URL';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value) {
				if (this.value.length < 50) return ' '+this.value;
				else return ' '+this.value.substr(0,50)+'...';
			}	else return 'not set';
		}
	});
	g.value = '';
	g.defaultValue = 'https://lnbits.satoshidnc.com/api/v1';
	g.hide = true;
	g.daisychain = true;
	g.clickFunc = function() {
		const g = this;
		var val = prompt(tr('base URL')+':', g.defaultValue);
		if (!val) return;
		{ // For the GUI.
			g.viewport.queueLayout();
		} { // For the app function.
			g.value = val;
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.value,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.gadgets.push(v.lnbitskey = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'lnbitsKey';
	g.title = 'key';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value) {
				var temp;
				if (this.value.length > 4) temp = this.value.substr(0,4)+'*'.repeat(this.value.length-4); else temp = this.value;
				if (temp.length < 50) return ' '+temp;
				else return ' '+temp.substr(0,50)+'...';
			}	else return 'not set';
		}
	});
	g.value = '';
	g.hide = true;
	g.clickFunc = function() {
		const g = this;
		var val = prompt(tr('API admin or invoice/read key')+':');
		if (!val) return;
		{ // For the GUI.
			g.viewport.queueLayout();
		} { // For the app function.
			g.value = val;
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.value,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.gadgets.push(v.strikeurl = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'strikeURL';
	g.title = 'base URL';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value) {
				if (this.value.length < 50) return ' '+this.value;
				else return ' '+this.value.substr(0,50)+'...';
			}	else return 'not set';
		}
	});
	g.value = '';
	g.defaultValue = 'https://api.strike.me/v1';
	g.hide = true;
	g.daisychain = true;
	g.clickFunc = function() {
		const g = this;
		var val = prompt(tr('base URL')+':', g.defaultValue);
		if (!val) return;
		{ // For the GUI.
			g.viewport.queueLayout();
		} { // For the app function.
			g.value = val;
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.value,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.gadgets.push(v.strikekey = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'strikeKey';
	g.title = 'API bearer token';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value) {
				var temp;
				if (this.value.length > 4) temp = this.value.substr(0,4)+'*'.repeat(this.value.length-4); else temp = this.value;
				if (temp.length < 50) return ' '+temp;
				else return ' '+temp.substr(0,50)+'...';
			}	else return 'not set';
		}
	});
	g.value = '';
	g.hide = true;
	g.clickFunc = function() {
		const g = this;
		var val = prompt(tr('API bearer token')+':');
		if (!val) return;
		{ // For the GUI.
			g.viewport.queueLayout();
		} { // For the app function.
			g.value = val;
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.value,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.gadgets.push(v.coinosurl = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'coinosURL';
	g.title = 'base URL';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value) {
				if (this.value.length < 50) return ' '+this.value;
				else return ' '+this.value.substr(0,50)+'...';
			}	else return 'not set';
		}
	});
	g.value = '';
	g.defaultValue = 'https://coinos.io/api';
	g.hide = true;
	g.daisychain = true;
	g.clickFunc = function() {
		const g = this;
		var val = prompt(tr('base URL')+':', g.defaultValue);
		if (!val) return;
		{ // For the GUI.
			g.viewport.queueLayout();
		} { // For the app function.
			g.value = val;
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.value,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.gadgets.push(v.coinoskey = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'coinosKey';
	g.title = 'API auth token';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value) {
				var temp;
				if (this.value.length > 4) temp = this.value.substr(0,4)+'*'.repeat(this.value.length-4); else temp = this.value;
				if (temp.length < 50) return ' '+temp;
				else return ' '+temp.substr(0,50)+'...';
			}	else return 'not set';
		}
	});
	g.value = '';
	g.hide = true;
	g.clickFunc = function() {
		const g = this;
		var val = prompt(tr('API auth token')+':');
		if (!val) return;
		{ // For the GUI.
			g.viewport.queueLayout();
		} { // For the app function.
			g.value = val;
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.value,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.load = function(cb) {
	const debuglog = false;
	{
		const g = this.typelist, v = this;
		g.tempValue = '';
		function finishInit(cb, v) {
			const g = v.typelist;
			var index = -1;
			for (var i=0; i<wallettypes.length; i++) {
				if (wallettypes[i] == g.tempValue) {
					index = i;
					break;
				}
			}
			if (index < 0) index = 0;
			{ // For the GUI.
				walletsettings.typelist.index = index;
				walletsettings.setRenderFlag(true);
			} { // For the app function.

				if (wallettypes[index] == 'LNbits compatible') {
					delete v.lnbitsurl.hide;
					delete v.lnbitskey.hide;
				} else {
					v.lnbitsurl.hide = true;
					v.lnbitskey.hide = true;
				}

				if (wallettypes[index] == 'strike compatible') {
					delete v.strikeurl.hide;
					delete v.strikekey.hide;
				} else {
					v.strikeurl.hide = true;
					v.strikekey.hide = true;
				}

				if (wallettypes[index] == 'coinos compatible') {
					delete v.coinosurl.hide;
					delete v.coinoskey.hide;
				} else {
					v.coinosurl.hide = true;
					v.coinoskey.hide = true;
				}

				v.queueLayout();
			} { // For persistence.
			}
			if (debuglog) console.log(`${g.key} ready`, g.tempValue);
			v.loadComplete = true; cb();
		}
		if (debuglog) console.log("requesting", `${getCurrentAccount().id}-${g.key}`);
		var req = db.transaction(["settings"], "readonly")
			.objectStore("settings")
			.get(`${getCurrentAccount().id}-${g.key}`);
		req.onsuccess = (event) => {
			g.tempValue = event.target.result
			if (debuglog) console.log(`${g.key} restored`, g.tempValue);
			finishInit(cb, this);
		};
		req.onerror = (event) => {
			console.log(`error getting ${g.key}`, event);
			finishInit(cb, this);
		};
	}
	for (const gad of [
		'lnbitsurl', 'lnbitskey',
		'strikeurl', 'strikekey',
		'coinosurl', 'coinoskey',
	]) {
		const g = this[gad];
		g.tempValue = g.defaultValue;
		function finishInit(v, g) {
			{ // For the GUI.
				g.viewport.queueLayout();
			} { // For the app function.
				g.value = g.tempValue;
			} { // For persistence.
			}
			delete g.tempValue;
			if (debuglog) console.log(`${g.key} ready`, g.value);
		}
		if (debuglog) console.log("requesting", `${getCurrentAccount().id}-${g.key}`);
		var req = db.transaction(["settings"], "readonly")
			.objectStore("settings")
			.get(`${getCurrentAccount().id}-${g.key}`);
		req.onsuccess = (event) => {
			if (event.target.result !== undefined)
				g.tempValue = event.target.result;
			if (debuglog) console.log(`${g.key} restored`, g.tempValue);
			finishInit(this, g);
		};
		req.onerror = (event) => {
			console.log(`error getting ${g.key}`, event);
			finishInit(this, g);
		};
	}
}
var pricelisttypes = ['none', 'NostrMarket compatible'];


const nostrmarketstall = v = new vp.View(null);
v.name = Object.keys({nostrmarketstall}).pop();
v.title = 'NostrMarket stall';
v.minX = 0; v.maxX = 0;
v.minY = 0; v.maxY = 0;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.swipeGad.hide = true;
v.gadgets.push(v.list = g = new vp.Gadget(v));
  g.key = 'nostrMarketStall';
  g.state = 0;
  Object.defineProperty(g, "list", {
    get : function () {
      if (this.state == 2) return this.stallList
      if (this.state == 1) return ['']
      const url = pricelistsettings.nostrmarketurl.value
      const key = pricelistsettings.nostrmarketwalletkey.value
      if (!url || !key) return ['']
      this.state = 1
      console.groupCollapsed(this.constructor.name+'.get()');
      console.log('initializing', key != '')
      const asyncLogic = async () => {
        console.log('getting stalls', url)
        try {
          const response = await fetch(url+'/stall?pending=false&api-key='+key, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
            },
          });
          const json = await response.json()
          console.log(json)
          const tempList = []
          json.map(e => { const { id, name } = e; tempList.push({ title: name, id }) })
          this.stallList = tempList
          this.state = 2
          this.viewport.setRenderFlag(true)
          pricelistsettings.setRenderFlag(true)
          nostrmarketstall.list.appFunction()
        } catch (e) {
          console.error(e)
          this.state = 0
        }
      }
      asyncLogic()
      console.groupEnd()
      return ['']
    }
  });
  g.index = -1;
	Object.defineProperty(g, "value", {
		get : function () {
			if (this.index >= 0 && this.index < this.list.length)
				return this.list[this.index];
			return '';
		}
	});
	g.appFunction = function() {
		const v = pricelistsettings
    v.setRenderFlag(true)
    if (pricelisttypes[v.typelist.index] == 'NostrMarket compatible' && this.value) {
      PriceList.instance.loadNostrMarketData(pricelistsettings.nostrmarketurl.value, pricelistsettings.nostrmarketwalletkey.value, this.value.id)
    }
	}
	g.listItemClick = function(index) {
		const g = this;
		{ // For the GUI.
			g.index = index; v.setRenderFlag(true);
		} { // For the app function.
			g.appFunction();
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.value,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.load = function(cb) {
	const debuglog = false;
	const g = this.list;
	g.tempValue = g.defaultValue;
  g.state = 0;
	function finishInit(cb, v, g) {
		var index = -1;
		for (var i=0; i<g.list.length; i++) {
			if (g.list[i] == g.tempValue) {
				index = i;
				break;
			}
		}
		if (index < 0) index = 0;
		{ // For the GUI.
			nostrmarketstall.list.index = index;
			nostrmarketstall.setRenderFlag(true);
		} { // For the app function.
			g.appFunction();
		} { // For persistence.
		}
		delete g.tempValue;
		if (debuglog) console.log(`${g.key} ready`, g.value);
		v.loadComplete = true; cb();
	}
	if (debuglog) console.log("requesting", `${getCurrentAccount().id}-${g.key}`);
	var req = db.transaction(["settings"], "readonly")
		.objectStore("settings")
		.get(`${getCurrentAccount().id}-${g.key}`);
	req.onsuccess = (event) => {
		if (event.target.result !== undefined)
			g.tempValue = event.target.result;
		if (debuglog) console.log(`${g.key} restored`, g.tempValue);
		finishInit(cb, this, g);
	};
	req.onerror = (event) => {
		console.log(`error getting ${g.key}`, event);
		finishInit(cb, this, g);
	};
}


const pricelistsettings = v = new vp.View(null);
v.name = Object.keys({pricelistsettings}).pop();
v.title = 'price list';
v.minX = 0; v.maxX = 0;
v.minY = 0; v.maxY = 0;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.swipeGad.hide = true;
v.gadgets.push(v.typelist = g = new vp.Gadget(v));
	g.key = 'priceListType';
	g.list = pricelisttypes;
	g.index = -1;
	g.listItemClick = function(index) {
		const g = this, v = g.viewport;

		{ // For the GUI.
			v.typelist.index = index;
			v.setRenderFlag(true);
		} { // For the app function.
      g.appFunction()
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.list[index],
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
  g.appFunction = function() {
    const v = this.viewport
    if (pricelisttypes[v.typelist.index] == 'none') {
      try {
        console.log(config, config.priceList)
        config.priceList.setEmojiDefault()
        delete emojipane.lastBuilt
        delete emojipane.emojiPoints
        emojiShapes.build(config.priceList.thumbnailData, config.priceList.thumbnailsPerRow, config.priceList.thumbnailsPerColumn, emojipane.emojiPoints)
        emojipane.queueLayout()
      } catch {
        console.log('caught')
      }
    }
    if (pricelisttypes[v.typelist.index] == 'NostrMarket compatible') {
      delete v.nostrmarketurl.hide;
      delete v.nostrmarketwalletkey.hide;
      delete v.nostrmarketstall.hide;
      v.nostrmarketurl.appFunction();
      v.nostrmarketwalletkey.appFunction();
    } else {
      v.nostrmarketurl.hide = true;
      v.nostrmarketwalletkey.hide = true;
      v.nostrmarketstall.hide = true;
    }
    v.queueLayout();
  }
v.gadgets.push(v.nostrmarketurl = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'NostrMarketURL';
	g.title = 'base URL';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value) {
				if (this.value.length < 50) return ' '+this.value;
				else return ' '+this.value.substr(0,50)+'...';
			}	else return 'not set';
		}
	});
	g.value = '';
	g.defaultValue = 'https://lnbits.satoshidnc.com/nostrmarket/api/v1';
	g.hide = true;
	g.daisychain = true;
	g.clickFunc = function() {
		const g = this;
		var val = prompt(tr('base URL')+':', g.defaultValue);
		if (!val) return;
		{ // For the GUI.
			g.viewport.queueLayout();
		} { // For the app function.
			g.value = val;
      g.appFunction()
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.value,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
  g.appFunction = function() {
		const v = this.viewport;
    if (pricelisttypes[v.typelist.index] == 'NostrMarket compatible') {
      nostrmarketstall.load(() => {})
    }
  }
v.gadgets.push(v.nostrmarketwalletkey = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'nostrMarketWalletKey';
	g.title = 'key';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			if (this.value) {
				var temp;
				if (this.value.length > 4) temp = this.value.substr(0,4)+'*'.repeat(this.value.length-4); else temp = this.value;
				if (temp.length < 50) return ' '+temp;
				else return ' '+temp.substr(0,50)+'...';
			}	else return 'not set';
		}
	});
	g.value = '';
	g.hide = true;
  g.daisychain = true;
	g.clickFunc = function() {
		const g = this;
		var val = prompt(tr('API admin or invoice/read key')+':');
		if (!val) return;
		{ // For the GUI.
			g.viewport.queueLayout();
		} { // For the app function.
			g.value = val;
      g.appFunction()
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.value,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
  g.appFunction = function() {
		const v = this.viewport;
    if (pricelisttypes[v.typelist.index] == 'NostrMarket compatible') {
      nostrmarketstall.load(() => {})
    }
  }
v.gadgets.push(v.nostrmarketstall = g = new vp.Gadget(v));
	g.title = 'stall';
	Object.defineProperty(g, "subtitle", {
		get : function () { try { return nostrmarketstall.list.value.title } catch (e) {} }
	});
	g.pane = nostrmarketstall;
/*
v.gadgets.push(v.manageprices = g = new vp.Gadget(v));
	g.type = 'button';
	g.key = 'managePrices';
	g.title = 'manage price list';
	Object.defineProperty(g, "subtitle", {
		get : function () {
			return String(config.priceList.length) + ' items';
		}
	});
	g.value = '';
	g.defaultValue = '';
	g.clickFunc = function() {
		const g = this;
		var val = prompt(tr('base URL')+':', g.defaultValue);
		if (!val) return;
		{ // For the GUI.
			g.viewport.queueLayout();
		} { // For the app function.
			g.value = val;
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.value,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
*/
v.load = function(cb) {
	const debuglog = true;
	{
		const g = this.typelist, v = this;
		g.tempValue = '';
		function finishInit(cb, v) {
			const g = v.typelist;
			var index = -1;
			for (var i=0; i<pricelisttypes.length; i++) {
				if (pricelisttypes[i] == g.tempValue) {
					index = i;
					break;
				}
			}
			if (index < 0) index = 0;
			{ // For the GUI.
				pricelistsettings.typelist.index = index;
				pricelistsettings.setRenderFlag(true);
			} { // For the app function.
        pricelistsettings.typelist.appFunction()
			} { // For persistence.
			}
			if (debuglog) console.log(`${g.key} ready`, g.tempValue);
			v.loadComplete = true; cb();
		}
		if (debuglog) console.log("requesting", `${getCurrentAccount().id}-${g.key}`);
		var req = db.transaction(["settings"], "readonly")
			.objectStore("settings")
			.get(`${getCurrentAccount().id}-${g.key}`);
		req.onsuccess = (event) => {
			g.tempValue = event.target.result
			if (debuglog) console.log(`${g.key} restored`, g.tempValue);
			finishInit(cb, this);
		};
		req.onerror = (event) => {
			console.log(`error getting ${g.key}`, event);
			finishInit(cb, this);
		};
	}
	for (const gad of [
		'nostrmarketurl', 'nostrmarketwalletkey',
	]) {
		const g = this[gad];
		g.tempValue = g.defaultValue;
		function finishInit(v, g) {
			{ // For the GUI.
				g.viewport.queueLayout();
			} { // For the app function.
				g.value = g.tempValue;
        g.appFunction()
			} { // For persistence.
			}
			delete g.tempValue;
			if (debuglog) console.log(`${g.key} ready`, g.value);
		}
		if (debuglog) console.log("requesting", `${getCurrentAccount().id}-${g.key}`);
		var req = db.transaction(["settings"], "readonly")
			.objectStore("settings")
			.get(`${getCurrentAccount().id}-${g.key}`);
		req.onsuccess = (event) => {
			if (event.target.result !== undefined)
				g.tempValue = event.target.result;
			if (debuglog) console.log(`${g.key} restored`, g.tempValue);
			finishInit(this, g);
		};
		req.onerror = (event) => {
			console.log(`error getting ${g.key}`, event);
			finishInit(this, g);
		};
	}
}
const layoutsettings = v = new vp.View(null);
v.name = Object.keys({layoutsettings}).pop();
v.title = 'layout';
v.minX = 0; v.maxX = 0;
v.minY = 0; v.maxY = 0;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.swipeGad.hide = true;
v.gadgets.push(v.countermode = g = new vp.Gadget(v));
	g.key = 'enableCustomerPane';
	g.type = 'enable';
	g.title = 'Customer-facing pane';
  g.state = false;
	Object.defineProperty(g, "icon", {
		get : function () { return this.state? "\x0E":"\x0D"; }
	});
	g.clickFunc = function(index) {
console.log('clck');
		const g = this;
		{ // For the GUI.
			g.state = !g.state; v.setRenderFlag(true);
		} { // For the app function.
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.state,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.load = function(cb) {
	const debuglog = false, g = this.countermode;
	var selectedValue = false;
	function finishInit(cb, v) {
		const g = v.countermode;
		g.state = selectedValue? true: false;
		{ // For the GUI.
			v.setRenderFlag(true);
		} { // For the app function.
			//defaultVendorCurrency = g.list[index];
		} { // For persistence.
		}
		if (debuglog) console.log(`${g.key} ready`, g.state);
		v.loadComplete = true; cb();
	}
	if (debuglog) console.log("requesting", `${getCurrentAccount().id}-${g.key}`);
	var req = db.transaction(["settings"], "readonly")
		.objectStore("settings")
		.get(`${getCurrentAccount().id}-${g.key}`);
	req.onsuccess = (event) => {
		selectedValue = event.target.result
		if (debuglog) console.log(`${g.key} restored`, selectedValue);
		finishInit(cb, this);
	};
	req.onerror = (event) => {
		console.log(`error getting ${g.key}`, event);
		finishInit(cb, this);
	};
}
const themes = [
	{ title: 'light mode', subtitle: 'default', theme: new DefaultLightTheme() },
	{ title: 'dark mode', subtitle: 'default', theme: new DefaultDarkTheme() },
];

const textures = [
	{ title: 'tradfi', font: financeGraphicsFont, width: 120, height: 120, pattern:
		"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F" +
		"\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F" +
		"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2A\x2B\x2C\x2D\x2E\x2F" +
		"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3A\x3B\x3C\x3D\x3E\x3F" +
		"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4A\x4B\x4C\x4D\x4E\x4F" +
		"\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5A\x5B\x5C\x5D\x5E\x5F" +
		"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6A\x6B\x6C\x6D\x6E\x6F" +
		"\x70" +
		""
	},
	{ title: 'plain', font: undefined, pattern: "" },
];

const colorsettings = v = new vp.View(null);
v.name = Object.keys({colorsettings}).pop();
v.title = 'themes';
v.minX = 0; v.maxX = 0;
v.minY = 0; v.maxY = 0;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.swipeGad.hide = true;
v.gadgets.push(v.themelist = g = new vp.Gadget(v));
	g.key = 'themeColors';
	g.list = themes;
  g.index = -1;
	g.listItemClick = function(index) {
		const g = this, v = g.viewport;
		{ // For the GUI.
			g.index = index;
			home.setRenderFlag(true);
		} { // For the app function.
			customerColors = themes[index].theme;
      mainShapes.build()
      emojiShapes.build(config.priceList.thumbnailData, config.priceList.thumbnailsPerRow, config.priceList.thumbnailsPerColumn, emojipane.emojiPoints)
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.list[index].title, `${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.gadgets.push(v.texturelist = g = new vp.Gadget(v));
	g.key = 'themeTexture';
	g.list = textures;
  g.index = -1;
	g.listItemClick = function(index) {
		const g = this, v = g.viewport;
		{ // For the GUI.
			g.index = index;
			home.setRenderFlag(true);
		} { // For the app function.
			if (textures[index].font) textures[index].font.init();
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.list[index].title, `${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.load = function(cb) {
	const debuglog = false;
	const gads = [
		'themelist', 'texturelist',
	];
	function icb(cb, v) {
		if (v.themelist.loadComplete && v.texturelist.loadComplete) {
			v.loadComplete = true; cb();
		}
	}
	for (const gad of gads) {
		const g = this[gad];
		g.tempValue = '';
		function finishInit(cb, v, g) {
			var index = -1;
			for (var i=0; i<g.list.length; i++) {
				if (g.list[i].title == g.tempValue) {
					index = i;
					break;
				}
			}
			if (index < 0) index = 0;
			g.index = index;
			settingspane.setRenderFlag(true);
			if (g === v.themelist) {
				customerColors = themes[(index >= 0)? index: 1].theme;
        mainShapes.build()
        emojiShapes.build(config.priceList.thumbnailData, config.priceList.thumbnailsPerRow, config.priceList.thumbnailsPerColumn, emojipane.emojiPoints)
			}
			if (g === v.texturelist) {
				if (textures[index].font) textures[index].font.init();
			}
			delete g.tempValue;
			if (debuglog) console.log(`${g.key} ready`, g.index);
			g.loadComplete = true; icb(cb, v);
		}
		if (debuglog) console.log("requesting", `${getCurrentAccount().id}-${g.key}`);
		var req = db.transaction(["settings"], "readonly")
			.objectStore("settings")
			.get(`${getCurrentAccount().id}-${g.key}`);
		req.onsuccess = (event) => {
			if (event.target.result !== undefined)
				g.tempValue = event.target.result;
			if (debuglog) console.log(`${g.key} restored`, g.tempValue);
			finishInit(cb, this, g);
		};
		req.onerror = (event) => {
			console.log(`error getting ${g.key}`, event);
			finishInit(cb, this, g);
		};
	}
}
const cameras = [];
var camerasLoaded = false;
var cameraSettingTrigger = false;
if (!navigator.mediaDevices?.enumerateDevices) {
  console.log("enumerateDevices() not supported.");
} else {
  navigator.mediaDevices
    .enumerateDevices()
    .then((devices) => {
			var x = 0;
      for (var i=0; i<devices.length; i++) {
				var device = devices[i];
				if (device.kind == 'videoinput') {
					x += 1;
					cameras.push({
						title: device.label? device.label: `camera ${x}`,
						label: device.label,
						deviceId: device.deviceId
					});
				}
      }
			camerasLoaded = true;
			loadCameraSettingGuarded();
    })
    .catch((err) => {
      console.error(`${err.name}: ${err.message}`);
    });
}

function loadCameraSettingGuarded() {
	if (!cameraSettingTrigger || !camerasLoaded) return;
	const debuglog = false;
	var selectedCameraId = '';
	function finishCameraInit() {
		var index = -1;
		for (var i=0; i<cameras.length; i++) {
			if (cameras[i].deviceId == selectedCameraId) {
				index = i;
				break;
			}
		}
		{ // For the GUI.
			camerasettings.cameralist.index = index;
			camerasettings.setRenderFlag(true);
		} { // For the app function.
			BarcodeScanner.cameraId = (index >= 0)? cameras[index].deviceId: '';
		} { // For persistence.
		}
		if (debuglog) console.log("camera setting ready", camerasettings.cameralist.index);
	}
	if (debuglog) console.log("requesting", `${getCurrentAccount().id}-selectedCameraId`);
	var req = db.transaction(["settings"], "readonly")
		.objectStore("settings")
		.get(`${getCurrentAccount().id}-selectedCameraId`);
	req.onsuccess = (event) => {
		selectedCameraId = event.target.result
		if (debuglog) console.log("selectedCameraId restored", selectedCameraId);
		finishCameraInit();
	};
	req.onerror = (event) => {
		console.log("error getting selectedCameraId", event);
		finishCameraInit();
	};
}

const camerasettings = v = new vp.View(null);
v.name = Object.keys({camerasettings}).pop();
v.title = 'camera selection';
v.minX = 0; v.maxX = 0;
v.minY = 0; v.maxY = 0;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.swipeGad.hide = true;
v.gadgets.push(v.cameralist = g = new vp.Gadget(v));
	g.list = cameras;
  g.index = -1;
	g.listItemClick = function(index) {
		const g = this;
		{ // For the GUI.
			g.index = index; v.setRenderFlag(true);
		} { // For the app function.
			BarcodeScanner.cameraId = cameras[index].deviceId;
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(cameras[index].deviceId,
					`${getCurrentAccount().id}-selectedCameraId`);
			req.onsuccess = (event) => {
				console.log("successfully selected camera", event);
			};
			req.onerror = (event) => {
				console.log("error selecting camera", event);
			};
		}
	}
/*
	g.actionFlags = vp.GAF_CLICKABLE;
	g.w = 400; g.h = 50 * cameras.length;
	g.x = 0; g.y = 50;
	g.autoHull();
	g.layoutFunc = function() {
		const g = this;
		g.h = 50 * cameras.length;
		g.autoHull();
	}
	g.renderFunc = function() {
	}
	g.clickFunc = function(p) {
		const g = this, v = g.viewport;
		const y = p.y / v.getScale();
		const index = Math.min(Math.max(Math.floor((y - g.y) / 50), 0), cameras.length-1);

		cameraIndex = index; v.setRenderFlag(true); // For the GUI.
		BarcodeScanner.cameraId = cameras[index].deviceId; // For the app function.
		localStorage.setItem("cameraChoice", cameras[index].deviceId); // For persistence.
	}
v.layoutFunc = function() {
	for (const g of this.gadgets) {
		if (g.layoutFunc) g.layoutFunc.call(g);
	}
}
v.renderFunc = function() {
	const th = config.themeColors;
	gl.clearColor(...th.uiBackground);
	gl.clear(gl.COLOR_BUFFER_BIT);
	mainShapes.useProg5();
	gl.enable(gl.BLEND);
	gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
		new Float32Array(th.uiForeground));
	gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uProjectionMatrix'), false, this.mat);
	for (const g of this.gadgets) {
		if (g.renderFunc) g.renderFunc.call(g);
	}
	const mat = mat4.create();
	var y = 0;
	//mat4.identity(mat);
	//defaultFont.draw(50,y + (50-16)/2+14,tr('Camera Selection'),th.uiText, this.mat, mat);
	//y += 50;

	for (var i=0; i<cameras.length; i++) {
		mat4.identity(mat);
		var color = th.uiText; if (i == cameraIndex) color = th.uiLightningYellow;
		var s = cameras[i].label;
		if (s == '') s = 'Camera ' + (i + 1);
		defaultFont.draw(50,y + (50-16)/2+14,s,color, this.mat, mat);
		y += 50;
	}

	mat4.identity(mat);
	defaultFont.draw(10,y+(50-16)/2+14,tr('The camera you choose will be requested for'),th.uiText, this.mat, mat);
	mat4.identity(mat);
	defaultFont.draw(10,y+(50-16)/2+14+16,tr('scanning QR codes.'),th.uiText, this.mat, mat);
}
*/
v.gadgets.push(v.itemscan = g = new vp.Gadget(v));
	g.key = 'enableItemScan';
	g.type = 'enable';
	g.title = 'barcode scanning';
	g.subtitle = 'enable barcode scanning function';
  g.state = false;
	Object.defineProperty(g, "icon", {
		get : function () { return this.state? "\x0E":"\x0D"; }
	});
	g.appFunction = function() {
		const g = this;
		camerasettings.lnscan.hide = !g.state;
		camerasettings.lnscan.enabled = !camerasettings.lnscan.hide;
    g.viewport.queueLayout()
	}
	g.clickFunc = function(index) {
		const g = this;
		{ // For the GUI.
			g.state = !g.state; v.setRenderFlag(true);
		} { // For the app function.
			if (g.appFunction) g.appFunction();
		} { // For persistence.
			var req = db.transaction(["settings"], "readwrite");
			req.objectStore("settings")
				.put(g.state,
					`${getCurrentAccount().id}-${g.key}`);
			req.onsuccess = (event) => {
				console.log(`successfully selected ${g.key}`, event);
			};
			req.onerror = (event) => {
				console.log(`error selecting ${g.key}`, event);
			};
		}
	}
v.gadgets.push(v.lnscan = g = new vp.Gadget(v));
	g.key = 'enableLightningScan';
	g.type = 'enable';
	g.title = 'lightning invoice scanning';
	g.subtitle = 'to pay lightning invoices on behalf of customer';
  g.state = false;
	Object.defineProperty(g, "icon", {
		get : function () { return this.state? "\x0E":"\x0D"; }
	});
	g.clickFunc = v.itemscan.clickFunc;

v.load = function(cb) {
	cameraSettingTrigger = true;
	loadCameraSettingGuarded();

	const debuglog = false;
	const gads = [
		'itemscan', 'lnscan',
	];
	function icb(cb, v) {
		let allComplete = true;
		for (let gad of gads) {
			if (v[gad].loadComplete) {
			} else {
				allComplete = false;
				break;
			}
			if (allComplete) {
				v.loadComplete = true; cb();
			}
		}
	}
	for (const gad of gads) {
		const g = this[gad];
		g.tempValue = g.defaultValue;
		function finishInit(cb, v, g) {
			g.state = g.tempValue? true: false;
			{ // For the GUI.
				v.setRenderFlag(true);
			} { // For the app function.
				if (g.appFunction) g.appFunction();
			} { // For persistence.
			}
			if (debuglog) console.log(`${g.key} ready`, g.state);
			v.loadComplete = true; icb(cb, v);
		}
		if (debuglog) console.log("requesting", `${getCurrentAccount().id}-${g.key}`);
		var req = db.transaction(["settings"], "readonly")
			.objectStore("settings")
			.get(`${getCurrentAccount().id}-${g.key}`);
		req.onsuccess = (event) => {
			g.tempValue = event.target.result
			if (debuglog) console.log(`${g.key} restored`, g.tempValue);
			finishInit(cb, this, g);
		};
		req.onerror = (event) => {
			console.log(`error getting ${g.key}`, event);
			finishInit(cb, this, g);
		};
	}
}
const dangerzone = v = new vp.View(null);
v.name = Object.keys({dangerzone}).pop();
v.title = 'danger zone';
v.minX = 0; v.maxX = 0;
v.minY = 0; v.maxY = 0;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.swipeGad.hide = true;
v.gadgets.push(v.deleteall = g = new vp.Gadget(v));
	g.icon = "\x03";
	g.color = [1,0,0,1];
	g.title = 'delete all data';
	g.button = true;
	g.clickFunc = function() {
		const g = this;
		if (confirm(tr('are you sure?'))) {
			console.log('Deleting database...');
			db.close();
			const req = indexedDB.deleteDatabase("DB");
			req.onsuccess = (e) => {
				console.log('Database deleted.');
				openDatabase();
				alert(tr('all data has been deleted and/or reset to installation defaults'));
				settingspages.toPage(0);
			};
			req.onerror = (e) => {
				console.log('Error deleting database.');
				openDatabase();
				alert(tr('an error occurred'));
				settingspages.toPage(0);
			};
		}
	}
var mainsettings = v = new vp.View(null);
v.name = Object.keys({mainsettings}).pop();
v.title = 'settings';
v.minX = 0; v.maxX = 0;
v.minY = 0; v.maxY = 0;
v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SCROLLABLE_UPDOWN;
v.swipeGad.hide = true;
v.layoutFunc = function() {
	const v = this;
	v.maxX = v.sw;
	if (v.swipeGad) v.swipeGad.layout.call(v.swipeGad);
	var y = 25;
	var x = v.sw;
	var skipspace = false;
	for (const g of this.gadgets) {
		if (g.hide) {
			skipspace = true;
		} else if (g.layoutFunc) {
			g.layoutFunc();
		} else if (g.list) {
			g.clickFunc = function(p) {
				settingsbuttons.listClickFunc.call(g, p);
			}
			g.actionFlags = vp.GAF_CLICKABLE;
			g.w = v.sw; g.h = 50 * (g.list.length + (g.canAdd?1:0));
			g.x = 0; g.y = y;
			y += g.h; x = v.sw;
			g.autoHull();
		} else if (['button','enable'].includes(g.type) || g.button) {
			g.actionFlags = vp.GAF_CLICKABLE;
			g.w = v.sw; g.h = g.subtitle?65:50;
			g.x = 0; g.y = y;
			y += g.h;
			g.autoHull();
		} else if (g.listToOverlay) {
			g.actionFlags = vp.GAF_CLICKABLE; g.z = 1;
			g.w = 30; g.h = 30;
			g.x = x - 40; g.y = g.listToOverlay.y + 10 + 50 * g.listToOverlay.index;
			x -= 50;
			g.autoHull();
			skipspace = true;
		} else {
			g.clickFunc = function() {
				settingsbuttons.subOptionClickFunc.call(this, this.pane);
			}
			g.actionFlags = vp.GAF_CLICKABLE;
			g.w = v.sw; g.h = 65;
			g.x = 0; g.y = y;
			y += g.h;
			g.autoHull();
		}
		if (!skipspace && !g.daisychain) y += 15;
		skipspace = false;
	}
	v.maxY = y;
}
v.renderFunc = function() {
	const th = config.themeColors;
	drawThemeBackdrop(this, th);
	mainShapes.useProg5();
	gl.enable(gl.BLEND);
	gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
		new Float32Array(th.uiForeground));
	gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uProjectionMatrix'), false, this.mat);
	const mat = mat4.create();
	var y = 25, daisychain = false;
	const margin = (th.uiBackground[0] + th.uiBackground[1] + th.uiBackground[2] == 0)? 5:5;
	for (const g of this.gadgets) {
		if (g.hide) {
		} else if (g.renderFunc) {
			g.renderFunc.call(g);
		} else if (g.listToOverlay) {
			mainShapes.useProg2();
			gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'),
				false, this.mat);
			gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
				new Float32Array([1,1,1,1]));
			mat4.identity(mat);
			//mat4.translate(mat,mat, [g.x,g.y+15+2.5+i*optionheight+14,0]);
			mat4.translate(mat,mat, [g.x,g.y+5+2.5+14,0]);
			var color = th.uiSettingsText;
			iconFont.draw(0,0,g.icon,color, this.mat, mat);
		} else {
			mainShapes.useProg2();
			gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'),
				false, this.mat);
			gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'),
				new Float32Array(g.color?colorize(g.color, th.uiBackground, th.uiSettingsBubble):th.uiSettingsBubble));
			mat4.identity(mat);
			mat4.translate(mat,mat, [g.x+margin,g.y,0]);
			mat4.scale(mat,mat, [g.w-2*margin,25,1]);
			if (daisychain) {
				gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, mat);
				mainShapes.drawArrays2('rect');
			} else {
				mat4.scale(mat,mat, [1/16,1/1,1]);
				gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, mat);
				mainShapes.drawArrays2('settingstop');
			}

			if (g.daisychain) {
				mat4.identity(mat);
				mat4.translate(mat,mat, [g.x+margin,g.y+25,0]);
				mat4.scale(mat,mat, [g.w-2*margin,g.h-25,1]);
				gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, mat);
			} else {
				mat4.identity(mat);
				mat4.translate(mat,mat, [g.x+margin,g.y+g.h-25,0]);
				mat4.scale(mat,mat, [g.w-2*margin,25,1]);
				mat4.scale(mat,mat, [1/16,1/1,1]);
				gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, mat);
				mainShapes.drawArrays2('settingsbot');

				mat4.identity(mat);
				mat4.translate(mat,mat, [g.x+margin,g.y+25,0]);
				mat4.scale(mat,mat, [g.w-2*margin,g.h-50,1]);
				gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uModelViewMatrix'), false, mat);
			}
			mainShapes.drawArrays2('rect');

			if (daisychain) {
				mainShapes.useProg5();
				gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uProjectionMatrix'),
					false, this.mat);
				gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
					new Float32Array([1,1,1,1]));
				mat4.identity(mat);
				mat4.translate(mat,mat, [g.x+margin+25,g.y,0]);
				mat4.scale(mat,mat, [g.w-2*margin-50,1,1]);
				gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uModelViewMatrix'), false, mat);
				mainShapes.drawArrays5('divSettings');
			}

			if (g.list) {
				var optionheight = 50, gca = false;
				if (g.canAdd) gca = true;
				for (var i=0; i<g.list.length + gca?1:0; i++) {
					var li = i<g.list.length;
					const o = li? g.list[i]: undefined;
					mat4.identity(mat);
					mat4.translate(mat,mat, [g.x+20,g.y+15+2.5+i*optionheight+14,0]);
					if (g.selection !== undefined) {
						var color = g.selection.includes(g.list[i])?
							th.uiSettingSelect : th.uiSettingsText;
						if (li) {
							var str = g.selection.includes(g.list[i])?"\x0E":"\x0D";
							iconFont.draw(0,0,str,color, this.mat, mat);
							defaultFont.draw(0,0,' ',color, this.mat, mat);
						} else {
							iconFont.draw(0,0,"\x0B",color, this.mat, mat);
							defaultFont.draw(0,0,' ',color, this.mat, mat);
						}
					} else {
						var color = (i == g.index)? th.uiSettingSelect : th.uiSettingsText;
						if (li) {
							iconFont.draw(0,0,(i == g.index)?"\x06":"\x05",color, this.mat, mat);
							defaultFont.draw(0,0,' ',color, this.mat, mat);
						} else {
							iconFont.draw(0,0,"\x0B",color, this.mat, mat);
							defaultFont.draw(0,0,' ',color, this.mat, mat);
						}
					}
					var color = th.uiSettingsText;
					var str;
					if (li) {
						if (typeof o === 'object') {
							str = o.title;
						} else {
							str = o;
						}
					} else {
						str = 'add new';
					}
					str = icap(tr(str));
					defaultFont.draw(0,0,str,color, this.mat, mat);

					if (i==0) continue;
					mainShapes.useProg5();
					gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uProjectionMatrix'),
						false, this.mat);
					gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
						new Float32Array([1,1,1,1]));
					mat4.identity(mat);
					mat4.translate(mat,mat, [g.x+25,g.y+i*optionheight,0]);
					mat4.scale(mat,mat, [g.w-50,1,1]);
					gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uModelViewMatrix'), false, mat);
					mainShapes.drawArrays5('divSettings');
				}
			} else if (['button','enable'].includes(g.type) || g.button) {
				mat4.identity(mat);
				mat4.translate(mat,mat, [g.x+20,g.y+15+(g.subtitle?0:2.5)+14,0]);
				if (g.icon) {
					var color = g.color? g.color: th.uiSettingsText;
					if (g.icon == "\x0E") color = th.uiSettingSelect;
					iconFont.draw(0,0,g.icon,color, this.mat, mat);
					defaultFont.draw(0,0,' ',color, this.mat, mat);
				}
				var color = g.color? g.color: th.uiSettingsText;
				defaultFont.draw(0,0,icap(tr(g.title)),color, this.mat, mat);
				if (g.subtitle) {
					mat4.identity(mat);
					mat4.translate(mat,mat, [g.x+20,g.y+15,0]);
					mat4.translate(mat,mat, [0,16+6,0]);
					mat4.scale(mat,mat, [0.75,0.75,1]);
					var color = th.uiSettingsSubText;
					var str;
					if (typeof g.subtitle === 'object') {
						str = g.subtitle.map(a => icap(tr(a)).trim()).join(' · ');
					} else {
						if (g.subtitle.startsWith(' ')) str = g.subtitle.trim();
						else str = icap(tr(g.subtitle));
					}
					defaultFont.draw(0,14,str,color, this.mat, mat);
				}
			} else {
				mat4.identity(mat);
				mat4.translate(mat,mat, [g.x+20,g.y+15,0]);
				var color = th.uiSettingsText;
				var str = icap(tr(g.title));
				defaultFont.draw(0,14,str,color, this.mat, mat);

				mat4.identity(mat);
				mat4.translate(mat,mat, [g.x+20,g.y+15,0]);
				mat4.translate(mat,mat, [0,16+6,0]);
				mat4.scale(mat,mat, [0.75,0.75,1]);
				var color = th.uiSettingsSubText;
				var str;
				if (typeof g.subtitle === 'object') {
					str = g.subtitle.map(a => icap(tr(a))).join(' · ');
				} else {
					if (g.subtitle.startsWith(' ')) str = g.subtitle.trim();
					else str = icap(tr(g.subtitle));
				}
				defaultFont.draw(0,14,str,color, this.mat, mat);
			}
		}
		daisychain = g.daisychain;
	}
}
v.gadgets.push(g = new vp.Gadget(v));
	g.title = 'account';
	g.subtitle = 'switch account';
	g.pane = accountsettings;
	g.pane.layoutFunc = mainsettings.layoutFunc;
	g.pane.renderFunc = mainsettings.renderFunc;
v.gadgets.push(g = new vp.Gadget(v));
	g.title = 'language';
	g.subtitle = [];
	for (var lang of enabledLangs) {
		g.subtitle.push(icap(tr(lang,lang)));
	}
	g.pane = languagesettings;
	g.pane.layoutFunc = mainsettings.layoutFunc;
	g.pane.renderFunc = mainsettings.renderFunc;
	g.daisychain = true;
v.gadgets.push(v.currencysettings = g = new vp.Gadget(v));
	g.title = 'currencies';
	g.subtitle = supportedCurrencies;
	g.pane = currencysettings;
	g.pane.layoutFunc = mainsettings.layoutFunc;
	g.pane.renderFunc = mainsettings.renderFunc;
	g.daisychain = true;
v.gadgets.push(v.walletsettings = g = new vp.Gadget(v));
	g.title = 'wallet';
	g.subtitle = ['link a wallet'];
	g.pane = walletsettings;
	g.pane.layoutFunc = mainsettings.layoutFunc;
	g.pane.renderFunc = mainsettings.renderFunc;
v.gadgets.push(v.pricelistsettings = g = new vp.Gadget(v));
	g.title = 'price list';
	g.subtitle = ['import price list'];
	g.pane = pricelistsettings;
	g.pane.layoutFunc = mainsettings.layoutFunc;
	g.pane.renderFunc = mainsettings.renderFunc;
	g.daisychain = true;
v.gadgets.push(g = new vp.Gadget(v));
	g.title = 'QR code and barcode scanning';
	g.subtitle = ['camera selection', 'product barcodes'];
	g.pane = camerasettings;
	g.pane.layoutFunc = mainsettings.layoutFunc;
	g.pane.renderFunc = mainsettings.renderFunc;
/*
v.gadgets.push(g = new vp.Gadget(v));
	g.title = 'layout';
	g.subtitle = 'layout';
	g.pane = layoutsettings;
	g.pane.layoutFunc = mainsettings.layoutFunc;
	g.pane.renderFunc = mainsettings.renderFunc;
	g.daisychain = true;
*/
v.gadgets.push(g = new vp.Gadget(v));
	g.title = 'themes';
	g.subtitle = ['dark/light mode', 'colors', 'textures'];
	g.pane = colorsettings;
	g.pane.layoutFunc = mainsettings.layoutFunc;
	g.pane.renderFunc = mainsettings.renderFunc;
v.gadgets.push(g = new vp.Gadget(v));
	g.title = 'danger zone';
	g.subtitle = 'delete data';
	g.pane = dangerzone;
	g.pane.layoutFunc = mainsettings.layoutFunc;
	g.pane.renderFunc = mainsettings.renderFunc;

	maincurrency.layoutFunc = mainsettings.layoutFunc;
	maincurrency.renderFunc = mainsettings.renderFunc;
	cashcurrency.layoutFunc = mainsettings.layoutFunc;
	cashcurrency.renderFunc = mainsettings.renderFunc;
	nostrmarketstall.layoutFunc = mainsettings.layoutFunc;
	nostrmarketstall.renderFunc = mainsettings.renderFunc;
const settingsbuttons = v = new vp.View(null);
v.name = Object.keys({settingsbuttons}).pop();
v.gadgets.push(v.maximizer = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.layoutFunc = function() {
		var g = this, v = g.viewport, s = v.getScale();
		g.x = v.w/s - g.w - (50 - g.w)/2;
	}
	g.renderFunc = function() {
		const g = this, th = config.themeColors;
		const mat = mat4.create();
		mat4.identity(mat);
		mat4.translate(mat,mat, [g.x,g.y-10+Math.floor((50-16*1.5)/2),0]);
		mat4.scale(mat,mat, [1.5,1.5,1]);
		iconFont.draw(0,15,"\x09",th.uiText, g.viewport.mat, mat);
	}
	g.clickFunc = function() {
		fullscreen.toggle();
	}
v.gadgets.push(v.backbutton = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = (50 - g.w)/2; g.y = (50 - g.h)/2; g.z = 1;
	g.autoHull();
	g.renderFunc = function() {
		const g = this, th = config.themeColors;
		const mat = mat4.create();
		mat4.identity(mat);
		mat4.translate(mat,mat, [10,Math.floor((50-16*1.5)/2),0]);
		mat4.scale(mat,mat, [1.5,1.5,1]);
		if (settingspages.index == 0) {
			if (layoutIsVertical())
				iconFont.draw(0,15,"\x0A",th.uiText, g.viewport.mat, mat);
			else
				iconFont.draw(0,15,"\x08",th.uiText, g.viewport.mat, mat);
		} else {
			iconFont.draw(0,15,"\x07",th.uiText, g.viewport.mat, mat);
		}
	}
	g.clickFunc = function() {
		this.startTime = performance.now();
		if (settingspages.index > 0) {
			if (settingspages.tempVX) {
				if (this.clickedIndex > 0) {
					this.clickedIndex -= 1;
					settingspages.toPage(this.clickedIndex);
				}
			} else {
				this.clickedIndex = settingspages.index-1;
				settingspages.toPage(this.clickedIndex);
			}
		} else {
			if (layoutIsVertical()) {
				settingsbuttons.subOptionClickFunc(mainsettings);
			} else {
				hsettingspane.ratio = 1;
				hsettingspane.queueLayout();
			}
		}
	}
v.subOptionClickFunc = function(pane) {
	//console.log('suboption', pane.name);
	while (settingspages.pages.length > settingspages.index+1)
		settingspages.pages.pop();
	pane.userY = 0;
	settingspages.pages.push(pane);
	settingspages.toPage(settingspages.pages.length-1);
}
v.listClickFunc = function(p) {
	const g = this, v = g.viewport;
	const y = (p.y - v.y) / v.getScale() + v.userY;
	const index = Math.min(Math.max(Math.floor((y - g.y) / 50), 0),
		g.list.length-(g.canAdd?0:1));
	if (g.canAdd && index == g.list.length)
		g.listAddClick.call(g);
	else
		g.listItemClick.call(g, index);
}
v.layoutFunc = function() {
	for (const g of this.gadgets) {
		if (g.layoutFunc) g.layoutFunc.call(g);
	}
}
v.renderFunc = function() {
	const th = config.themeColors;
	gl.clearColor(...th.uiBackground);
	gl.clear(gl.COLOR_BUFFER_BIT);
	mainShapes.useProg5();
	gl.enable(gl.BLEND);
	gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
		new Float32Array(th.uiForeground));
	gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uProjectionMatrix'), false, this.mat);
	for (const g of this.gadgets) {
		if (g.renderFunc) g.renderFunc.call(g);
	}
	const mat = mat4.create();
	mat4.identity(mat);
	mat4.translate(mat,mat, [50,Math.floor((50-16*1.5)/2),0]);
	mat4.scale(mat,mat, [1.5,1.5,1]);
	var str = settingspages.pages[settingspages.index].title;
	if (str) {
		str = icap(tr(str));
		defaultFont.draw(0,14,str,th.uiText, this.mat, mat);
	}
}

const settingsbuttons2 = v = new vp.View(null);
v.name = Object.keys({settingsbuttons2}).pop();
v.gadgets.push(v.maximizer = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = (50 - g.w)/2; g.y = (50 - g.h)/2;
	g.autoHull();
	g.layoutFunc = function() {
		var g = this, v = g.viewport, s = v.getScale();
		g.x = v.w/s - g.w - (50 - g.w)/2;
	}
	g.renderFunc = function() {
		if (hsettingspane.ratio != 1) return;
		const g = this, th = config.themeColors;
		const mat = mat4.create();
		mat4.identity(mat);
		mat4.translate(mat,mat, [g.x,g.y-10+Math.floor((50-16*1.5)/2),0]);
		mat4.scale(mat,mat, [1.5,1.5,1]);
		iconFont.draw(0,15,"\x09",th.uiText, g.viewport.mat, mat);
	}
	g.clickFunc = function() {
		if (hsettingspane.ratio != 1) return;
		fullscreen.toggle();
	}
v.gadgets.push(v.backbutton = g = new vp.Gadget(v));
	g.w = 30; g.h = 30; g.actionFlags = vp.GAF_CLICKABLE;
	g.x = (50 - g.w)/2; g.y = (50 - g.h)/2; g.z = 1;
	g.autoHull();
	g.renderFunc = function() {
		const g = this, th = config.themeColors;
		const mat = mat4.create();
		mat4.identity(mat);
		mat4.translate(mat,mat, [10,Math.floor((50-16*1.5)/2),0]);
		mat4.scale(mat,mat, [1.5,1.5,1]);
		iconFont.draw(0,15,"\x0A",th.uiText, g.viewport.mat, mat);
	}
	g.clickFunc = function() {
		if (hsettingspane.ratio < 1) {
			hsettingspane.ratio = 1;
			hsettingspane.queueLayout();
		} else {
			hsettingspane.ratio = 1 - (400 / hsettingspane.sw);
			hsettingspane.queueLayout();
		}
	}
v.layoutFunc = function() {
	for (const g of this.gadgets) {
		if (g.layoutFunc) g.layoutFunc.call(g);
	}
}
v.renderFunc = function() {
	const th = config.themeColors;
	gl.clearColor(...th.uiBackground);
	gl.clear(gl.COLOR_BUFFER_BIT);
	mainShapes.useProg5();
	gl.enable(gl.BLEND);
	gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
		new Float32Array(th.uiForeground));
	gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uProjectionMatrix'), false, this.mat);
	for (const g of this.gadgets) {
		if (g.renderFunc) g.renderFunc.call(g);
	}
	const mat = mat4.create();
	mat4.identity(mat);
	mat4.translate(mat,mat, [50,Math.floor((50-16*1.5)/2),0]);
	mat4.scale(mat,mat, [1.5,1.5,1]);
	var str = startpane.title;
	if (str) {
		str = icap(tr(str));
		defaultFont.draw(0,14,str,th.uiText, this.mat, mat);
	}
}

const settingspages = v = new vp.PagesView(null, 'h');
v.name = Object.keys({settingspages}).pop();
v.swipeGad.z = -1;
v.pages.push(startpane);
v.pageChangeFunc = function() {
	//console.log('settings pagechange', this.pages[this.index].title);
	settingsbuttons.setRenderFlag(true);
}

const vsettingspane = v = new vp.SliceView(null, 't', 50);
v.name = Object.keys({vsettingspane}).pop();
v.designFit = [400, 400];
v.a = settingsbuttons; settingsbuttons.parent = v;
v.b = settingspages; settingspages.parent = v;
v.layoutFunc = function() {
	settingspages.designScale = this.viewScale;
}

const hhomepane = v = new vp.SliceView(null, 't', 50);
v.name = Object.keys({hhomepane}).pop();
//v.b = camerasettings; camerasettings.parent = v;
v.a = settingsbuttons2; settingsbuttons2.parent = v;
//v.b = startpane; startpane.parent = v;

const hsettingspane = v = new vp.DividerView(null, 'v', 0.5, 0);
v.name = Object.keys({vsettingspane}).pop();
v.designFit = [400, 400];
//v.b = camerasettings; camerasettings.parent = v;
v.a = hhomepane; hhomepane.parent = v;
//v.b = vsettingspane; vsettingspane.parent = v;
v.layoutFunc = function() {
	if (hsettingspane.ratio != 1) {
		hsettingspane.ratio = 1 - (400 / hsettingspane.sw);
		hsettingspane.b = vsettingspane; vsettingspane.parent = hsettingspane;
	}
}


var settingspane = vsettingspane;
var home = settingspane;

function verticalLayout() {
	home = settingspane = vsettingspane;
	if (!(settingspages.pages.length > 0 && settingspages.pages[0] === startpane)) { settingspages.pages.splice(0,0,startpane); settingspages.index += 1; }
	if (hsettingspane.ratio == 1) settingspages.index = 0;
	settingspages.keepPage();
	hsettingspane.b = undefined;
	menudiv.b = home; home.parent = menudiv;
	menudiv.queueLayout();
}
function horizontalLayout() {
	home = settingspane = hsettingspane;
	if (settingspages.pages.length > 0 && settingspages.pages[0] === startpane) { settingspages.pages.splice(0,1); settingspages.index -= 1; }
	if (settingspages.pages.length == 0) settingspages.pages.splice(0,0,mainsettings);
	if (settingspages.index < 0) {
		settingspages.index = 0;
		hsettingspane.ratio = 1;
	} else {
		//hsettingspane.b = vsettingspane; vsettingspane.parent = hsettingspane;
		hsettingspane.ratio = 0.5;
	}
	startpane.userX = 0;
	settingspages.keepPage();
	hhomepane.b = startpane; startpane.parent = hhomepane;
	menudiv.b = home; home.parent = menudiv;
	menudiv.queueLayout();
}
function layoutIsVertical() { return home === vsettingspane; }

  var menupane = v = new vp.View(null);
	v.name = Object.keys({menupane}).pop();
  v.gadgets.push(g = new vp.MatrixGadget(v));
  //g.w = 10; g.h = 1000; //g.f = GF_RELH;
	g.y = 100;
  g.convexHull = g.computeHull([50,50, 100,200, 200,200, 200,100]);
  g.actionFlags = vp.GAF_CLICKABLE;// | vp.GAF_DRAGGABLE | vp.GAF_PINCHABLE;
  g.clickFunc = function() {
    var g = this; g.f = !(g.f); vp.setDebugFlags(g.f, g.f);
    var v = g.viewport; while (v.parent) v = v.parent; v.setRenderFlag(true);
  }
  var quadrant4;
  v.gadgets.push(g = new vp.MatrixGadget(v));
  //g.w = 10; g.h = 1000; //g.f = GF_RELH;
  g.convexHull = g.computeHull([50,50, 100,200, 200,200, 200,100]);
  g.actionFlags = vp.GAF_CLICKABLE | vp.GAF_DRAGGABLE | vp.GAF_PINCHABLE;
  var mg1, mg2;
  g.clickFunc = function() {
    mat4.identity(mg1.targetView.userMat);
    mat4.identity(mg2.targetGad.mat);
    quadrant4.rematrix();
    quadrant4.setRenderFlag(true);
    quadrant4.renderAll();
    //console.log('click', this);
  }
  v.renderFunc = function() {
    gl.clearColor(0.380, 0.588, 0.259, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    mainShapes.useProg2();
    gl.enable(gl.BLEND);
    gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'), new Float32Array([0,0,0, 1]));
    gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, this.mat);
    const mat = mat4.create();
    for (const g of this.gadgets) {
      var h = g.convexHull;
      for (var p = 0; p < h.length; p += 2) {
      mat4.identity(mat);
      mat4.translate(mat, mat, [h[p+0]+g.x, h[p+1]+g.y, 0]);
      mat4.scale(mat, mat, [h[(p+2)%h.length]-h[p+0], h[(p+3)%h.length]-h[p+1], 0]);
      gl.uniformMatrix4fv(
        gl.getUniformLocation(prog2, 'uModelViewMatrix'),
        false, mat);
      mainShapes.drawArrays2('unitLine');
      }
    }
  };

  //v.gadgets.push(v.swipeGad = new vp.SwipeGadget(v));
  //v.swipeGad.actionFlags = vp.GAF_SWIPEABLE_UPDOWN | vp.GAF_SWIPEABLE_LEFTRIGHT;
  //v.layoutFunc = function() { this.swipeGad.layout(); }

  var quadrant3 = v = new vp.View(null);
	v.name = Object.keys({quadrant3}).pop();
  v.gadgets.push(g = new vp.MatrixGadget(v));
  //g.w = 10; g.h = 1000; //g.f = GF_RELH;
  g.convexHull = g.computeHull([50,50, 100,200, 200,200, 200,100]);
  g.actionFlags = vp.GAF_CLICKABLE | vp.GAF_CONTEXTMENU | vp.GAF_DRAGGABLE | vp.GAF_PINCHABLE;
  g.clickFunc = function() {
    //console.log('click', this);
  }
  v.renderFunc = function() {
    gl.clearColor(0.882, 0.647, 0.353, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    mainShapes.useProg2();
    gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'), new Float32Array([0,0,0, 1]));
    gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, this.mat);
    const mat = mat4.create();
    for (const g of this.gadgets) {
      var h = g.convexHull;
      for (p = 0; p < h.length; p += 2) {
      mat4.identity(mat);
      mat4.translate(mat, mat, [h[p+0], h[p+1], 0]);
      mat4.scale(mat, mat, [h[(p+2)%h.length]-h[p+0], h[(p+3)%h.length]-h[p+1], 0]);
      gl.uniformMatrix4fv(
        gl.getUniformLocation(prog2, 'uModelViewMatrix'),
        false, mat);
      mainShapes.drawArrays2('unitLine');
      }
    }
  };

  quadrant4 = v = new vp.View(null);
	v.name = Object.keys({quadrant4}).pop();
  v.gadgets.push(mg1 = g = new vp.MatrixGadget(v));
  g.convexHull = g.computeHull([50,50, 100,200, 200,200, 200,100]);
  g.actionFlags = vp.GAF_CLICKABLE | vp.GAF_DRAGGABLE | vp.GAF_PINCHABLE;
  g.clickFunc = function() {
    //console.log('click', this);
  }
  v.gadgets.push(mg2 = g = new vp.MatrixGadget(v));
  g.convexHull = g.computeHull([150,50, 200,200, 300,200, 300,100]);
  g.actionFlags = vp.GAF_CLICKABLE | vp.GAF_DRAGGABLE | vp.GAF_PINCHABLE;
  g.targetGad = g;
  g.clickFunc = function() {
    //console.log('click', this);
  }
  v.renderFunc = function() {
    gl.clearColor(0.416, 0.533, 0.573, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    mainShapes.useProg2();
    gl.enable(gl.BLEND);
    gl.uniform4fv(gl.getUniformLocation(prog2, 'overallColor'), new Float32Array([0,0,0, 1]));
    gl.uniformMatrix4fv(gl.getUniformLocation(prog2, 'uProjectionMatrix'), false, this.mat);
    const mat = mat4.create();
    for (const g of this.gadgets) {
      var h = g.convexHull;
      for (p = 0; p < h.length; p += 2) {
        mat4.identity(mat);
        mat4.multiply(mat, mat, g.mat);
        mat4.translate(mat, mat, [h[p+0], h[p+1], 0]);
        mat4.scale(mat, mat, [h[(p+2)%h.length]-h[p+0], h[(p+3)%h.length]-h[p+1], 0]);
        gl.uniformMatrix4fv(
          gl.getUniformLocation(prog2, 'uModelViewMatrix'),
          false, mat);
        mainShapes.drawArrays2('unitLine');
      }
    }
  };

function scrollUpDn(g, amt) {
	var wi2px = window.visualViewport.scale * window.devicePixelRatio;
	var px2wi = 1/wi2px;
	p = { gestureState: '', touching: false, px: 0, py: 0 }; p.e = {};
	p.x = 0 * wi2px; p.ox = p.x; p.px = p.x;
	p.y = 0 * wi2px; p.oy = p.y; p.py = p.y;
	if (g.swipeBeginFunc) g.swipeBeginFunc.call(g, p);
	p.dx = 0; p.x = p.x;
	p.dy = amt /* * window.devicePixelRatio*/; p.y = p.y + p.dy;
	if (g.swipeMoveFunc) g.swipeMoveFunc.call(g, p);
	if (g.swipeEndFunc) g.swipeEndFunc.call(g, p);
}
/*
	var scrollbar = v = new vp.View();
	v.name = Object.keys({scrollbar}).pop();
	v.gadgets.push(g = v.upGad = new vp.Gadget(v)); g.z = 2;
  g.clickFunc = function() { scrollUpDn(startpane.swipeGad, 0.885); }
  //g.holdBeginFunc = function () { console.log('hold-begin'); }
  //g.holdEndFunc = function () { console.log('hold-end'); }
	v.gadgets.push(g = v.dnGad = new vp.Gadget(v)); g.z = 2;
  g.clickFunc = function() { scrollUpDn(startpane.swipeGad, -0.885); }
  //g.holdBeginFunc = function () { console.log('hold-begin'); }
  //g.holdEndFunc = function () { console.log('hold-end'); }
	v.gadgets.push(g = v.knobGad = new vp.Gadget(v)); g.z = -1;
  g.shown = 40; g.total = 100; g.start = 10;
	v.gadgets.push(g = v.pupGad = new vp.Gadget(v)); g.z = -2;
  g.clickFunc = function() { scrollUpDn(startpane.swipeGad, 1.7); }
	v.gadgets.push(g = v.pdnGad = new vp.Gadget(v)); g.z = -2;
  g.clickFunc = function() { scrollUpDn(startpane.swipeGad, -1.7); }
	v.layoutFunc = function() {
		const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
		var g, v = this, s = v.getScale();
		g = v.upGad; g.actionFlags = (vp.GAF_CLICKABLE | vp.GAF_HOLDABLE);
		g.convexHull = g.computeHull([0,10, 5,0, 10,10]);
		g.extendedHulls = {}; g.boundingBoxes = {};

		g = v.dnGad; g.actionFlags = (vp.GAF_CLICKABLE | vp.GAF_HOLDABLE);
		g.convexHull = g.computeHull([0,0, 5,10, 10,0]); g.y = v.h/s - 10;
		g.extendedHulls = {}; g.boundingBoxes = {};

		g = v.knobGad; g.actionFlags = vp.GAF_DRAGGABLE_UPDOWN;
    var h = (v.h/s-20  )*clamp(g.shown/g.total, 0,1);
		var y = (v.h/s-20-h)*clamp(g.start/(g.total-g.shown), 0,1);
		g.convexHull = g.computeHull([0,y, 10,y, 10,y+h, 0,y+h]); g.y = 10;
		g.extendedHulls = {}; g.boundingBoxes = {};

		g = v.pupGad; g.actionFlags = vp.GAF_CLICKABLE;
		g.convexHull = g.computeHull([0,0, 10,0, 10,y, 0,y]); g.y = 10;
		g.extendedHulls = {}; g.boundingBoxes = {};

		g = v.pdnGad; g.actionFlags = vp.GAF_CLICKABLE;
		g.convexHull = g.computeHull([0,y+h, 10,y+h, 10,v.h/s-20, 0,v.h/s-20]); g.y = 10;
		g.extendedHulls = {}; g.boundingBoxes = {};
	}
	v.renderFunc = function() {
		var s = this.getScale();
		var sel;
		gl.clearColor(th.uiBackground[0],th.uiBackground[1],th.uiBackground[2], 1);
		gl.clear(gl.COLOR_BUFFER_BIT);
		mainShapes.useProg5();
		gl.enable(gl.BLEND);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uProjectionMatrix'), false, this.mat);
		const mat = mat4.create();
    var selColor = [1,0.1,0.1, 1];
		var white = [1,1,1, 1]

		// Up button.
		if (this.upGad.gestureState && this.upGad.gestureState == 'hold')
			scrollUpDn(startpane.swipeGad, 0.5);
		sel = this.upGad.gestureState
			&& ['begin-click','recover-click','hold'].includes(this.upGad.gestureState);
		gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
			new Float32Array(sel?selColor:white));
		mat4.identity(mat);
		mat4.scale(mat, mat, [10, 10, 0]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uModelViewMatrix'), false, mat);
		mainShapes.drawArrays5('scrollUp');

		// Down button.
		if (this.dnGad.gestureState && this.dnGad.gestureState == 'hold')
			scrollUpDn(startpane.swipeGad, -0.5);
		sel = this.dnGad.gestureState
			&& ['begin-click','recover-click','hold'].includes(this.dnGad.gestureState);
		gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
			new Float32Array(sel?selColor:white));
		mat4.identity(mat);
		mat4.translate(mat, mat, [0, this.h/s, 0]);
		mat4.scale(mat, mat, [10, -10, 0]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uModelViewMatrix'), false, mat);
		mainShapes.drawArrays5('scrollDn');

		// Scroll bar knob.
		gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
			new Float32Array([.1,.1,.1,1]));
		mat4.identity(mat);
		mat4.translate(mat, mat, [4, 10, 0]);
		mat4.scale(mat, mat, [2, this.h/s-20, 0]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uModelViewMatrix'), false, mat);
		mainShapes.drawArrays5('rect');
		sel = this.knobGad.gestureState
			&& (this.knobGad.gestureState=='drag'
				||this.knobGad.gestureState=='drag');
		gl.uniform4fv(gl.getUniformLocation(prog5, 'overallColor'),
			new Float32Array(sel?selColor:white));
		mat4.identity(mat);
		mat4.translate(mat, mat, [3, 10+this.knobGad.convexHull[1], 0]);
		mat4.scale(mat, mat, [4, this.knobGad.convexHull[5]-this.knobGad.convexHull[1], 0]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uModelViewMatrix'), false, mat);
		mainShapes.drawArrays5('divLineH');
	};

  var walletpane = v = new vp.SliceView(null, 'r', 10);
	v.name = Object.keys({walletpane}).pop();
	v.designFit = [400,400];
  v.a = scrollbar; scrollbar.parent = v;
  v.b = startpane; startpane.parent = v;
*/
  var div3and4 = v = new vp.View();
	v.name = Object.keys({div3and4}).pop();
  v.gadgets.push(g = v.middleDividerGad = new vp.MiddleDividerGadget(v)); g.z = 1;
  v.layoutFunc = function() { this.middleDividerGad.layout(); }

  var quadrants3and4 = v = new vp.DividerView(null, 'a', 0.5, 0);
	v.name = Object.keys({quadrants3and4}).pop();
  v.a = quadrant3; quadrant3.parent = v;
  v.b = quadrant4; quadrant4.parent = v;
  v.c = div3and4; div3and4.parent = v;

	var maindivider = v = new vp.View();
	v.name = Object.keys({maindivider}).pop();
	v.designScale = 1;
	v.gadgets.push(g = v.middleDividerGad = new vp.MiddleDividerGadget(v)); g.z = 1;
	v.layoutFunc = function() { this.middleDividerGad.layout(); }
	v.renderFunc = function() {
		const th = config.themeColors;
		gl.clearColor(th.uiBackground[0],th.uiBackground[1],th.uiBackground[2], 1);
		gl.clear(gl.COLOR_BUFFER_BIT);
		mainShapes.useProg5();
		gl.enable(gl.BLEND);
		const mat = mat4.create();
		mat4.identity(mat);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uProjectionMatrix'), false, this.mat);
		mat4.scale(mat, mat, [this.w, this.h, 0]);
		gl.uniformMatrix4fv(gl.getUniformLocation(prog5, 'uModelViewMatrix'), false, mat);
		//mainShapes.drawArrays5('divLine');
		if (this.parent.state == 'v') {
			mainShapes.drawArrays5('divLineV');
		} else {
			mainShapes.drawArrays5('divLineH');
		}
	};

	var menudivider = v = new vp.View();
	v.name = Object.keys({menudivider}).pop();
	v.designScale = 1;
	v.gadgets.push(g = v.middleDividerGad = new vp.MiddleDividerGadget(v)); g.z = 1;
	v.layoutFunc = function() { this.middleDividerGad.layout(); }

  var div = v = new vp.DividerView(null, 'a', 0.5, 1);
	v.name = Object.keys({div}).pop();
  div.designSize = 640*400;
  v.a = startpane; startpane.parent = v;
  v.b = quadrants3and4; quadrants3and4.parent = v;
  v.c = maindivider; maindivider.parent = v;
	const transitionTo = function(view, option = '') {
		v = allblack;
		v.transitionOption = option;
		v.root = menudiv;
		v.state = 'begin';
		v.root.b = v; v.parent = v.root;
		v.root.relayout();
		v.target = view;
		v.setRenderFlag(true);
	};

	var allblack = v = new vp.View(null);
	v.name = Object.keys({allblack}).pop();
	v.renderFunc = function() {
/*
		if (false) {
			if (this.counter)
				console.log('transition state:', this.state, this.counter);
			else
				console.log('transition state:', this.state);
		}
*/
		gl.clearColor(...config.themeColors.uiBackground);
		gl.clear(gl.COLOR_BUFFER_BIT);
		switch (this.state) {
		case 'begin':
			this.counter = 1; this.state = 't1';
			break;
		case 't1':
			this.counter = this.counter - 1;
			if (this.counter <= 0) this.state = 'go fullscreen';
			break;
		case 'go fullscreen':
			this.resized = false;
			if (this.transitionOption == 'max') fullscreen.enter();
			if (this.transitionOption == 'min') fullscreen.exit();
			this.counter = 100; this.state = 't2';
			break;
		case 't2':
			this.counter = this.counter - 1;
			if (this.resized) { this.resized = false; this.counter = 20; }
			if (this.counter <= 0) this.state = 'switch view';
			break;
		case 'switch view':
			this.root.b = this.target; this.target.parent = this.root
			this.root.relayout();
			if (this.target.switchedToFunc) this.target.switchedToFunc();
			this.state = 'done';
			break;
		default:
			return;
		}
		this.root.setRenderFlag(true);
	};
var allblack;

const splash = v = new vp.View(null);
v.name = Object.keys({splash}).pop();

//const home = settingspane;
const menudiv = v = new vp.DividerView(null, 'h', 0, 0);
v.name = Object.keys({menudiv}).pop();
div.designSize = 640*400;
v.b = splash; splash.parent = v;
//v.a = startpane; startpane.parent = v;
v.c = menudivider; menudivider.parent = v;
v.resizeFunc = function() {
	allblack.resized = true;
}
//verticalLayout();
v.layoutFunc = function() {
	if (menudiv.b == hsettingspane || menudiv.b == vsettingspane) {
		if (canvas.width > canvas.height) {
			if (layoutIsVertical()) horizontalLayout();
		} else {
			if (!layoutIsVertical()) verticalLayout();
		}
	}
}

  function checkOnlineOrders() {
    const asyncLogic = async () => {
      const url = config.stallKeys.url
      const stallId = config.stallKeys.stall.id
      const stallKey = config.stallKeys.key
      {
        console.log('checking for orders')
        const response = await fetch(url+'/stall/order/'+stallId+'?api-key='+stallKey, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
          },
        });
        const json = await response.json()
        console.log(json)
        json.sort((a, b) => a.event_created_at - b.event_created_at)
        if (url != config.stallKeys.url || stallId != config.stallKeys.stall.id || stallKey != config.stallKeys.key) return  
        json.map(o => {
          const { id } = o
          var req = db.transaction(["nostrmarket-orders"], "readonly")
            .objectStore("nostrmarket-orders")
            .get(`${getCurrentAccount().id}-${id}`)
          req.onsuccess = (event) => {
            if (event.target.result === undefined) {
              //console.log('new order:', o)

              {
                var currentState = 'saved'
                let subtotal = 0
                o.items.map(item => {
                  const unitprice = o.extra.products.filter(p => p.id === item.product_id)[0].price
                  const qty = item.quantity
                  subtotal += unitprice * qty
                })
                console.log(subtotal)
                const newOrder = {
                  nostrmarketId: id,
                  store: getCurrentAccount().id,
                  status: currentState,
                  date: new Date(),
                  "dataentry": {
                    textbox: '',
                    options: {},
                  },
                  currency: Convert.LNbitsCurrencyToAppCurrency(o.extra.currency),
                  items: o.items.map(item => {
                    return {
                      qty: +item.quantity,
                      unitprice: +o.extra.products.filter(p => p.id === item.product_id)[0].price,
                      options: { emoji: o.extra.products.filter(p => p.id === item.product_id)[0].name },
                    }
                  }),
                  subtotal: subtotal,
                  //amountTendered: receivepayment.cash.text,
                  //amountToReturn: returnchange.change.text,
                };
                // if (JSON.stringify(billpane.conversions) != '{}') {
                //   newItem.conversions = billpane.conversions
                // }
                console.log('Saving', newOrder)
                const tx = db.transaction(["sales"], "readwrite")
                tx.onerror = (event) => { console.log("Save transaction failed.") }
                tx.oncomplete = (event) => { }
                const req = tx.objectStore("sales").add(newOrder)
                req.onerror = (event) => { console.log("Save request failed.") }
                req.onsuccess = (event) => { }
              }

              {
                var req = db.transaction(["nostrmarket-orders"], "readwrite")
                  .objectStore("nostrmarket-orders")
                  .add({ id }, `${getCurrentAccount().id}-${id}`)
                req.onerror = (event) => { console.log("DB write error.") }
                req.onsuccess = (event) => { }
              }
            }
          }
      
        })
      }
    }
    asyncLogic()
    setTimeout(checkOnlineOrders, 60000)
  }
  setTimeout(checkOnlineOrders, 6000)

  if (window.devicePixelRatio > 1) defaultFont.fidelity = Math.max(1, 4 - Math.floor(window.devicePixelRatio));

	vp.start(menudiv);
}
var loadPending = true;
// var emojiReady = false;
function loadCheck() {
  if ( loadPending
    && defaultFont.isReady()
    && iconFont.isReady()
    && dotMatrixFont.isReady()
  ) { loadPending = false; main(); }
}

window.onload = function () {
  defaultFont = new df.GlyphSet();
  defaultFont.loadFromURL(
    "defaultFont",
    loadCheck,
    "data:application/octet-stream;base64,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",
  );
  iconFont = new df.GlyphSet();
  iconFont.loadFromURL(
    "iconFont",
    loadCheck,
    "data:application/octet-stream;base64,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",
  );
  dotMatrixFont = new df.GlyphSet();
  dotMatrixFont.loadFromURL(
    "dotMatrixFont",
    loadCheck,
    "data:application/octet-stream;base64,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",
  );
  financeGraphicsFont = new df.GlyphSet();
  financeGraphicsFont.loadFromURL(
    "financeGraphicsFont",
    loadCheck,
    "data:application/octet-stream;base64,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",
  );
emojiFile = "src/fonts/google-emoji-spritesheet.png";
}
</script>
<meta name="theme-color" content="#000000" />
</head>
<body style="text-align: center; touch-action: none; overflow: hidden; margin: 0; padding: 0;">
  <input id="prev" type="text" style="position:fixed;left:-2000px; display: none;">
  <input id="numpad" type="number" style="position:fixed;left:-2000px;">
  <input id="kb" type="text" style="position:fixed;left:-2000px; display: none;">
  <input id="next" type="text" style="position:fixed;left:-2000px; display: none;">
  <input type="file" id="fileinput" multiple accept="image/*" style="display: none;">
  <canvas id="app1"></canvas>
  <video id="scan1" style="display: none;"></video>
  <canvas id="buf1" style="display: none;"></canvas>
</body>
</html>
